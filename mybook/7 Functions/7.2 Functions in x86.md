# 7.2 Functions in x86

7.2 Functions in x86

The x86 architecture provides a few features to support the implementation of functions. We have already seen that there are labels in x86 so that one can refer to the location of an instruction, as is needed for jump instructions. Labels can also be used to mark the beginning of the instructions for a function. Going further, we can obtain the address of a label by using the leaq instruction. For example, the following puts the address of the inc label into the rbx register:

leaq inc(%rip), %rbx

Recall from section 6.6 that inc(%rip) is an example of instruction-pointer-relative addressing. In section 2.2 we used the callq instruction to jump to functions whose locations were given by a label, such as read_int. To support function calls in this chapter we instead jump to functions whose location are given by an address in a register; that is, we use indirect function calls. The x86 syntax for this is a callq instruction that requires an asterisk before the register name.

callq *%rbx

7.2.1 Calling Conventions The callq instruction provides partial support for implementing functions: it pushes the return address on the stack and it jumps to the target. However, callq does not handle

* parameter passing,
* pushing frames on the procedure call stack and popping them off, or
* determining how registers are shared by different functions.

Regarding parameter passing, recall that the x86-64 calling convention for Unix- based systems uses the following six registers to pass arguments to a function, in the given order:

rdi rsi rdx rcx r8 r9

If there are more than six arguments, then the calling convention mandates using space on the frame of the caller for the rest of the arguments. However, to ease the implementation of efficient tail calls (section 7.2.2), we arrange never to need more than six arguments. The return value of the function is stored in register rax. Regarding frames and the procedure call stack, recall from section 2.2 that the stack grows down and each function call uses a chunk of space on the stack called a frame. The caller sets the stack pointer, register rsp, to the last data item in its frame. The callee must not change anything in the caller’s frame, that is, anything that is at or above the stack pointer. The callee is free to use locations that are below the stack pointer. Recall that we store variables of tuple type on the root stack. So, the prelude of a function needs to move the root stack pointer r15 up according to the number

![Figure 7.6...](images/page_147_vector_324.png)
*Figure 7.6*

of variables of tuple type and the conclusion needs to move the root stack pointer back down. Also, the prelude must initialize to 0 this frame’s slots in the root stack to signal to the garbage collector that those slots do not yet contain a valid pointer. Otherwise the garbage collector will interpret the garbage bits in those slots as memory addresses and try to traverse them, causing serious mayhem! Regarding the sharing of registers between different functions, recall from section 3.1 that the registers are divided into two groups, the caller-saved registers and the callee-saved registers. The caller should assume that all the caller-saved registers are overwritten with arbitrary values by the callee. For that reason we recommend in section 3.1 that variables that are live during a function call should not be assigned to caller-saved registers. On the flip side, if the callee wants to use a callee-saved register, the callee must save the contents of those registers on their stack frame and then put them back prior to returning to the caller. For that reason we recommend in section 3.1 that if the register allocator assigns a variable to a callee-saved register, then the prelude of the main function must save that register to the stack and the conclusion of main must restore it. This recommendation now generalizes to all functions. Recall that the base pointer, register rbp, is used as a point of reference within a frame, so that each local variable can be accessed at a fixed offset from the base pointer (section 2.2). Figure 7.6 shows the layout of the caller and callee frames.

7.2.2 Efficient Tail Calls In general, the amount of stack space used by a program is determined by the longest chain of nested function calls. That is, if function f1 calls f2, f2 calls f3, and so on to fn, then the amount of stack space is linear in n. The depth n can grow quite large if functions are recursive. However, in some cases we can arrange to use only a constant amount of space for a long chain of nested function calls. A tail call is a function call that happens as the last action in a function body. For example, in the following program, the recursive call to tail_sum is a tail call:

```
(define (tail_sum [n : Integer] [r : Integer]) : Integer
(if (eq? n 0)
r
(tail_sum (- n 1) (+ n r))))
```

(+ (tail_sum 3 0) 36)

At a tail call, the frame of the caller is no longer needed, so we can pop the caller’s frame before making the tail call. With this approach, a recursive function that makes only tail calls ends up using a constant amount of stack space. Functional languages like Racket rely heavily on recursive functions, so the definition of Racket requires that all tail calls be optimized in this way. Some care is needed with regard to argument passing in tail calls. As mentioned, for arguments beyond the sixth, the convention is to use space in the caller’s frame for passing arguments. However, for a tail call we pop the caller’s frame and can no longer use it. An alternative is to use space in the callee’s frame for passing arguments. However, this option is also problematic because the caller and callee’s frames overlap in memory. As we begin to copy the arguments from their sources in the caller’s frame, the target locations in the callee’s frame might collide with the sources for later arguments! We solve this problem by using the heap instead of the stack for passing more than six arguments (section 7.5). As mentioned, for a tail call we pop the caller’s frame prior to making the tail call. The instructions for popping a frame are the instructions that we usually place in the conclusion of a function. Thus, we also need to place such code immediately before each tail call. These instructions include restoring the callee-saved registers, so it is fortunate that the argument passing registers are all caller-saved registers. One note remains regarding which instruction to use to make the tail call. When the callee is finished, it should not return to the current function but instead return to the function that called the current one. Thus, the return address that is already on the stack is the right one, and we should not use callq to make the tail call because that would overwrite the return address. Instead we simply use the jmp instruction. As with the indirect function call, we write an indirect jump with a register prefixed with an asterisk. We recommend using rax to hold the jump target because the conclusion can overwrite just about everything else.

jmp *%rax

