# 7.11 Generate Prelude and Conclusion

7.9.1 Liveness Analysis The IndirectCallq instruction should be treated like Callq regarding its written locations W, in that they should include all the caller-saved registers. Recall that the reason for that is to force variables that are live across a function call to be assigned to callee-saved registers or to be spilled to the stack. Regarding the set of read locations R, the arity fields of TailJmp and IndirectCallq determine how many of the argument-passing registers should be considered as read by those instructions. Also, the target field of TailJmp and IndirectCallq should be included in the set of read locations R.

7.9.2 Build Interference Graph With the addition of function definitions, we compute a separate interference graph for each function (not just one for the whole program). Recall that in section 6.7 we discussed the need to spill tuple-typed variables that are live during a call to collect, the garbage collector. With the addition of functions to our language, we need to revisit this issue. Functions that perform allocation contain calls to the collector. Thus, we should not only spill a tuple-typed variable when it is live during a call to collect, but we should spill the variable if it is live during a call to any user-defined function. Thus, in the build_interference pass, we recommend adding interference edges between call-live tuple-typed vari- ables and the callee-saved registers (in addition to creating edges between call-live variables and the caller-saved registers).

7.9.3 Allocate Registers The primary change to the allocate_registers pass is adding an auxiliary func- tion for handling definitions (the def nonterminal shown in figure 7.10) with one case for function definitions. The logic is the same as described in chapter 3 except that now register allocation is performed many times, once for each function definition, instead of just once for the whole program.

7.10 Patch Instructions

In patch_instructions, you should deal with the x86 idiosyncrasy that the desti- nation argument of leaq must be a register. Additionally, you should ensure that the argument of TailJmp is rax, our reserved register—because we trample many other registers before the tail call, as explained in the next section.

7.11 Generate Prelude and Conclusion

Now that register allocation is complete, we can translate the TailJmp into a sequence of instructions. A naive translation of TailJmp would simply be jmp *arg. However, before the jump we need to pop the current frame to achieve efficient tail calls. This sequence of instructions is the same as the code for the conclusion of a function, except that the retq is replaced with jmp *arg.

Regarding function definitions, we generate a prelude and conclusion for each one. This code is similar to the prelude and conclusion generated for the main function presented in chapter 6. To review, the prelude of every function should carry out the following steps:

* Push rbp to the stack and set rbp to current stack pointer.
* Push to the stack all the callee-saved registers that were used for register
  allocation.
* Move the stack pointer rsp down to make room for the regular spills (aligned
  to 16 bytes).
* Move the root stack pointer r15 up by the size of the root-stack frame for this
  function, which depends on the number of spilled tuple-typed variables.
* Initialize to zero all new entries in the root-stack frame.
* Jump to the start block.

The prelude of the main function has an additional task: call the initialize function to set up the garbage collector, and then move the value of the global rootstack_begin in r15. This initialization should happen before step 4, which depends on r15. The conclusion of every function should do the following:

* Move the stack pointer back up past the regular spills.
* Restore the callee-saved registers by popping them from the stack.
* Move the root stack pointer back down by the size of the root-stack frame for
  this function.
* Restore rbp by popping it from the stack.
* Return to the caller with the retq instruction.

The output of this pass is x86callq∗, which differs from x86Def callq∗in that there is no longer an AST node for function definitions. Instead, a program is just an association list of basic blocks, as in x86Global. So we have the following grammar rule: x86callq∗::= (X86Program info ((label . block) … ))

*Figure 7.11*

Exercise 7.1 Expand your compiler to handle LFun as outlined in this chapter. Cre- ate eight new programs that use functions including examples that pass functions and return functions from other functions, recursive functions, functions that cre- ate tuples, and functions that make tail calls. Test your compiler on these new programs and all your previously created test programs.

