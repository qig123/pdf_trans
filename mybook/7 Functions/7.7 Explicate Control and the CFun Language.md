# 7.7 Explicate Control and the CFun Language

![Figure 7.7 Lmon FunRef...](images/page_150_vector_238.png)
*Figure 7.7 Lmon FunRef is LFunRef in monadic normal form.*

![Figure 7.8 defines the...](images/page_150_vector_591.png)
*Figure 7.8 defines the abstract syntax for CFun, the output of explicate_control. The auxiliary functions for assignment and tail contexts should be updated with cases for Apply and FunRef. The auxiliary function for predicate context should be updated for Apply but not FunRef. (A FunRef cannot be a Boolean.) In assign- ment and predicate contexts, Apply becomes Call, whereas in tail position Apply*

![Figure 7.8 The abstract...](images/page_151_vector_323.png)
*Figure 7.8 The abstract syntax of CFun, extending CTup (figure 6.12).*

becomes TailCall. We recommend defining a new auxiliary function for processing function definitions. This code is similar to the case for Program in Lmon Tup. The top- level explicate_control function that handles the ProgramDefs form of Lmon FunRef can apply this new function to all function definitions.

