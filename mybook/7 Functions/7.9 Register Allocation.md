# 7.9 Register Allocation

Instead, add an entry to info that maps num-params to the number of parameters to construct info′. By changing the parameters to local variables, we are giving the register allocator control over which registers or stack locations to use for them. If you implement the move-biasing challenge (section 3.7), the register allocator will try to assign the parameter variables to the corresponding argument register, in which case the patch_instructions pass will remove the movq instruction. This happens in the example translation given in figure 7.12 in section 7.12, in the add function. Also, note that the register allocator will perform liveness analysis on this sequence of move instructions and build the interference graph. So, for example, x1 will be marked as interfering with rsi, and that will prevent the mapping of x1 to rsi, which is good because otherwise the first movq would overwrite the argument in rsi that is needed for x2. Next, consider the compilation of function calls. In the mirror image of the handling of parameters in function definitions, the arguments are moved to the argument-passing registers. Note that the function is not given as a label, but its address is produced by the argument arg0. So, we translate the call into an indirect function call. The return value from the function is stored in rax, so it needs to be moved into the lhs.

lhs = (Call arg0 arg1 arg2 … ) ⇒ movq arg1, %rdi movq arg2, %rsi ... callq *arg0 movq %rax, lhs

The IndirectCallq AST node includes an integer for the arity of the function, that is, the number of parameters. That information is useful in the uncover_live pass for determining which argument-passing registers are potentially read during the call. For tail calls, the parameter passing is the same as non-tail calls: generate instruc- tions to move the arguments into the argument-passing registers. After that we need to pop the frame from the procedure call stack. However, we do not yet know how big the frame is; that gets determined during register allocation. So, instead of generating those instructions here, we invent a new instruction that means “pop the frame and then do an indirect jump,” which we name TailJmp. The abstract syntax for this instruction includes an argument that specifies where to jump and an integer that represents the arity of the function being called.

7.9 Register Allocation

The addition of functions requires some changes to all three aspects of register allocation, which we discuss in the following subsections.

