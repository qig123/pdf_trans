# 11.9 Summary and Concluding Remarks

11.9 Summary and Concluding Remarks 583

was able to eliminate 99 to 100 percent of all copy operations in standard numeric benchmarks [Can92]. Scholz reports performance for SAC competitive with that of carefully optimized modern Fortran programs [Sch03]. Signiﬁcant strides in both the theory and practice of functional programming have been made in recent years. Wadler [Wad98b] argued in the late 1990s that the principal remaining obstacles to the widespread adoption of functional lan- guages were social and commercial, not technical: most programmers have been trained in an imperative style; software libraries and development environments for functional programming are not yet as mature as those of their imperative cousins. Experience over the past decade appears to have borne out this charac- terization: with the development of better tools and a growing body of practical experience, functional languages have begun to see much wider use. Functional features have also begun to appear in such mainstream imperative languages as C#, Python, and Ruby.

3CHECK YOUR UNDERSTANDING 19. What is the difference between normal-order and applicative-order evaluation? What is lazy evaluation?

20. What is the difference between a function and a special form in Scheme? 21. What does it mean for a function to be strict? 22. What is memoization?

23. How can one accommodate I/O in a purely functional programming model? 24. What is a higher-order function (also known as a functional form)? Give three examples. 25. What is currying? What purpose does it serve in practical programs?

26. What is the trivial update problem in functional programming? 27. Summarize the arguments for and against side-effect-free programming.

28. Why do functional languages make such heavy use of lists?

11.9 Summary and Concluding Remarks

In this chapter we have focused on the functional model of computing. Where an imperative program computes principally through iteration and side effects (i.e., the modiﬁcation of variables), a functional program computes principally through substitution of parameters into functions. We began by enumerating a list of key issues in functional programming, including ﬁrst-class and higher- order functions, polymorphism, control ﬂow and evaluation order, and support

