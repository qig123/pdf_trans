# 11.3 A Bit of Scheme

11.3 A Bit of Scheme
**539**

Because Lisp was the original functional language, and is still one of the most
widely used, several characteristics of Lisp are commonly, though inaccurately,
described as though they pertained to functional programming in general. We
will examine these characteristics (in the context of Scheme) in Section 11.3. They
include

Homogeneity of programs and data: A program in Lisp is itself a list, and can
be manipulated with the same mechanisms used to manipulate data.
Self-deﬁnition: The operational semantics of Lisp can be deﬁned elegantly in
terms of an interpreter written in Lisp.
Interaction with the user through a “read-eval-print” loop.

Many programmers—probably most—who have written signiﬁcant amounts
of software in both imperative and functional styles ﬁnd the latter more aestheti-
cally appealing. Moreover, experience with a variety of large commercial projects
(see the Bibliographic Notes at the end of the chapter) suggests that the absence
of side effects makes functional programs signiﬁcantly easier to write, debug, and
maintain than their imperative counterparts. When passed a given set of argu-
ments, a pure function can always be counted on to return the same results. Is-
sues of undocumented side effects, misordered updates, and dangling or (in most
cases) uninitialized references simply don’t occur. At the same time, many imple-
mentations of functional languages still fall short in terms of portability, richness
of library packages, interfaces to other languages, and debugging and proﬁling
tools. We will return to the tradeoffs between functional and imperative pro-
gramming in Section 11.8.
## 11.3

**A Bit of Scheme**
Scheme was originally developed by Guy Steele and Gerald Sussman in the late
1970s, and has evolved through several revisions. The description here follows
the 1998 R5RS (ﬁfth revised standard), and should also be compliant with the
2013 R7RS.
Most Scheme implementations employ an interpreter that runs a “read-eval-
print” loop. The interpreter repeatedly reads an expression from standard input
(generally typed by the user), evaluates that expression, and prints the resulting
value. If the user types
**EXAMPLE** 11.1

```
The read-eval-print loop
(+ 3 4)
```

the interpreter will print

```
7
```

If the user types

```
eval: 7 is not a procedure
```

Unlike the situation in almost all other programming languages, extra parenthe-
ses change the semantics of Lisp/Scheme programs:

```
(+ 3 4)
=⇒7
((+ 3 4))
=⇒error
```

Here the =*⇒*means “evaluates to.” This symbol is not a part of the syntax of
Scheme itself.
■
One can prevent the Scheme interpreter from evaluating a parenthesized ex-
**EXAMPLE** 11.3

Quoting
pression by* quoting* it:

```
(quote (+ 3 4))
=⇒(+ 3 4)
```

Here the result is a three-element list. More commonly, quoting is speciﬁed with
a special shorthand notation consisting of a leading single quote mark:

```
'(+ 3 4)
=⇒(+ 3 4)
■
```

Though every expression has a type in Scheme, that type is generally not de-
termined until run time. Most predeﬁned functions check dynamically to make
**EXAMPLE** 11.4

Dynamic typing
sure that their arguments are of appropriate types. The expression

