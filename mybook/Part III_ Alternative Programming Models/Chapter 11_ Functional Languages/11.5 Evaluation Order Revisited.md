# 11.5 Evaluation Order Revisited

### 11.5 Evaluation Order Revisited

### **567**

q0

Start
q1

q2

b

a
a
a
a

b

b

b
q3

```
let a_b_even_dfa : char dfa =
{ current_state = 0;
transition_function =
[ (0, 'a', 2); (0, 'b', 1); (1, 'a', 3); (1, 'b', 0);
(2, 'a', 0); (2, 'b', 3); (3, 'a', 1); (3, 'b', 2) ];
final_states = [0];
};;
```


![Figure 11.4 DFA to...](images/page_600_vector_262.png)
*Figure 11.4 DFA to accept all strings of as and bs containing an even number of each. At the bottom of the ﬁgure is a representation of the machine as an OCaml data structure, using the conventions of Figure 11.3. 11.5 Evaluation Order Revisited*

### In Section 6.6.2 we observed that the subcomponents of many expressions can

### be evaluated in more than one order. In particular, one can choose to evaluate

### function arguments before passing them to a function, or to pass them unevalu-

### ated. The former option is called* applicative-order* evaluation; the latter is called

### *normal-order* evaluation. Like most imperative languages, Scheme and OCaml

### use applicative order in most cases. Normal order, which arises in the macros and

### call-by-name parameters of imperative languages, is available in special cases.

### Suppose, for example, that we have deﬁned the following function in Scheme:

**EXAMPLE** 11.55
```
Applicative and
normal-order evaluation
(define double (lambda (x) (+ x x)))
```

```
Evaluating the expression (double (* 3 4)) in applicative order (as Scheme
does), we have
```

```
(double (* 3 4))
=⇒(double 12)
=⇒(+ 12 12)
=⇒24
```

### Under normal-order evaluation we would have

