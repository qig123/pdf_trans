# 11.11 Explorations

11.11 Explorations
**589**

```
let rec next_int n = (n, Promise (fun() -> next_int (n + 1)));;
let naturals = Promise (fun() -> next_int (1));;
```

we have

```
head naturals;;
=⇒1
head (rest naturals);;
=⇒2
head (rest (rest naturals));;
=⇒3
...
```

```
The delayed list naturals is effectively of unlimited length. It will be
computed out only as far as actually needed. If a value is needed more
than once, however, it will be recomputed every time.
Show how to
use pointers and assignment (Example 8.42) to memoize the values of a
delayed_list, so that elements are computed only once.
11.19
Write an OCaml version of Example 11.67. Alternatively (or in addition),
solve Exercises 11.5, 11.7, 11.8, 11.10, 11.13, 11.14, or 11.15 in OCaml.
```

11.20–11.23 In More Depth.
## 11.11

**Explorations**
```
11.24
Read the original self-deﬁnition of Lisp [MAE+65]. Compare it to a sim-
ilar deﬁnition of Scheme [AS96, Chap. 4]. What is different? What has
stayed the same? What is built into apply and eval in each deﬁnition?
What do you think of the whole idea? Does a metacircular interpreter
really deﬁne anything, or is it “circular reasoning”?
11.25
Read the Turing Award lecture of John Backus [Bac78], in which he argues
for functional programming. How does his FP notation compare to the
Lisp and ML language families?
11.26
Learn more about monads in Haskell. Pay particular attention to the def-
inition of lists. Explain the relationship of the list monad to list com-
prehensions (Example 8.58), iterators, continuations (Section 6.2.2), and
backtracking search.
11.27
Read ahead and learn about transactional memory (Section 13.4.4). Then
read up on STM Haskell [HMPH05]. Explain how monads facilitate the
serialization of updates to locations shared between threads.
11.28
We have seen that Lisp and ML include such imperative features as assign-
ment and iteration. How important are these? What do languages like
Haskell give up (conversely, what do they gain) by insisting on a purely
functional programming style? In a similar vein, what do you think of at-
tempts in several recent imperative languages (notably Python and C#—
see Sidebar 11.6) to facilitate functional programming with function con-
structors and unlimited extent?
```

