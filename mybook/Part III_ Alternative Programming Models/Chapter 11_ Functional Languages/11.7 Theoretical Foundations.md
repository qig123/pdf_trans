# 11.7 Theoretical Foundations

580 Chapter 11 Functional Languages

To obtain the behavior of the built-in fold_left, we need to assume that the function f is also curried:

# let rec fold_left f i l = match l with | [] -> i | h :: t -> fold_left f (f i h) t;; val fold_left : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a = <fun> # fold_left curried_plus 0 [1;2;3;4;5];; - : int = 15

Note again the difference in the inferred type of the functions. ■ It is of course possible to deﬁne fold_left by nesting occurrences of the ex- plicit fun notation within the function’s body. The shorthand notation, with juxtaposed arguments, however, is substantially more intuitive and convenient. Note also that OCaml’s syntax for function calls—juxtaposition of function and EXAMPLE 11.75

Currying in OCaml vs Scheme argument—makes the use of a curried function more intuitive and convenient than it is in Scheme:

fold_left (+) 0 [1; 2; 3; 4; 5]; (* OCaml *) (((curried-fold +) 0) '(1 2 3 4 5)) ; Scheme ■

11.7 Theoretical Foundations

Mathematically, a function is a single-valued mapping: it associates every element in one set (the domain) with (at most) one element in another set (the range). In EXAMPLE 11.76

conventional notation, we indicate the domain and range of, say, the square root function by writing

Declarative (nonconstructive) function deﬁnition

sqrt : R −→R

We can also deﬁne functions using conventional set notation:

sqrt ≡  (x, y) ∈R × R | y > 0 ∧x = y2

Unfortunately, this notation is nonconstructive: it doesn’t tell us how to com- pute square roots. Church designed the lambda calculus to address this limita- tion. ■

IN MORE DEPTH

Lambda calculus is a constructive notation for function deﬁnitions. We consider it in more detail on the companion site. Any computable function can be written as

