# 11.10 Exercises

**584**
Chapter 11* Functional Languages*

for list-based data. We then turned to a pair of concrete examples—the Scheme
dialect of Lisp and the OCaml dialect of ML—to see how these issues may be
addressed in a programming language. We also considered, more brieﬂy, the lazy
evaluation and monads found in Haskell.
For imperative programming languages, the underlying formal model is often
taken to be a Turing machine. For functional languages, the model is the lambda
calculus. Both models evolved in the mathematical community as a means of
formalizing the notion of an effective procedure, as used in constructive proofs.
Aside from hardware-imposed limits on arithmetic precision, disk and memory
space, and so on, the full power of lambda calculus is available in functional
languages. While a full treatment of the lambda calculus could easily consume
another book, we provided an overview on the companion site. We considered
rewrite rules, evaluation order, and the Church-Rosser theorem. We noted that
conventions on the use of very simple notation provide the computational power
of integer arithmetic, selection, recursion, and structured data types.
For practical reasons, many functional languages extend the lambda calculus
with additional features, including assignment, I/O, and iteration. Lisp dialects,
moreover, are* homoiconic*: programs look like ordinary data structures, and can
be created, modiﬁed, and executed on the ﬂy.
Lists feature prominently in most functional programs, largely because they
can easily be built incrementally, without the need to allocate and then modify
state as separate operations. Many functional languages provide other structured
data types as well. In Sisal and Single Assignment C, an emphasis on iterative
syntax, tail-recursive semantics, and high-performance compilers allows multidi-
mensional array-based functional programs to achieve performance comparable
to that of imperative programs.
## 11.10

**Exercises**
```
11.1
Is the define primitive of Scheme an imperative language feature? Why
or why not?
11.2
It is possible to write programs in a purely functional subset of an imper-
ative language such as C, but certain limitations of the language quickly
become apparent. What features would need to be added to your favorite
imperative language to make it genuinely useful as a functional language?
(Hint: What does Scheme have that C lacks?)
11.3
Explain the connection between short-circuit Boolean expressions and
normal-order evaluation. Why is cond a special form in Scheme, rather
than a function?
11.4
Write a program in your favorite imperative language that has the same in-
put and output as the Scheme program of Figure 11.1. Can you make any
general observations about the usefulness of Scheme for symbolic compu-
tation, based on your experience?
```

```
Write a similar function that uses the imperative features of Scheme to
modify L “in place,” rather than building a new list. Compare your func-
tion to the code above in terms of brevity, conceptual clarity, and speed.
11.6
Write tail-recursive versions of the following:
(a)
;; compute integer log, base 2
;; (number of bits in binary representation)
;; works only for positive integers
(define log2
(lambda (n)
(if (= n 1) 1 (+ 1 (log2 (quotient n 2))))))
```

```
(b)
;; find minimum element in a list
(define min
(lambda (l)
(cond
((null? l) '())
((null? (cdr l)) (car l))
(#t (let ((a (car l))
(b (min (cdr l))))
(if (< b a) b a))))))
11.7
Write purely functional Scheme functions to
(a) return all rotations of a given list. For example, (rotate ‚(a b c d
e)) should return ((a b c d e) (b c d e a) (c d e a b) (d e a
b c) (e a b c d)) (in some order).
(b) return a list containing all elements of a given list that satisfy a given
predicate. For example, (filter (lambda (x) (< x 5)) ‚(3 9 5 8
2 4 7)) should return (3 2 4).
11.8
Write a purely functional Scheme function that returns a list of all permu-
tations of a given list. For example, given (a b c), it should return ((a b
c) (b a c) (b c a) (a c b) (c a b) (c b a)) (in some order).
11.9
Modify the Scheme program of Figure 11.1 or the OCaml program of Fig-
ure 11.3 to simulate an NFA (nondeterministic ﬁnite automaton), rather
than a DFA. (The distinction between these automata is described in Sec-
tion 2.2.1.) Since you cannot “guess” correctly in the face of a multivalued
```

```
Now we can deﬁne the driver to expect an “ostream”—an empty list or a
pair, the cdr of which is an ostream:
```

```
(define driver
(lambda (s)
(if (null? s) '()
(display (car s))
(driver (force (cdr s))))))
```

```
Note the use of force.
Show how to write the function squares so that it takes an istream
as argument and returns an ostream. You should then be able to type
(driver (squares (input))) and see appropriate behavior.
11.12
Write new versions of cons, car, and cdr that operate on streams. Us-
ing them, rewrite the code of the previous exercise to eliminate the calls
to delay and force. Note that the stream version of cons will need to
avoid evaluating its second argument; you will need to learn how to deﬁne
macros (derived special forms) in Scheme.
```

