# 11.1 Historical Origins

**536**
Chapter 11* Functional Languages*

formance depend heavily on the evaluation rules for parameters (Section 6.6.2).
All have a tendency to generate signiﬁcant amounts of temporary data, which
their implementations reclaim through garbage collection (Section 8.5.3).
Our chapter begins with a brief introduction to the historical origins of the im-
perative, functional, and logic programming models. We then enumerate funda-
mental concepts in functional programming and consider how these are realized
in the Scheme dialect of Lisp and the OCaml dialect of ML. More brieﬂy, we also
consider Common Lisp, Erlang, Haskell, Miranda, pH, Single Assignment C, and
Sisal. We pay particular attention to issues of evaluation order and higher-order
functions. For those with an interest in the theoretical foundations of functional
programming, we provide (on the companion site) an introduction to functions,
sets, and the lambda calculus. The formalism helps to clarify the notion of a pure
functional language, and illuminates the places where practical languages diverge
from the mathematical abstraction.
## 11.1

**Historical Origins**
To understand the differences among programming models, it can be helpful to
consider their theoretical roots, all of which predate the developmentof electronic
computers. The imperative and functional models grew out of work undertaken
by mathematicians Alan Turing, Alonzo Church, Stephen Kleene, Emil Post, and
others in the 1930s. Working largely independently, these individuals developed
several very different formalizations of the notion of an algorithm, or* effective*
*procedure*, based on automata, symbolic manipulation, recursive function deﬁni-
tions, and combinatorics. Over time, these various formalizations were shown to
be equally powerful: anything that could be computed in one could be computed
in the others. This result led Church to conjecture that* any* intuitively appealing
model of computing would be equally powerful as well; this conjecture is known
as* Church’s thesis*.
Turing’s model of computing was the* Turing machine*, an automaton reminis-
cent of a ﬁnite or pushdown automaton, but with the ability to access arbitrary
cells of an unbounded storage “tape.”1 The Turing machine computes in an im-
perative way, by changing the values in cells of its tape, just as a high-level im-
perative program computes by changing the values of variables. Church’s model
of computing is called the* lambda calculus*. It is based on the notion of param-
eterized expressions (with each parameter introduced by an occurrence of the

**1**
Alan Turing (1912–1954), after whom the Turing Award is named, was a British mathematician,
philosopher, and computer visionary. As intellectual leader of Britain’s cryptanalytic group dur-
ing World War II, he was instrumental in cracking the German “Enigma” code and turning the
tide of the war. He also helped lay the theoretical foundations of modern computer science, con-
ceived the general-purpose electronic computer, and pioneered the ﬁeld of Artiﬁcial Intelligence.
Persecuted as a homosexual after the war, stripped of his security clearance, and sentenced to
“treatment” with drugs, he committed suicide.

