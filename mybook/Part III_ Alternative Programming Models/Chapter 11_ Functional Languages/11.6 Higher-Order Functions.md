# 11.6 Higher-Order Functions

11.6 Higher-Order Functions

A function is said to be a higher-order function (also called a functional form) if it takes a function as an argument, or returns a function as a result. We have seen several examples already of higher-order functions in Scheme: call/cc (Sec- tion 6.2.2), for-each (Example 11.18), compose (Example 11.19), and apply (Section 11.3.5). We also saw a Haskell version of the higher-order function map in Section 11.5.2. The Scheme version of map is slightly more general. Like EXAMPLE 11.64

map function in Scheme for-each, it takes as argument a function and a sequence of lists. There must be as many lists as the function takes arguments, and the lists must all be of the same length. Map calls its function argument on corresponding sets of elements from the lists:

(map * '(2 4 6) '(3 5 7)) =⇒(6 20 42)

Where for-each is executed for its side effects, and has an implementation- dependent return value, map is purely functional: it returns a list composed of the values returned by its function argument. ■ Programmers in Scheme (or in OCaml, Haskell, or other functional languages) can easily deﬁne other higher-order functions. Suppose, for example, that we EXAMPLE 11.65

Folding (reduction) in Scheme want to be able to “fold” the elements of a list together, using an associative binary operator:

(define fold (lambda (f i l) (if (null? l) i ; i is commonly the identity element for f (f (car l) (fold f i (cdr l))))))

Now (fold + 0 ‚(1 2 3 4 5)) gives us the sum of the ﬁrst ﬁve natural numbers, and (fold * 1 ‚(1 2 3 4 5)) gives us their product. ■ A similar fold_left function is deﬁned by OCaml’s List module: EXAMPLE 11.66

Folding in OCaml fold_left (+) 0 [1; 2; 3; 4; 5];; =⇒15 fold_left ( * ) 1 [1; 2; 3; 4; 5];; =⇒120

(The spaces around * are required to distinguish it from a comment delimiter.) For non associative operators, an analogous fold_right function folds the list from right-to-left. It is not tail-recursive, however, and tends to be used less of- ten. ■ One of the most common uses of higher-order functions is to build new func- EXAMPLE 11.67

Combining higher-order functions tions from existing ones:

(define total (lambda (l) (fold + 0 l))) (total '(1 2 3 4 5)) =⇒15

(define total-all (lambda (l) (map total l))) (total-all '((1 2 3 4 5) (2 4 6 8 10) (3 6 9 12 15))) =⇒(15 30 45)

(define make-double (lambda (f) (lambda (x) (f x x)))) (define twice (make-double +)) (define square (make-double *)) ■

Currying

A common operation, named for logician Haskell Curry, is to replace a multiargu- EXAMPLE 11.68

Partial application with currying ment function with a function that takes a single argument and returns a function that expects the remaining arguments:

(define curried-plus (lambda (a) (lambda (b) (+ a b)))) ((curried-plus 3) 4) =⇒7 (define plus-3 (curried-plus 3)) (plus-3 4) =⇒7

Among other things, currying gives us the ability to pass a “partially applied” function to a higher-order function:

(map (curried-plus 3) '(1 2 3)) =⇒(4 5 6) ■

It turns out that we can write a general-purpose function in Scheme that “cur- EXAMPLE 11.69

General-purpose curry function ries” its (binary) function argument:

(define curry (lambda (f) (lambda (a) (lambda (b) (f a b))))) (((curry +) 3) 4) =⇒7 (define curried-plus (curry +)) ■

DESIGN & IMPLEMENTATION

11.6 Higher-order functions If higher-order functions are so powerful and useful, why aren’t they more common in imperative programming languages? There would appear to be at least two important answers. First, much of the power of ﬁrst-class func- tions depends on the ability to create new functions on the ﬂy, and for that we need a function constructor—something like Scheme’s lambda or OCaml’s fun. Though they appear in several recent languages, function constructors are a signiﬁcant departure from the syntax and semantics of traditional im- perative languages. Second, the ability to specify functions as return values, or to store them in variables (if the language has side effects), requires either that we eliminate function nesting (something that would again erode the abil- ity of programs to create functions with desired behaviors on the ﬂy) or that we give local variables unlimited extent, thereby increasing the cost of storage management.

ML and its descendants make it especially easy to deﬁne curried functions— a fact that we glossed over in Section 11.4. Consider the following function in EXAMPLE 11.70

Tuples as OCaml function arguments OCaml:

# let plus (a, b) = a + b;; val plus : int * int -> int = <fun>

The ﬁrst line here, which we have shown beginning with a # prompt, is entered by the user. The second line is printed by the OCaml interpreter, and indicates the inferred type of plus. Though one may think of plus as a function of two arguments, the OCaml deﬁnition says that all functions take a single argument. What we have declared is a function that takes a two-element tuple as argument. To call plus, we juxtapose its name and the tuple that is its argument:

# plus (3, 4);; - : int = 7

The parentheses here are not part of the function call syntax; they delimit the tuple (3, 4). ■ We can declare a single-argument function without parenthesizing its formal EXAMPLE 11.71

Optional parentheses on singleton arguments argument:

# let twice n = n + n;; val twice = fn : int -> int # twice 2;; - : int = 4

We can add parenthesesin either the declaration or the call if we want, but because there is no comma inside, no tuple is implied:

# let double (n) = n + n;; val double : int -> int = <fun> # twice (2);; - : int = 4 # twice 2;; - : int = 4 # double (2);; - : int = 4 # double 2;; - : int = 4

Ordinary parentheses can be placed around any expression in OCaml. ■ Now consider the deﬁnition of a curried function: EXAMPLE 11.72

Simple curried function in OCaml # let curried_plus a = fun b -> a + b;; val curried_plus : int -> int -> int = <fun>

Here the type of curried_plus is the same as that of the built-in + in Exam- ple 11.23—namely int -> int -> int. This groups implicitly as int -> (int -> int). Where plus is a function mapping a pair (tuple) of integers to an inte- ger, curried_plus is a function mapping an integer to a function that maps an integer to an integer:

# curried_plus 3;; - : int -> int = <fun>

# plus 3;; Error: This expression has type int but an expression was expected of type int * int ■

To make it easier to declare functions like curried_plus, ML-family lan- EXAMPLE 11.73

Shorthand notation for currying guages, OCaml among them, allow a sequence of operands in the formal param- eter position of a function declaration:

# let curried_plus a b = a + b;; val curried_plus : int -> int -> int = <fun>

This form is simply shorthand for the declaration in the previous example; it does not declare a function of two arguments. Curried_plus has a single formal parameter, a. Its return value is a function with formal parameter b that in turn returns a + b. ■ Using tuple notation, a naive, non-curried fold function might be declared as EXAMPLE 11.74

Building fold_left in OCaml follows in OCaml:

# let rec fold (f, i, l) = match l with | [] -> i | h :: t -> fold (f, f (i, h), t);; val fold : ('a * 'b -> 'b) * 'b * 'a list -> 'b = <fun>

A curried version might be declared as follows:

# let rec curried_fold f i l = match l with | [] -> i | h :: t -> curried_fold f (f (i, h)) t;; val curried_fold : ('a * 'b -> 'a) -> 'a -> 'b list -> 'a = <fun>

Note the difference in the inferred types of the functions. The advantage of the curried version is its ability to accept a partial list of arguments:

# curried_fold plus;; - : int -> int list -> int = <fun> # curried_fold plus 0;; - : int list -> int = <fun> # curried_fold plus 0 [1; 2; 3; 4; 5];; - : int = 15

