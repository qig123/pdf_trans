# 11.6 Higher-Order Functions

**576**
Chapter 11* Functional Languages*

## 11.6

**Higher-Order Functions**
```
A function is said to be a higher-order function (also called a functional form) if it
takes a function as an argument, or returns a function as a result. We have seen
several examples already of higher-order functions in Scheme: call/cc (Sec-
tion 6.2.2), for-each (Example 11.18), compose (Example 11.19), and apply
(Section 11.3.5). We also saw a Haskell version of the higher-order function map
in Section 11.5.2. The Scheme version of map is slightly more general. Like
EXAMPLE 11.64
```

```
map function in Scheme
for-each, it takes as argument a function and a sequence of lists. There must
be as many lists as the function takes arguments, and the lists must all be of the
same length. Map calls its function argument on corresponding sets of elements
from the lists:
```

```
(map * '(2 4 6) '(3 5 7))
=⇒(6 20 42)
```

```
Where for-each is executed for its side effects, and has an implementation-
dependent return value, map is purely functional: it returns a list composed of
the values returned by its function argument.
■
Programmers in Scheme (or in OCaml, Haskell, or other functional languages)
can easily deﬁne other higher-order functions. Suppose, for example, that we
EXAMPLE 11.65
```

Folding (reduction) in
Scheme
want to be able to “fold” the elements of a list together, using an associative binary
operator:

```
(define fold
(lambda (f i l)
(if (null? l) i
; i is commonly the identity element for f
(f (car l) (fold f i (cdr l))))))
```

```
Now (fold + 0 ‚(1 2 3 4 5)) gives us the sum of the ﬁrst ﬁve natural numbers,
and (fold * 1 ‚(1 2 3 4 5)) gives us their product.
■
A similar fold_left function is deﬁned by OCaml’s List module:
EXAMPLE 11.66
```

```
Folding in OCaml
fold_left (+) 0 [1; 2; 3; 4; 5];;
=⇒15
fold_left ( * ) 1 [1; 2; 3; 4; 5];;
=⇒120
```

```
(The spaces around * are required to distinguish it from a comment delimiter.)
For non associative operators, an analogous fold_right function folds the list
from right-to-left. It is not tail-recursive, however, and tends to be used less of-
ten.
■
One of the most common uses of higher-order functions is to build new func-
EXAMPLE 11.67
```

Combining higher-order
functions
tions from existing ones:

```
(define total (lambda (l) (fold + 0 l)))
(total '(1 2 3 4 5))
=⇒15
```

```
11.6 Higher-order functions
If higher-order functions are so powerful and useful, why aren’t they more
common in imperative programming languages? There would appear to be
at least two important answers. First, much of the power of ﬁrst-class func-
tions depends on the ability to create new functions on the ﬂy, and for that
we need a function constructor—something like Scheme’s lambda or OCaml’s
fun. Though they appear in several recent languages, function constructors
are a signiﬁcant departure from the syntax and semantics of traditional im-
perative languages. Second, the ability to specify functions as return values,
or to store them in variables (if the language has side effects), requires either
that we eliminate function nesting (something that would again erode the abil-
ity of programs to create functions with desired behaviors on the ﬂy) or that
we give local variables unlimited extent, thereby increasing the cost of storage
management.
```

