# 11.2 Functional Programming Concepts

11.2 Functional Programming Concepts
**537**

letter* λ*—hence the notation’s name).2 Lambda calculus was the inspiration for
functional programming: one uses it to compute by substituting parameters into
expressions, just as one computes in a high-level functional program by passing
arguments to functions. The computing models of Kleene and Post are more ab-
stract, and do not lend themselves directly to implementation as a programming
language.
The goal of early work in computability was not to understand computers
(aside from purely mechanical devices, computers did not exist) but rather to
formalize the notion of an effective procedure. Over time, this work allowed
mathematicians to formalize the distinction between a* constructive* proof (one
that shows how to obtain a mathematical object with some desired property) and
a* nonconstructive* proof (one that merely shows that such an object must exist,
perhaps by contradiction, or counting arguments, or reduction to some other
theorem whose proof is nonconstructive). In effect, a program can be seen as
a constructive proof of the proposition that, given any appropriate inputs, there
exist outputs that are related to the inputs in a particular, desired way. Euclid’s al-
gorithm, for example, can be thought of as a constructive proof of the proposition
that every pair of non-negative integers has a greatest common divisor.
Logic programming is also intimately tied to the notion of constructive proofs,
but at a more abstract level. Rather than write a general constructive proof that
works for all appropriate inputs, the logic programmer writes a set of* axioms*
that allow the* computer* to discover a constructive proof for each particular set of
inputs. We will consider logic programming in more detail in Chapter 12.
## 11.2

**Functional Programming Concepts**
In a strict sense of the term,* functional programming* deﬁnes the outputs of a
program as a mathematical function of the inputs, with no notion of internal
state, and thus no side effects. Among the languages we consider here, Miranda,
Haskell, pH, Sisal, and Single Assignment C are purely functional. Erlang is nearly
so. Most others include imperative features. To make functional programming
practical, functional languages provide a number of features that are often miss-
ing in imperative languages, including

First-class function values and higher-order functions
Extensive polymorphism
List types and operators

**2**
Alonzo Church (1903–1995) was a member of the mathematics faculty at Princeton University
from 1929 to 1967, and at UCLA from 1967 to 1990. While at Princeton he supervised the doc-
toral theses of, among many others, Alan Turing, Stephen Kleene, Michael Rabin, and Dana
Scott. His codiscovery, with Turing, of undecidable problems was a major breakthrough in un-
derstanding the limits of mathematics.

