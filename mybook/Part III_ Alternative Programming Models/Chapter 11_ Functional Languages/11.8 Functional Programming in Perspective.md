# 11.8 Functional Programming in Perspective

11.8 Functional Programming in Perspective
**581**

a lambda expression. Computation amounts to macro substitution of arguments
into the function deﬁnition, followed by reduction to simplest form via simple
and mechanical rewrite rules. The order in which these rules are applied captures
the distinction between applicative and normal-order evaluation, as described
in Section 6.6.2. Conventions on the use of certain simple functions (e.g., the
identity function) allow selection, structures, and even arithmetic to be captured
as lambda expressions. Recursion is captured through the notion of* ﬁxed points*.

## 11.8

**Functional Programming in Perspective**
Side-effect-free programming is a very appealing idea. As discussed in Sections
6.1.2 and 6.3, side effects can make programs both hard to read and hard to com-
pile. By contrast, the lack of side effects makes expressions* referentially transpar-*
*ent*—independent of evaluation order. Programmers and compilers of a purely
functional language can employ* equational reasoning*, in which the equivalence of
two expressions at any point in time implies their equivalence at all times. Equa-
tional reasoning in turn is highly appealing for parallel execution: In a purely
functional language, the arguments to a function can safely be evaluated in paral-
lel with each other. In a lazy functional language, they can be evaluated in parallel
with (the beginning of) the function to which they are passed. We will consider
these possibilities further in Section 13.4.5.
Unfortunately, there are common programming idioms in which the canonical
side effect—assignment—plays a central role. Critics of functional programming
often point to these idioms as evidence of the need for imperative language fea-
tures. I/O is one example. We have seen (in Section 11.5) that sequential access
to ﬁles can be modeled in a functional manner using streams. For graphics and
random ﬁle access we have also seen that the monads of Haskell can cleanly isolate
the invocation of actions from the bulk of the language, and allow the full power
of equational reasoning to be applied to both the computation of values and the
determination of the order in which I/O actions should occur.
Other commonly cited examples of “naturally imperative” idioms include

*Initialization of complex structures:* The heavy reliance on lists in the Lisp and ML
families reﬂects the ease with which functions can build new lists out of the
components of old lists. Other data structures—multidimensional arrays in
particular—are much less easy to put together incrementally, particularly if
the natural order in which to initialize the elements is not strictly row-major
or column-major.
*Summarization:* Many programs include code that scans a large data structure
or a large amount of input data, counting the occurrences of various items or
patterns. The natural way to keep track of the counts is with a dictionary data
structure in which one repeatedly updates the count associated with the most
recently noticed key.

