# 12.2 Prolog

12.2 Prolog
**593**

## 12.2

**Prolog**
Much as an imperative or functional language interpreter evaluates expressions
in the context of a referencing environment in which various functions and con-
stants have been deﬁned, a Prolog interpreter runs in the context of a* database*
of* clauses* (Horn clauses) that are assumed to be true.3 Each clause is composed
of* terms*, which may be constants, variables, or* structures*. A constant is either an
atom or a number. A structure can be thought of as either a logical predicate or a
data structure.
Atoms in Prolog are similar to symbols in Lisp. Lexically, an atom looks like
**EXAMPLE** 12.4

Atoms, variables, scope,
and type
an identiﬁer beginning with a lowercase letter, a sequence of “punctuation” char-
acters, or a quoted character string:

```
foo
my_Const
+
'Hi, Mom'
```

Numbers resemble the integers and ﬂoating-point constants of other program-
ming languages. A variable looks like an identiﬁer beginning with an uppercase
letter:

```
Foo
My_var
X
```

Variables can be* instantiated* to (i.e., can take on) arbitrary values at run time as a
result of uniﬁcation. The scope of every variable is limited to the clause in which
it appears. There are no declarations. Type checking is dynamic: it occurs only
when a program attempts to use a value as an operand at run time.
■
Structures consist of an atom called the* functor* and a list of arguments:
**EXAMPLE** 12.5

```
Structures and predicates
rainy(rochester)
teaches(scott, cs254)
bin_tree(foo, bin_tree(bar, glarch))
```

```
Prolog requires the opening parenthesis to come immediately after the functor,
with no intervening space. Arguments can be arbitrary terms: constants, vari-
ables, or (nested) structures. Internally, a typical Prolog implementation will rep-
resent each structure as a tree of Lisp-like cons cells. Conceptually, the program-
mer may prefer to think of certain structures (e.g., rainy) as logical predicates.
We use the term “predicate” to refer to the combination of a functor and an “ar-
ity” (number of arguments). The predicate rainy has arity 1. The predicate
teaches has arity 2.
■
The clauses in a Prolog database can be classiﬁed as facts or rules, each of which
ends with a period. A fact is a Horn clause without a right-hand side. It looks like
EXAMPLE 12.6
```

Facts and rules
a single term (the implication symbol is implicit):

**3**
In fact, for any given program, the database is assumed to characterize* everything* that is true. As
we shall see in Section 12.4.3, this* closed world assumption* imposes certain limits on the expres-
siveness of the language.

the query

```
?- snowy(C).
```

will yield only one solution.
■

```
Like equality checking, list manipulation is a sufﬁciently common operation in
Prolog to warrant its own notation. The construct [a, b, c] is syntactic sugar
EXAMPLE 12.12
```

```
List notation in Prolog
for the structure .(a, .(b, .(c, []))), where [] is the empty list and . is
a built-in cons-like predicate. With minor syntactic differences (parentheses v.
brackets; commas v. semicolons), this notation should be familiar to users of ML
or Lisp. Prolog adds an extra convenience, however—an optional vertical bar that
delimits the “tail” of the list. Using this notation, [a, b, c] could be expressed
as [a | [b, c]], [a, b | [c]], or [a, b, c | []]. The vertical-bar notation
is particularly handy when the tail of the list is a variable:
```


![Figure 12.1 Backtracking search...](images/page_632_vector_331.png)
*Figure 12.1 Backtracking search in Prolog. The tree of potential resolutions consists of alter- nating AND and OR levels. An AND level consists of subgoals from the right-hand side of a rule, all of which must be satisﬁed. An OR level consists of alternative database clauses whose head will unify with the subgoal above; one of these must be satisﬁed. The notation _C = _X is meant to indicate that while both C and X are uninstantiated, they have been associated with one another in such a way that if either receives a value in the future it will be shared by both.*

```
The process of returning to previous goals is known as backtracking. It strongly
resembles the control ﬂow of generators in Icon (Section C 6.5.4). Whenever a
uniﬁcation operation is “undone” in order to pursue a different path through
the search tree, variables that were given values or associated with one another
as a result of that uniﬁcation are returned to their uninstantiated or unassociated
state. In Figure 12.1, for example, the binding of X to seattle is broken when
EXAMPLE 12.16
```

```
Backtracking and
instantiation
we backtrack to the rainy(X) subgoal. The effect is similar to the breaking of
bindings between actual and formal parameters in an imperative programming
language, except that Prolog couches the bindings in terms of uniﬁcation rather
than subroutine calls.
■
Space management for backtracking search in Prolog usually follows the
single-stack implementation of iterators described in Section C 9.5.3. The inter-
preter pushes a frame onto its stack every time it begins to pursue a new subgoal
G. If G fails, the frame is popped from the stack and the interpreter begins to
backtrack. If G succeeds, control returns to the “caller” (the parent in the search
tree), but G’s frame remains on the stack. Later subgoals will be given space above
```

