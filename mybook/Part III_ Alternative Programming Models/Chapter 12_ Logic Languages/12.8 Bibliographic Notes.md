620
Chapter 12 Logic Languages
which a structure like this one would be useful? If not, can you suggest
how a Prolog interpreter might implement checks to forbid its creation?
How expensive would those checks be? Would the cost in your opinion be
justiﬁed?
12.19–12.21 In More Depth.
12.7
Explorations
12.22
Learn about alternative search strategies for Prolog and other logic lan-
guages. How do forward chaining solvers work? What are the prospects
for intelligent hybrid strategies?
12.23
Between 1982 and 1992 the Japanese government invested large sums of
money in logic programming. Research the Fifth Generation project, ad-
ministered by the Japanese Ministry of International Trade and Industry
(MITI). What were its goals? What was achieved? What was not? How
tightly were the goals and outcomes tied to Prolog? What lessons can we
learn from the project today?
12.24
Read ahead to Chapter 14 and learn about XSLT, a language used to ma-
nipulate data represented in XML, the extended markup language (of
which XHTML, the latest standard for web pages, is an example). XSLT
is generally described as declarative. Is it logic based? How does it com-
pare to Prolog in expressive power, level of abstraction, and execution ef-
ﬁciency?
12.25
Repeat the previous question for SQL, the database query language (for
an introduction, type “SQL tutorial” into your favorite Internet search en-
gine).
12.26
Spreadsheets like Microsoft Excel are sometimes characterized as declar-
ative programming. Is this fair? Ignoring extensions like Visual Basic
macros, does the ability to deﬁne relationships among cells provide Turing
complete expressive power? Compare the execution model to that of Pro-
log. How is the order of update for cells determined? Can data be pushed
“both ways,” as they can in Prolog?
12.27–12.30 In More Depth.
12.8
Bibliographic Notes
Logic programming has its roots in automated theorem proving. Much of the the-
oretical groundwork was laid by Horn in the early 1950s [Hor51], and by Robin-
son in the early 1960s [Rob65]. The breakthrough for computing came in the
12.8 Bibliographic Notes
621
early 1970s, when Colmeraurer and Roussel at the University of Aix–Marseille
in France and Kowalski and his colleagues at the University of Edinburgh in
Scotland developed the initial version of Prolog. The early history of the lan-
guage is recounted by Robinson [Rob83]. Theoretical foundations are covered by
Lloyd [Llo87].
Prolog was originally intended for research in natural language processing, but
it soon became apparent that it could serve as a general-purpose language. Several
versions of Prolog have since evolved. The one described here is the widely used
Edinburgh dialect. The ISO standard [Int95] is similar.
Several other logic languages have been developed, though none rivaled Pro-
log in popularity. OPS5 [BFKM86] used forward chaining. Gödel [HL94] in-
cludes modules, strong typing, a richer variety of logical operators, and enhanced
control of execution order. Parlog is a parallel Prolog dialect; we will mention
it brieﬂy in Section 13.4.5. Mercury [SHC96] adopts a variety of features from
ML-family functional languages, including static type inference, monad-like I/O,
higher-order predicates, closures, currying, and lambda expressions. It is com-
piled, rather than interpreted, and requires the programmer to specify modes
(in, out) for predicate arguments.
Database query languages stemming from Datalog [Ull85][UW08, Secs. 4.2–
4.4] are implemented using forward chaining. CLP (Constraint Logic Program-
ming) and its variants are largely based on Prolog, but employ a more general
constraint-satisfaction mechanism in place of uniﬁcation [JM94]. The Associa-
tion for Logic Programming can be found on-line at www.cs.nmsu.edu/ALP/.
This page intentionally left blank
