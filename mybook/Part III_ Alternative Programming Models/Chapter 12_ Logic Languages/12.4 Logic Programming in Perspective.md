# 12.4 Logic Programming in Perspective

12.4 Logic Programming in Perspective
**613**

**IN MORE DEPTH**

In conventional logical notation there are many ways to state a given proposition.
Logic programming is built on* clausal form*, which provides a unique expression
for every proposition. Many though not all clausal forms can be cast as a collec-
tion of Horn clauses, and thus translated into Prolog. On the companion site we
trace the steps required to translate an arbitrary proposition into clausal form.
We also characterize the cases in which this form can and cannot be translated
into Prolog.

## 12.4

**Logic Programming in Perspective**
In the abstract, logic programming is a very compelling idea: it suggests a model
of computing in which we simply list the logical properties of an unknown value,
and then the computer ﬁgures out how to ﬁnd it (or tells us it doesn’t exist).
Unfortunately, reality falls quite a bit short of the vision, for both theoretical and
practical reasons.

12.4.1** Parts of Logic Not Covered**

```
As noted in Section 12.3, Horn clauses do not capture all of ﬁrst-order pred-
icate calculus. In particular, they cannot be used to express statements whose
clausal form includes a disjunction with more than one non-negated term. We
can sometimes get around this problem in Prolog by using the \+ predicate, but
the semantics are not the same (see Section 12.4.3).
```

12.4.2** Execution Order**

In Section 12.2.4, we saw that one must often consider execution order to ensure
that a Prolog search will terminate. Even for searches that terminate, naive code
can be* very* inefﬁcient. Consider the problem of sorting. A natural declarative
**EXAMPLE** 12.35

Sorting incredibly slowly

**DESIGN & IMPLEMENTATION**

12.3 Implementing logic
Predicate calculus is a signiﬁcantly higher-level notation than lambda calculus.
It is much more abstract—much less algorithmic. It is natural, therefore, that a
language like Prolog not provide the full power of predicate calculus, and that
it include extensions to make it more algorithmic. We may someday reach the
point where programming systems are capable of discovering good algorithms
from very high-level declarative speciﬁcations, but we are not there yet.

```
?- \+(takes(X, his201)).
X = ajit_chandra
```

or even

```
?- \+(takes(X, his201)).
X != jane_doe
```

