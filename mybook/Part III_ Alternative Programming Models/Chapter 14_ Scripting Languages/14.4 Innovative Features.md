# 14.4 Innovative Features

**738**
Chapter 14* Scripting Languages*

**IN MORE DEPTH**

XML can be used to create specialized markup languages for a very wide range of
application domains. XHTML is an almost (but not quite) backward compatible
variant of HTML that conforms to the XML standard. Web tools are increasingly
being designed to generate XHTML.
On the companion site, we consider a variety of topics related to XML, with
a particular emphasis on XSLT. We elaborate on the distinction between content
and presentation, introduce the general notion of stylesheet languages, and de-
scribe the* document type deﬁnitions* (DTDs) and* schemas* used to deﬁne domain-
speciﬁc applications of XML, using XHTML as an example.
Because tags are required to nest, an XML document has a natural tree-based
structure. XSLT is designed to process these trees via recursive traversal. Though
it can be used for almost any task that takes XML as input, perhaps its most com-
mon use is to transform XML into formatted output—often XHTML to be pre-
sented in a browser. As an extended example, we consider the formatting of an
XML-based bibliographic database.

```
3CHECK YOUR UNDERSTANDING
23. Explain the distinction between server-side and client-side web scripting.
```

24. List the tradeoffs between CGI scripts and embedded PHP.
25. Why are CGI scripts usually installed only in a special directory?

26. Explain how a PHP page can service its own requests.
27. Why might we prefer to execute a web script on the server rather than the
client? Why might we sometimes prefer the client instead?
28. What is the HTML* Document Object Model*? What is its signiﬁcance for client-
side scripting?
29. What is the relationship between JavaScript and Java?

30. What is an* applet*? Why applets are usually not considered an example of
scripting?

31. What is HTML? XML? XSLT? How are they related to one another?

## 14.4

**Innovative Features**
In Section 14.1.1, we listed several common characteristics of scripting languages:

**1.** Both batch and interactive use

```
/b[aeiou]d/
matches bad, bed, bid, bod, and bud
```

**DESIGN & IMPLEMENTATION**

```
14.8 The grep command and the birth of Unix tools
Historically, regular expression tools have their roots in the pattern matching
mechanism of the ed line editor, which dates from the earliest days of Unix.
In 1973, Doug McIlroy, head of the department where Unix was born, was
working on a project in computerized voice synthesis. As part of this project
he was using the editor to search for potentially challenging words in an on-
line dictionary. The process was both tedious and slow. At McIlroy’s request,
Ken Thompson extracted the pattern matcher from ed and made it a stand-
alone tool. He named his creation grep, after the g/re/p command sequence
in the editor: g for “global”; / / to search for a regular expression (re); p to
print [HH97a, Chap. 9].
Thompson’s creation was one of the ﬁrst in a large suite of stream-based
Unix tools. As described in Section 14.2.1, such tools are frequently combined
with pipes to perform a variety of ﬁltering, transforming, and formatting op-
erations.
```

```
6
Strictly speaking, ] and } don’t require a protective backslash unless there is a preceding un-
matched (and unprotected) [ or {, respectively.
```

### using composite objects as keys in a hash. Tuples in Python work particularly

### well:

