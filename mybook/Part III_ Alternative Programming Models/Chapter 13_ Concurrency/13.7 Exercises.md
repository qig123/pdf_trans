# 13.7 Exercises

**690**
Chapter 13* Concurrency*

languages being designed for purely sequential execution. As of 2015, explic-
itly parallel languages have yet to seriously undermine the dominance of MPI for
high-end scientiﬁc computing, though this, too, may change in coming years.
## 13.7

**Exercises**
```
13.1
Give an example of a “benign” race condition—one whose outcome affects
program behavior, but not correctness.
13.2
We have deﬁned the ready list of a thread package to contain all threads
that are runnable but not running, with a separate variable to identify the
currently running thread. Could we just as easily have deﬁned the ready
list to contain all runnable threads, with the understanding that the one at
the head of the list is running? (Hint: Think about multiprocessors.)
13.3
Imagine you are writing the code to manage a hash table that will be shared
among several concurrent threads. Assume that operations on the table
need to be atomic. You could use a single mutual exclusion lock to protect
the entire table, or you could devise a scheme with one lock per hash-
table bucket. Which approach is likely to work better, under what circum-
stances? Why?
13.4
The typical spin lock holds only one bit of data, but requires a full word
of storage, because only full words can be read, modiﬁed, and written
atomically in hardware. Consider, however, the hash table of the previ-
ous exercise. If we choose to employ a separate lock for each bucket of the
table, explain how to implement a “two-level” locking scheme that cou-
ples a conventional spin lock for the table as a whole with a single bit of
locking information for each bucket. Explain why such a scheme might be
desirable, particularly in a table with external chaining.
13.5
Drawing inspiration from Examples 13.29 and 13.30, design a non-
blocking linked-list implementation of a stack using compare_and_swap.
(When CAS was ﬁrst introduced, on the IBM 370 architecture, this algo-
rithm was one of the driving applications [Tre86].)
13.6
Building on the previous exercise, suppose that stack nodes are dynami-
cally allocated. If we read a pointer and then are delayed (e.g., due to pre-
emption), the node to which the pointer refers may be reclaimed and then
reallocated for a different purpose. A subsequent compare-and-swap may
then succeed when logically it should not. This issue is known as the ABA
problem.
Give a concrete example—an interleaving of operations in two or more
threads—where the ABA problem may result in incorrect behavior for
your stack. Explain why this behavior cannot occur in systems with au-
tomatic garbage collection. Suggest what might be done to avoid it in
systems with manual storage management.
```

and the middle four lines of procedure V with

S.N +:= 1
if S.Q is nonempty
enqueue(ready list, dequeue(S.Q))

```
What is the problem with this new version? Explain how it connects to the
question of hints and absolutes in Section 13.4.1.
13.21
Suppose that every monitor has a separate mutual exclusion lock, so that
different threads can run in different monitors concurrently, and that we
want to release exclusion on both inner and outer monitors when a thread
waits in a nested call. When the thread awakens it will need to reacquire
the outer locks. How can we ensure its ability to do so? (Hint: Think
about the order in which to acquire locks, and be prepared to abandon
Hoare semantics. For further hints, see Wettstein [Wet78].)
13.22
Show how general semaphores can be implemented with conditional criti-
cal regions in which all threads wait for the same condition, thereby avoid-
ing the overhead of unproductive wake-ups.
13.23
Write code for a bounded buffer using the protected object mechanism of
Ada 95.
```

