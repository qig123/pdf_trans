# 13.5 Message Passing

13.5 Message Passing
**687**

```
3CHECK YOUR UNDERSTANDING
38. What is a monitor? How do monitor condition variables differ from sema-
phores?
```

39. Explain the difference between treating monitor signals as* hints* and treating
them as* absolutes*.

40. What is a* monitor invariant*? Under what circumstances must it be guaranteed
to hold?

41. Describe the* nested monitor problem* and some potential solutions.
42. What is* deadlock*?

43. What is a* conditional critical region*? How does it differ from a monitor?
44. Summarize the synchronization mechanisms of Ada 95, Java, and C#. Con-
trast them with one another, and with monitors and conditional critical re-
gions. Be sure to explain the features added to Java 5.

45. What is* transactional memory*? What advantages does it offer over algorithms
based on locks? What challenges will need to be overcome before it enters
widespread use?

```
46. Describe the semantics of the HPF/Fortran 95 forall loop. How does it
differ from do concurrent?
```

47. Why might pure functional languages be said to provide a particularly attrac-
tive setting for concurrent programming?

48. What are* futures*? In what languages do they appear? What precautions must
the programmer take when using them?

49. Explain the difference between AND* parallelism* and OR* parallelism* in Prolog.

## 13.5

**Message Passing**
Shared-memory concurrency has become ubiquitous on multicore processors
and multiprocessor servers. Message passing, however, still dominates both dis-
tributed and high-end computing. Supercomputers and large-scale clusters are
programmed primarily in Fortran or C/C++ with the MPI library package. Dis-
tributed computing increasingly relies on clientâ€“server abstractions layered on
top of libraries that implement the TCP/IP Internet standard. As in shared-
memory computing, scores of message-passing languages have also been devel-
oped for particular application domains, or for research or pedagogical purposes.

