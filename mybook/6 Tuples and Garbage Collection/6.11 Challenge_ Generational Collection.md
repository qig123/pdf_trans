# 6.11 Challenge: Generational Collection

Compile the exit primitive into a call to the exit function of the C standard library, with an argument of 255.

Exercise 6.2 Implement a compiler for the LArray language by extending your compiler for LWhile. Test your compiler on a half dozen new programs, including the one shown in figure 6.23 and also a program that multiplies two matrices. Note that although matrices are two-dimensional arrays, they can be encoded into one-dimensional arrays by laying out each row in the array, one after the next.

6.11 Challenge: Generational Collection

The copying collector described in section 6.2 can incur significant runtime over- head because the call to collect takes time proportional to all the live data. One way to reduce this overhead is to reduce how much data is inspected in each call to collect. In particular, researchers have observed that recently allocated data is more likely to become garbage than data that has survived one or more previous calls to collect. This insight motivated the creation of generational garbage col- lectors that (1) segregate data according to its age into two or more generations; (2) allocate less space for younger generations, so collecting them is faster, and more space for the older generations; and (3) perform collection on the younger generations more frequently than on older generations (Wilson 1992). For this challenge assignment, the goal is to adapt the copying collector imple- mented in runtime.c to use two generations, one for young data and one for old data. Each generation consists of a FromSpace and a ToSpace. The following is a sketch of how to adapt the collect function to use the two generations:

* Copy the young generationâ€™s FromSpace to its ToSpace and then switch the role
  of the ToSpace and FromSpace.
* If there is enough space for the requested number of bytes in the young
  FromSpace, then return from collect.
* If there is not enough space in the young FromSpace for the requested bytes,
  then move the data from the young generation to the old one with the following
  steps:
  a. If there is enough room in the old FromSpace, copy the young FromSpace to
  the old FromSpace and then return.
  b. If there is not enough room in the old FromSpace, then collect the old gen-
  eration by copying the old FromSpace to the old ToSpace and swap the roles
  of the old FromSpace and ToSpace.
  c. If there is enough room now, copy the young FromSpace to the old FromSpace
  and return. Otherwise, allocate a larger FromSpace and ToSpace for the old
  generation. Copy the young FromSpace and the old FromSpace into the larger
  FromSpace for the old generation and then return.

We recommend that you generalize the cheney function so that it can be used for all the copies mentioned: between the young FromSpace and ToSpace, between the old FromSpace and ToSpace, and between the young FromSpace and old

