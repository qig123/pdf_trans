# 6.8 Generate Prelude and Conclusion

6.7 Register Allocation

![Figure 6.17 shows the...](images/page_129_vector_504.png)
*Figure 6.17 shows the output of the prelude_and_conclusion pass on the running example. In the prelude of the main function, we allocate space on the root stack to make room for the spills of tuple-typed variables. We do so by incrementing the root stack pointer (r15), taking care that the root stack grows up instead of down. For the running example, there was just one spill, so we increment r15 by 8 bytes. In the conclusion we subtract 8 bytes from r15. One issue that deserves special care is that there may be a call to collect prior to the initializing assignments for all the variables in the root stack. We do not want the garbage collector to mistakenly determine that some uninitialized variable is a pointer that needs to be followed. Thus, we zero out all locations on the root stack in the prelude of main. In figure 6.17, the instruction movq $0, 0(%r15) is sufficient*

![Figure 6.16 Output of...](images/page_130_vector_395.png)
*Figure 6.16 Output of register allocation for the running example.*

to accomplish this task because there is only one spill. In general, we have to clear as many words as there are spills of tuple-typed variables. The garbage collector tests each root to see if it is null prior to dereferencing it. Figure 6.18 gives an overview of all the passes needed for the compilation of LTup.

![Figure 6.17 The prelude...](images/page_131_vector_238.png)
*Figure 6.17 The prelude and conclusion for the running example.*

![Figure 6.18 Diagram of...](images/page_131_vector_502.png)
*Figure 6.18 Diagram of the passes for LTup, a language with tuples.*

