# 6.3 Expose Allocation

6.3 Expose Allocation

The pass expose_allocation lowers tuple creation into making a condi- tional call to the collector followed by allocating the appropriate amount of memory and initializing it. We choose to place the expose_allocation pass before remove_complex_operands because it generates code that con- tains complex operands. However, with some care it can also be placed after remove_complex_operands, which would simplify tuple creation by removing the need to assign the initializing expressions to temporary variables (see below). The output of expose_allocation is a language LAlloc that replaces tuple creation with new forms that we use in the translation of tuple creation.

exp ::= (Collect int) | (Allocate int type) | (GlobalValue var)

The (Collect n) form runs the garbage collector, requesting that there be n bytes ready to be allocated. During instruction selection, the (Collect n) form will become a call to the collect function in runtime.c. The (Allocate n type) form obtains memory for n elements (and space at the front for the 64-bit tag), but the elements are not initialized. The type parameter is the type of the tuple: (Vector type1 … typen) where typei is the type of the ith element. The (GlobalValue name) form reads the value of a global variable, such as free_ptr. The type information that you need for (Allocate n type) can be obtained by running the type-check-Lvec-has-type type checker immediately before the expose_allocation pass. This version of the type checker places a special AST node of the form (HasType e type) around each tuple creation. The concrete syntax for HasType is has-type. The following shows the transformation of tuple creation into (1) a sequence of temporary variable bindings for the initializing expressions, (2) a conditional call to collect, (3) a call to allocate, and (4) the initialization of the tuple. The len placeholder refers to the length of the tuple, and bytes is the total number of bytes that need to be allocated for the tuple, which is 8 for the tag plus len times 8.

(has-type (vector e0 … en−1) type) =⇒ (let ([x0 e0]) ... (let ([xn−1 en−1]) (let ([_ (if (< (+ (global-value free_ptr) bytes) (global-value fromspace_end)) (void) (collect bytes))]) (let ([v (allocate len type)]) (let ([_ (vector-set! v 0 x0)]) ... (let ([_ (vector-set! v n −1 xn−1)]) v) ... )))) ...)

The sequencing of the initializing expressions e0, … , en−1 prior to the allocate is important because they may trigger garbage collection and we cannot have an allocated but uninitialized tuple on the heap during a collection.

