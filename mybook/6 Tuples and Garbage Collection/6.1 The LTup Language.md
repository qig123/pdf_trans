# 6.1 The LTup Language

6

Tuples and Garbage Collection

In this chapter we study the implementation of tuples, called vectors in Racket. A tuple is a fixed-length sequence of elements in which each element may have a differ- ent type. This language feature is the first to use the computer’s heap, because the lifetime of a tuple is indefinite; that is, a tuple lives forever from the programmer’s viewpoint. Of course, from an implementer’s viewpoint, it is important to reclaim the space associated with a tuple when it is no longer needed, which is why we also study garbage collection techniques in this chapter. Section 6.1 introduces the LTup language, including its interpreter and type checker. The LTup language extends the LWhile language (chapter 5) with tuples. Section 6.2 describes a garbage collection algorithm based on copying live tuples back and forth between two halves of the heap. The garbage collector requires coor- dination with the compiler so that it can find all the live tuples. Sections 6.3 through

6.8 discuss the necessary changes and additions to the compiler passes, including a new compiler pass named expose_allocation.

![Figure 6.1...](images/page_111_vector_cluster_434.png)
*Figure 6.1*

```
(let ([t (vector 40 #t (vector 2))])
(if (vector-ref t 1)
(+ (vector-ref t 0)
(vector-ref (vector-ref t 2) 0))
44))
```

Tuples raise several interesting new issues. First, variable binding performs a shallow copy in dealing with tuples, which means that different variables can refer

![Figure 6.1...](images/page_112_vector_cluster_267.png)
*Figure 6.1*

![Figure 6.2...](images/page_112_vector_cluster_517.png)
*Figure 6.2*

to the same tuple; that is, two variables can be aliases for the same entity. Consider the following example, in which t1 and t2 refer to the same tuple value and t3 refers to a different tuple value with equal elements. The result of the program is 42.

```
(let ([t1 (vector 3 7)])
(let ([t2 t1])
(let ([t3 (vector 3 7)])
(if (and (eq? t1 t2) (not (eq? t1 t3)))
42
0))))
```

Whether two variables are aliased or not affects what happens when the under- lying tuple is mutated. Consider the following example in which t1 and t2 again refer to the same tuple value.

```
(let ([t1 (vector 3 7)])
(let ([t2 t1])
(let ([_ (vector-set! t2 0 42)])
(vector-ref t1 0))))
```

The mutation through t2 is visible in referencing the tuple from t1, so the result of this program is 42. The next issue concerns the lifetime of tuples. When does a tuple’s lifetime end? Notice that LTup does not include an operation for deleting tuples. Furthermore, the lifetime of a tuple is not tied to any notion of static scoping. For example, the following program returns 42 even though the variable w goes out of scope prior to the vector-ref that reads from the vector to which it was bound.

```
(let ([v (vector (vector 44))])
(let ([x (let ([w (vector 42)])
(let ([_ (vector-set! v 0 w)])
0))])
(+ x (vector-ref (vector-ref v 0) 0))))
```

From the perspective of programmer-observable behavior, tuples live forever. How- ever, if they really lived forever then many long-running programs would run out of memory. To solve this problem, the language’s runtime system performs automatic garbage collection. Figure 6.3 shows the definitional interpreter for the LTup language. We define the vector, vector-ref, vector-set!, and vector-length operations for LTup in terms of the corresponding operations in Racket. One subtle point is that the vector-set! operation returns the #<void> value. Figure 6.4 shows the type checker for LTup. The type of a tuple is a Vector type that contains a type for each of its elements. To create the s-expression for the Vector type, we use the unquote-splicing operator ,@ to insert the list t* without its usual start and end parentheses. The type of accessing the ith element of a tuple is the ith element type of the tuple’s type, if there is one. If not, an error is signaled. Note that the index i is required to be a constant integer (and not, for example, a call to read) so that the type checker can determine the element’s type given the tuple type. Regarding writing an element to a tuple, the element’s type must be equal to the ith element type of the tuple’s type. The result type is Void.

