# 6.2 Garbage Collection

![Figure 6.3 Interpreter for...](images/page_114_vector_423.png)
*Figure 6.3 Interpreter for the LTup language.*

6.2 Garbage Collection

Garbage collection is a runtime technique for reclaiming space on the heap that will not be used in the future of the running program. We use the term object to refer to any value that is stored in the heap, which for now includes only tuples.1

Unfortunately, it is impossible to know precisely which objects will be accessed in the future and which will not. Instead, garbage collectors overapproximate the set of objects that will be accessed by identifying which objects can possibly be accessed. The running program can directly access objects that are in registers and on the procedure call stack. It can also transitively access the elements of tuples, starting with a tuple whose address is in a register or on the procedure call stack. We define the root set to be all the tuple addresses that are in registers or on the procedure

* The term object as it is used in the context of object-oriented programming has a more specific
  meaning than the way in which we use the term here.

```
(define type-check-Lvec-class
(class type-check-Lif-class
(super-new)
(inherit check-type-equal?)
```

![Figure 6.4 Type checker...](images/page_115_vector_589.png)
*Figure 6.4 Type checker for the LTup language.*

call stack. We define the live objects to be the objects that are reachable from the root set. Garbage collectors reclaim the space that is allocated to objects that are no longer live. That means that some objects may not get reclaimed as soon as they could be, but at least garbage collectors do not reclaim the space dedicated to objects that will be accessed in the future! The programmer can influence which objects get reclaimed by causing them to become unreachable. So the goal of the garbage collector is twofold:

* to preserve all the live objects, and
* to reclaim the memory of everything else, that is, the garbage.

6.2.1 Two-Space Copying Collector Here we study a relatively simple algorithm for garbage collection that is the basis of many state-of-the-art garbage collectors (Lieberman and Hewitt 1983; Ungar 1984; Jones and Lins 1996; Detlefs et al. 2004; Dybvig 2006; Tene, Iyengar, and Wolf 2011). In particular, we describe a two-space copying collector (Wilson 1992) that uses Cheney’s algorithm to perform the copy (Cheney 1970). Figure 6.5 gives a coarse-grained depiction of what happens in a two-space collector, showing two time steps, prior to garbage collection (on the top) and after garbage collection (on the bottom). In a two-space collector, the heap is divided into two parts named the FromSpace and the ToSpace. Initially, all allocations go to the FromSpace until there is not enough room for the next allocation request. At that point, the garbage collector goes to work to make room for the next allocation. A copying collector makes more room by copying all the live objects from the FromSpace into the ToSpace and then performs a sleight of hand, treating the ToSpace as the new FromSpace and the old FromSpace as the new ToSpace. In the example shown in figure 6.5, the root set consists of three pointers, one in a register and two on the stack. All the live objects have been copied to the ToSpace (the right-hand side of figure 6.5) in a way that preserves the pointer relationships. For example, the pointer in the register still points to a tuple that in turn points to two other tuples. There are four tuples that are not reachable from the root set and therefore do not get copied into the ToSpace. The exact situation shown in figure 6.5 cannot be created by a well-typed program in LTup because it contains a cycle. However, creating cycles will be possible once we get to LDyn (chapter 9). We design the garbage collector to deal with cycles to begin with, so we will not need to revisit this issue.

6.2.2 Graph Copying via Cheney’s Algorithm Let us take a closer look at the copying of the live objects. The allocated objects and pointers can be viewed as a graph, and we need to copy the part of the graph that is reachable from the root set. To make sure that we copy all the reachable vertices in the graph, we need an exhaustive graph traversal algorithm, such as depth-first search or breadth-first search (Moore 1959; Cormen et al. 2001). Recall that such algorithms take into account the possibility of cycles by marking which vertices have already been visited, so to ensure termination of the algorithm. These

![Figure 6.5 A copying...](images/page_117_vector_429.png)
*Figure 6.5 A copying collector in action.*

search algorithms also use a data structure such as a stack or queue as a to-do list to keep track of the vertices that need to be visited. We use breadth-first search and a trick due to Cheney (1970) for simultaneously representing the queue and copying tuples into the ToSpace. Figure 6.6 shows several snapshots of the ToSpace as the copy progresses. The queue is represented by a chunk of contiguous memory at the beginning of the ToSpace, using two pointers to track the front and the back of the queue, called the scan pointer and the free pointer, respectively. The algorithm starts by copying all tuples that are immediately reachable from the root set into the ToSpace to form the initial queue. When we copy a tuple, we mark the old tuple to indicate that it has been visited. We discuss how this marking is accomplished in section 6.2.3. Note that any pointers inside the copied tuples in the queue still point back to the FromSpace. Once the initial queue has been created, the algorithm enters a loop in which it repeatedly processes the tuple at the front of the queue and pops

![Figure 6.6 Depiction of...](images/page_118_vector_505.png)
*Figure 6.6 Depiction of the Cheney algorithm copying the live tuples.*

it off the queue. To process a tuple, the algorithm copies all the objects that are directly reachable from it to the ToSpace, placing them at the back of the queue. The algorithm then updates the pointers in the popped tuple so that they point to the newly copied objects. As shown in figure 6.6, in the first step we copy the tuple whose second element is 42 to the back of the queue. The other pointer goes to a tuple that has already been copied, so we do not need to copy it again, but we do need to update the pointer to the new location. This can be accomplished by storing a forwarding pointer to the

new location in the old tuple, when we initially copied the tuple into the ToSpace. This completes one step of the algorithm. The algorithm continues in this way until the queue is empty; that is, when the scan pointer catches up with the free pointer.

6.2.3 Data Representation The garbage collector places some requirements on the data representations used by our compiler. First, the garbage collector needs to distinguish between pointers and other kinds of data such as integers. The following are three ways to accomplish this:

* Attach a tag to each object that identifies what type of object it is (McCarthy
  1960).
* Store different types of objects in different regions (Steele 1977).
* Use type information from the program to either (a) generate type-specific
  code for collecting, or (b) generate tables that guide the collector (Appel 1989;
  Goldberg 1991; Diwan, Moss, and Hudson 1992).

Dynamically typed languages, such as Racket, need to tag objects in any case, so option 1 is a natural choice for those languages. However, LTup is a statically typed language, so it would be unfortunate to require tags on every object, especially small and pervasive objects like integers and Booleans. Option 3 is the best-performing choice for statically typed languages, but it comes with a relatively high implemen- tation complexity. To keep this chapter within a reasonable scope of complexity, we recommend a combination of options 1 and 2, using separate strategies for the stack and the heap. Regarding the stack, we recommend using a separate stack for pointers, which we call the root stack (aka shadow stack) (Siebert 2001; Henderson 2002; Baker et al. 2009). That is, when a local variable needs to be spilled and is of type Vector, we put it on the root stack instead of putting it on the procedure call stack. Furthermore, we always spill tuple-typed variables if they are live during a call to the collector, thereby ensuring that no pointers are in registers during a collection. Figure 6.7 reproduces the example shown in figure 6.5 and contrasts it with the data layout using a root stack. The root stack contains the two pointers from the regular stack and also the pointer in the second register. The problem of distinguishing between pointers and other kinds of data also arises inside each tuple on the heap. We solve this problem by attaching a tag, an extra 64 bits, to each tuple. Figure 6.8 shows a zoomed-in view of the tags for two of the tuples in the example given in figure 6.5. Note that we have drawn the bits in a big-endian way, from right to left, with bit location 0 (the least significant bit) on the far right, which corresponds to the direction of the x86 shifting instructions salq (shift left) and sarq (shift right). Part of each tag is dedicated to specifying which elements of the tuple are pointers, the part labeled pointer mask. Within the pointer mask, a 1 bit indicates that there is a pointer, and a 0 bit indicates some other kind of data. The pointer mask starts at bit location 7. We limit tuples to

![Figure 6.7 Maintaining a...](images/page_120_vector_240.png)
*Figure 6.7 Maintaining a root stack to facilitate garbage collection.*

![Figure 6.8 Representation of...](images/page_120_vector_426.png)
*Figure 6.8 Representation of tuples in the heap.*

a maximum size of fifty elements, so we need 50 bits for the pointer mask.2 The tag also contains two other pieces of information. The length of the tuple (number of elements) is stored in bits at locations 1 through 6. Finally, the bit at location 0 indicates whether the tuple has yet to be copied to the ToSpace. If the bit has value 1, then this tuple has not yet been copied. If the bit has value 0, then the entire tag is a forwarding pointer. (The lower 3 bits of a pointer are always zero in any case, because our tuples are 8-byte aligned.)

* A production-quality compiler would handle arbitrarily sized tuples and use a more complex
  approach.

![Figure 6.9 The compiler’s...](images/page_121_vector_182.png)
*Figure 6.9 The compiler’s interface to the garbage collector.*

6.2.4 Implementation of the Garbage Collector An implementation of the copying collector is provided in the runtime.c file. Figure 6.9 defines the interface to the garbage collector that is used by the com- piler. The initialize function creates the FromSpace, ToSpace, and root stack and should be called in the prelude of the main function. The arguments of initialize are the root stack size and the heap size. Both need to be multiples of sixty-four, and 16, 384 is a good choice for both. The initialize function puts the address of the beginning of the FromSpace into the global variable free_ptr. The global variable fromspace_end points to the address that is one past the last element of the FromSpace. We use half-open intervals to represent chunks of memory (Dijkstra 1982). The rootstack_begin variable points to the first element of the root stack. As long as there is room left in the FromSpace, your generated code can allo- cate tuples simply by moving the free_ptr forward. The amount of room left in the FromSpace is the difference between the fromspace_end and the free_ptr. The collect function should be called when there is not enough room left in the FromSpace for the next allocation. The collect function takes a pointer to the current top of the root stack (one past the last item that was pushed) and the number of bytes that need to be allocated. The collect function performs the copying collection and leaves the heap in a state such that there is enough room for the next allocation. The introduction of garbage collection has a nontrivial impact on our com- piler passes. We introduce a new compiler pass named expose_allocation that elaborates the code for allocating tuples. We also make significant changes to select_instructions, build_interference, allocate_registers, and prelude_and_conclusion and make minor changes in several more passes. The following program serves as our running example. It creates two tuples, one nested inside the other. Both tuples have length one. The program accesses the element in the inner tuple.

(vector-ref (vector-ref (vector (vector 42)) 0) 0)

