# 9.5 Reveal Casts

9.5 Reveal Casts

In the reveal_casts pass, we recommend compiling Project into a conditional expression that checks whether the value’s tag matches the target type; if it does, the value is converted to a value of the target type by removing the tag; if it does not, the program exits. To perform these actions we need a new primitive operation, tag-of-any, and a new form, ValueOf. The tag-of-any operation retrieves the type tag from a tagged value of type Any. The ValueOf form retrieves the underlying value from a tagged value. The ValueOf form includes the type for the underlying value that is used by the type checker. If the target type of the projection is Boolean or Integer, then Project can be translated as follows:

(Project e ftype) ⇒ (Let tmp e′

(If (Prim 'eq? (list (Prim 'tag-of-any (list (Var tmp))) (Int tagof(ftype)))) (ValueOf tmp ftype) (Exit)))

If the target type of the projection is a tuple or function type, then there is a bit more work to do. For tuples, check that the length of the tuple type matches the length of the tuple. For functions, check that the number of parameters in the function type matches the function’s arity. Regarding Inject, we recommend compiling it to a slightly lower-level primitive operation named make-any. This operation takes a tag instead of a type.

(Inject e ftype) ⇒ (Prim 'make-any (list e′ (Int tagof(ftype))))

The type predicates (boolean?, etc.) can be translated into uses of tag-of-any and eq? in a similar way as in the translation of Project. The any-vector-ref and any-vector-set! operations combine the projection action with the vector operation. Also, the read and write operations allow arbitrary expressions for the index, so the type checker for LAny (figure 9.6) cannot guarantee that the index is within bounds. Thus, we insert code to perform bounds checking at runtime. The translation for any-vector-ref is as follows, and the other two operations are translated in a similar way:

