# 9.9 Register Allocation for LAny 

There is an interesting interaction between tagged values and garbage collection that has an impact on register allocation. A variable of type Any might refer to a tuple, and therefore it might be a root that needs to be inspected and copied during garbage collection. Thus, we need to treat variables of type Any in a similar way to variables of tuple type for purposes of register allocation, with particular attention to the following:

* If a variable of type Any is live during a function call, then it must be spilled. This
  can be accomplished by changing build_interference to mark all variables of
  type Any that are live after a callq to be interfering with all the registers.

* If a variable of type Any is spilled, it must be spilled to the root stack instead of
  the normal procedure call stack.

Another concern regarding the root stack is that the garbage collector needs to differentiate among (1) plain old pointers to tuples, (2) a tagged value that points to a tuple, and (3) a tagged value that is not a tuple. We enable this differentiation by choosing not to use the tag 000 in the tagof function. Instead, that bit pattern is reserved for identifying plain old pointers to tuples. That way, if one of the first three bits is set, then we have a tagged value and inspecting the tag can differentiate between tuples (010) and the other kinds of values.

Exercise 9.1 Expand your compiler to handle LDyn as outlined in this chapter. Create tests for LDyn by adapting ten of your previous test programs by removing type annotations. Add five more test programs that specifically rely on the language being dynamically typed. That is, they should not be legal programs in a statically typed language, but nevertheless they should be valid LDyn programs that run to completion without error.

![Figure 9.12...](images/page_191_vector_440.png)
*Figure 9.12*

![Figure 9.12...](images/page_192_vector_390.png)
*Figure 9.12*

