# 3.6 Generate Prelude and Conclusion

```
movq $1, -8(%rbp)
movq $42, %rcx
movq -8(%rbp), -8(%rbp)
addq $7, -8(%rbp)
movq -8(%rbp), -16(%rbp)
movq -8(%rbp), -8(%rbp)
addq %rcx, -8(%rbp)
movq -16(%rbp), %rcx
negq %rcx
movq -8(%rbp), %rax
addq %rcx, %rax
jmp conclusion
```

```
movq $1, -8(%rbp)
movq $42, %rcx
addq $7, -8(%rbp)
movq -8(%rbp), %rax
movq %rax, -16(%rbp)
addq %rcx, -8(%rbp)
movq -16(%rbp), %rcx
negq %rcx
movq -8(%rbp), %rax
addq %rcx, %rax
jmp conclusion
```

⇒

Exercise 3.5 Update the patch_instructions compiler pass to delete trivial moves. Run the script to test the patch_instructions pass.

3.6 Generate Prelude and Conclusion

Recall that this pass generates the prelude and conclusion instructions to satisfy the x86 calling conventions (section 3.1). With the addition of the register allocator, the callee-saved registers used by the register allocator must be saved in the prelude and restored in the conclusion. In the allocate_registers pass, add an entry to the info of X86Program named used_callee that stores the set of callee-saved registers that were assigned to variables. The prelude_and_conclusion pass can then access this information to decide which callee-saved registers need to be saved and restored. When calculating the amount to adjust the rsp in the prelude, make sure to take into account the space used for saving the callee-saved registers. Also, remember that the frame needs to be a multiple of 16 bytes! We recommend using the following equation for the amount A to subtract from the rsp. Let S be the number of stack locations used by spilled variables1 and C be the number of callee- saved registers that were allocated to variables. The align function rounds a number up to the nearest 16 bytes.

A = align(8S + 8C) −8C

The reason we subtract 8C in this equation is that the prelude uses pushq to save each of the callee-saved registers, and pushq subtracts 8 from the rsp. An overview of all the passes involved in register allocation is shown in figure 3.12. Figure 3.13 shows the x86 code generated for the running example (figure 3.1). To demonstrate both the use of registers and the stack, we limit the register allocator for this example to use just two registers: rcx (color 0) and rbx (color 1). In the prelude of the main function, we push rbx onto the stack because it is a callee-saved register and it was assigned to a variable by the register allocator. We subtract 8

* Sometimes two or more spilled variables are assigned to the same stack location, so S can be
  less than the number of spilled variables.

