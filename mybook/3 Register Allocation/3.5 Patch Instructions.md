# 3.5 Patch Instructions

use for register allocation, rcx. Then we have the following assignment.

{0 7→%rcx, 1 7→-8(%rbp), 2 7→-16(%rbp)}

Composing this mapping with the coloring, we arrive at the following assignment of variables to locations.

{v 7→-8(%rbp), w 7→%rcx, x 7→-8(%rbp), y 7→-16(%rbp),

z 7→-8(%rbp), t 7→%rcx}

Adapt the code from the assign_homes pass (section 2.8) to replace the variables with their assigned location. Applying this assignment to our running example shown next, on the left, yields the program on the right.

```
movq $1, -8(%rbp)
movq $42, %rcx
movq -8(%rbp), -8(%rbp)
addq $7, -8(%rbp)
movq -8(%rbp), -16(%rbp)
movq -8(%rbp), -8(%rbp)
addq %rcx, -8(%rbp)
movq -16(%rbp), %rcx
negq %rcx
movq -8(%rbp), %rax
addq %rcx, %rax
jmp conclusion
```

```
movq $1, v
movq $42, w
movq v, x
addq $7, x
movq x, y
movq x, z
addq w, z
movq y, t
negq t
movq z, %rax
addq t, %rax
jmp conclusion
```

⇒

Exercise 3.4 Implement the allocate_registers pass. Create five programs that exercise all aspects of the register allocation algorithm, including spilling variables to the stack. Replace assign_homes in the list of passes in the run-tests.rkt script with the three new passes: uncover_live, build_interference, and allocate_registers. Temporarily remove the call to compiler-tests. Run the script to test the register allocator.

3.5 Patch Instructions

The remaining step in the compilation to x86 is to ensure that the instructions have at most one argument that is a memory access. In the running example, the instruc- tion movq -8(%rbp), -16(%rbp) is problematic. Recall from section 2.9 that the fix is to first move -8(%rbp) into rax and then move rax into -16(%rbp). The moves from -8(%rbp) to -8(%rbp) are also problematic, but they can simply be deleted. In general, we recommend deleting all the trivial moves whose source and destina- tion are the same location. The following is the output of patch_instructions on the running example.

