# 2.3 Parsing

2.3 Parsing
**69**

```
3CHECK YOUR UNDERSTANDING
10. List the tasks performed by the typical scanner.
11. What are the advantages of an automatically generated scanner, in compari-
son to a handwritten one? Why do many commercial compilers use a hand-
written scanner anyway?
```

12. Explain the difference between deterministic and nondeterministic ﬁnite au-
tomata. Why do we prefer the deterministic variety for scanning?

13. Outline the constructions used to turn a set of regular expressions into a min-
imal DFA.
14. What is the “longest possible token” rule?
15. Why must a scanner sometimes “peek” at upcoming characters?

16. What is the difference between a* keyword* and an* identiﬁer*?
17. Why must a scanner save the text of tokens?

18. How does a scanner identify lexical errors? How does it respond?
19. What is a* pragma*?

## 2.3

**Parsing**
The parser is the heart of a typical compiler. It calls the scanner to obtain the
tokens of the input program, assembles the tokens together into a syntax tree,
and passes the tree (perhaps one subroutine at a time) to the later phases of the
compiler, which perform semantic analysis and code generation and improve-
ment. In effect, the parser is “in charge” of the entire compilation process; this
style of compilation is sometimes referred to as* syntax-directed translation*.
As noted in the introduction to this chapter, a context-free grammar (CFG) is
a* generator* for a CF language. A parser is a language* recognizer*. It can be shown
that for any CFG we can create a parser that runs in* O*(*n*3) time, where* n* is the
length of the input program.12 There are two well-known parsing algorithms that
achieve this bound: Earley’s algorithm [Ear70] and the Cocke-Younger-Kasami
(CYK) algorithm [Kas65, You67]. Cubic time is much too slow for parsing siz-
able programs, but fortunately not all grammars require such a general and slow
parsing algorithm. There are large classes of grammars for which we can build
parsers that run in linear time. The two most important of these classes are called
LL and LR (Figure 2.13).

**12** In general, an algorithm is said to run in time* O*(*f* (*n*)), where* n* is the length of the input, if
its running time* t*(*n*) is proportional to* f* (*n*) in the worst case. More precisely, we say* t*(*n*) =
*O*(*f* (*n*))* ⇐⇒∃**c**,** m* [*n** >** m** −→**t*(*n*)* <** c f* (*n*)].

```
These are the productions that would normally be used for an identiﬁer list in a
top-down parser. They can also be parsed bottom-up (most top-down grammars
can be). In practice they would not be used in a bottom-up parser, for reasons
that will become clear in a moment, but the ability to handle them either way
makes them good for this example.
Progressive stages in the top-down and bottom-up construction of a parse tree
for the string A, B, C; appear in Figure 2.14. The top-down parser begins by
predicting that the root of the tree (id list) will expand to id id list tail. It then
matches the id against a token obtained from the scanner. (If the scanner pro-
duced something different, the parser would announce a syntax error.) The parser
then moves down into the ﬁrst (in this case only) nonterminal child and predicts
that id list tail will expand to , id id list tail. To make this prediction it needs
```

;

id(C)

id(B)

,

,

*id_list_tail*

*id_list_tail*

*id_list_tail*

id(A)

*id_list*

id(B)
,

*id_list_tail*

*id_list_tail*

id(A)

*id_list*

*id_list_tail*
id(A)

*id_list*

*id_list*

;

id(C)

id(B)

,

,

*id_list_tail*

*id_list_tail*

*id_list_tail*

id(A)

*id_list*

id(A) , id(B)

id(A)

;

;

id(C)
,

id(A) , id(B) , id(C)

id(A) , id(B) , id(C) ;

id(A) , id(B) , id(C)

id(A) , id(B) , 

id(A) , id(B)

id(A) ,

id(A)

*id_list_tail*

*id_list_tail*

*id_list_tail*

;

id(C)

id(B)

,

,

*id_list_tail*

*id_list_tail*

*id_list_tail*

id

, id

;

*id_list*
*id_list_tail*

*id_list_tail*

*id_list_tail*

*id_list_tail*


![Figure 2.14 Top-down (left)...](images/page_104_vector_502.png)
*Figure 2.14 Top-down (left) and bottom-up parsing (right) of the input string A, B, C;. Grammar appears at lower left.*

```
to peek at the upcoming token (a comma), which allows it to choose between the
two possible expansions for id list tail. It then matches the comma and the id
and moves down into the next id list tail. In a similar, recursive fashion, the top-
down parser works down the tree, left-to-right, predicting and expanding nodes
and tracing out a left-most derivation of the fringe of the tree.
```

