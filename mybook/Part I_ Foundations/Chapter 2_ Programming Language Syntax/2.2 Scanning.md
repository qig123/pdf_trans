# 2.2 Scanning

**54**
Chapter 2* Programming Language Syntax*

## 2.2

**Scanning**
Together, the scanner and parser for a programming language are responsible for
discovering the syntactic structure of a program. This process of discovery, or
*syntax analysis*, is a necessary ﬁrst step toward translating the program into an
equivalent program in the target language. (It’s also the ﬁrst step toward inter-
preting the program directly. In general, we will focus on compilation, rather
than interpretation, for the remainder of the book. Most of what we shall dis-
cuss either has an obvious application to interpretation, or is obviously irrelevant
to it.)
By grouping input characters into tokens, the scanner dramatically reduces the
number of individual items that must be inspected by the more computationally
intensive parser. In addition, the scanner typically removes comments (so the
parser doesn’t have to worry about them appearing throughout the context-free
grammar—see Exercise 2.20); saves the text of “interesting” tokens like identiﬁers,
strings, and numeric literals; and tags tokens with line and column numbers, to
make it easier to generate high-quality error messages in subsequent phases.
In Examples 2.4 and 2.8 we considered a simple language for arithmetic expres-
**EXAMPLE** 2.9

Tokens for a calculator
language
sions. In Section 2.3.1 we will extend this to create a simple “calculator language”
with input, output, variables, and assignment. For this language we will use the
following set of tokens:

```
assign −→:=
```

```
plus −→+
```

```
minus −→-
```

```
times −→*
```

```
div −→/
```

```
lparen −→(
```

```
rparen −→)
```

```
id −→letter ( letter | digit )*
except for read and write
```

```
number −→digit digit * | digit * ( . digit | digit . ) digit *
```

```
In keeping with Algol and its descendants (and in contrast to the C-family lan-
guages), we have used := rather than = for assignment. For simplicity, we have
omitted the exponential notation found in Example 2.3. We have also listed the
tokens read and write as exceptions to the rule for id (more on this in Sec-
tion 2.2.2). To make the task of the scanner a little more realistic, we borrow the
two styles of comment from C:
```

```
comment −→/* ( non-* | * non-/ )* *+ /
| // ( non-newline )* newline
```

```
Here we have used non-*, non-/, and non-newline as shorthand for the alterna-
tion of all characters other than *, /, and newline, respectively.
■
```

plus
minus
lparen

div

id or keyword

times
rparen

*letter, digit*

assign

number
number

=

1

2

3

4
5

6
7
8
9
10

11
12

13

14
15

16


![Figure 2.6 Pictorial representation...](images/page_90_vector_415.png)
*Figure 2.6 Pictorial representation of a scanner for calculator tokens, in the form of a ﬁnite automaton. This ﬁgure roughly parallels the code in Figure 2.5. States are numbered for reference in Figure 2.12. Scanning for each token begins in the state marked “Start.” The ﬁnal states, in which a token is recognized, are indicated by double circles. Comments, when recognized, send the scanner back to its start state, rather than a ﬁnal state.*

### state to a ﬁnal state whose non-epsilon transitions are labeled, in order, by the

### characters of the token.

### To avoid the need to search all possible paths for one that “works,” the second

### step of a scanner generatortranslates the NFA into an equivalentDFA: an automa-

### ton that accepts the same language, but in which there are no epsilon transitions,

### and no states with more than one outgoing transition labeled by the same char-

### acter. The third step is a space optimization that generates a ﬁnal DFA with the

### minimum possible number of states.

11
12
13
14


![Figure 2.8 Construction of...](images/page_92_vector_404.png)
*Figure 2.8 Construction of an NFA equivalent to the regular expression d*( .d | d. ) d*. In the top row are the primitive automata for . and d, and the Kleene closure construction for d*. In the second and third rows we have used the concatenation and alternation constructions to build .d, d., and ( .d | d. ) . The fourth row uses concatenation again to complete the NFA. We have labeled the states in the ﬁnal automaton for reference in subsequent ﬁgures.*

ones without any ambiguity about where to create the connections, and without
creating any unexpected paths.
■
To make these constructions concrete, we consider a small but nontrivial
**EXAMPLE** 2.13

```
NFA for d*( .d | d. ) d*
example—the decimal strings of Example 2.3. These consist of a string of decimal
digits containing a single decimal point. With only one digit, the point can come
at the beginning or the end: ( .d | d. ), where for brevity we use d to represent
any decimal digit. Arbitrary numbers of digits can then be added at the beginning
or the end: d*( .d | d. ) d*. Starting with this regular expression and using the
constructions of Figure 2.7, we illustrate the construction of an equivalent NFA
in Figure 2.8.
■
```

