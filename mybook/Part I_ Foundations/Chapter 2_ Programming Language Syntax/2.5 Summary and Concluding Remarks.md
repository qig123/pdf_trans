104
Chapter 2 Programming Language Syntax
It can be proven, constructively, that regular expressions and ﬁnite automata
are equivalent: one can construct a ﬁnite automaton that accepts the language
deﬁned by a given regular expression, and vice versa. Similarly, it is possible to
construct a push-down automaton that accepts the language deﬁned by a given
context-free grammar, and vice versa. The grammar-to-automaton constructions
are in fact performed by scanner and parser generators such as lex and yacc.
Of course, a real scanner does not accept just one token; it is called in a loop
so that it keeps accepting tokens repeatedly. As noted in Sidebar 2.4, this detail
is accommodated by having the scanner accept the alternation of all the tokens
in the language (with distinguished ﬁnal states), and by having it continue to
consume characters until no longer token can be constructed.
IN MORE DEPTH
On the companion site we consider ﬁnite and pushdown automata in more detail.
We give an algorithm to convert a DFA into an equivalent regular expression.
Combined with the constructions in Section 2.2.1, this algorithm demonstrates
the equivalence of regular expressions and ﬁnite automata. We also consider the
sets of grammars and languages that can and cannot be parsed by the various
linear-time parsing algorithms.
2.5
Summary and Concluding Remarks
In this chapter we have introduced the formalisms of regular expressions and
context-free grammars, and the algorithms that underlie scanning and parsing
in practical compilers. We also mentioned syntax error recovery, and presented a
quick overview of relevant parts of automata theory. Regular expressions and
context-free grammars are language generators: they specify how to construct
valid strings of characters or tokens. Scanners and parsers are language recogniz-
ers: they indicate whether a given string is valid. The principal job of the scanner
is to reduce the quantity of information that must be processed by the parser, by
grouping characters together into tokens, and by removing comments and white
space. Scanner and parser generators automatically translate regular expressions
and context-free grammars into scanners and parsers.
Practical parsers for programming languages (parsers that run in linear time)
fall into two principal groups: top-down (also called LL or predictive) and
bottom-up (also called LR or shift-reduce). A top-down parser constructs a parse
tree starting from the root and proceeding in a left-to-right depth-ﬁrst traversal.
A bottom-up parser constructs a parse tree starting from the leaves, again working
left-to-right, and combining partial trees together when it recognizes the children
of an internal node. The stack of a top-down parser contains a prediction of what
will be seen in the future; the stack of a bottom-up parser contains a record of
what has been seen in the past.
