# 2.6 Exercises

2.6 Exercises
**105**

```
Top-down parsers tend to be simple, both in the parsing of valid strings and in
the recovery from errors in invalid strings. Bottom-up parsers are more power-
ful, and in some cases lend themselves to more intuitively structured grammars,
though they suffer from the inability to embed action routines at arbitrary points
in a right-hand side (we discuss this point in more detail in Section C 4.5.1). Both
varieties of parser are used in real compilers, though bottom-up parsers are more
common. Top-down parsers tend to be smaller in terms of code and data size, but
modern machines provide ample memory for either.
Both scanners and parsers can be built by hand if an automatic tool is not
available. Handbuilt scanners are simple enough to be relatively common. Hand-
built parsers are generally limited to top-down recursive descent, and are most
commonly used for comparatively simple languages. Automatic generation of
the scanner and parser has the advantage of increased reliability, reduced devel-
opment time, and easy modiﬁcation and enhancement.
Various features of language design can have a major impact on the complex-
ity of syntax analysis. In many cases, features that make it difﬁcult for a compiler
to scan or parse also make it difﬁcult for a human being to write correct, main-
tainable code. Examples include the lexical structure of Fortran and the if...
then ... else statement of languages like Pascal. This interplay among language
design, implementation, and use will be a recurring theme throughout the re-
mainder of the book.
2.6
Exercises
```

```
2.1
Write regular expressions to capture the following.
(a) Strings in C. These are delimited by double quotes ("), and may not
contain newline characters. They may contain double-quote or back-
slash characters if and only if those characters are “escaped” by a pre-
ceding backslash. You may ﬁnd it helpful to introduce shorthand nota-
tion to represent any character that is not a member of a small speciﬁed
set.
(b) Comments in Pascal. These are delimited by (* and *) or by { and }.
They are not permitted to nest.
(c)
Numeric constants in C. These are octal, decimal, or hexadecimal inte-
gers, or decimal or hexadecimal ﬂoating-point values. An octal integer
begins with 0, and may contain only the digits 0–7. A hexadecimal
integer begins with 0x or 0X, and may contain the digits 0–9 and a/A–
f/F. A decimal ﬂoating-point value has a fractional portion (beginning
with a dot) or an exponent (beginning with E or e). Unlike a decimal
integer, it is allowed to start with 0. A hexadecimal ﬂoating-point value
has an optional fractional portion and a mandatory exponent (begin-
ning with P or p). In either decimal or hexadecimal, there may be digits
```

```
decl tail −→, decl
```

```
−→: ID ;
```

```
(The ﬁnal ID is meant to be a type name.)
2.12 Consider the following grammar:
```

```
B −→b E | a B B
```

```
(a) Describe in English the language that the grammar generates.
(b) Show a parse tree for the string a b a a.
(c)
Is the grammar LL(1)? If so, show the parse table; if not, identify a
prediction conﬂict.
```

### 2.13 Consider the following grammar:

*stmt** −→**assignment*

*−→**subr call*

```
assignment −→id := expr
```

```
subr call −→id ( arg list )
```

*expr** −→**primary expr tail*

*expr tail** −→**op expr*

*−→**ϵ*

```
primary −→id
```

*−→**subr call*

```
−→( expr )
```

```
op −→+ | - | * | /
```

*arg list** −→**expr args tail*

```
args tail −→, arg list
```

*−→**ϵ*

```
(a) Construct a parse tree for the input string
foo(a, b).
(b) Give a canonical (right-most) derivation of this same string.
(c)
Prove that the grammar is not LL(1).
(d) Modify the grammar so that it is LL(1).
```

```
2.14 Consider the language consisting of all strings of properly balanced paren-
theses and brackets.
(a) Give LL(1) and SLR(1) grammars for this language.
(b) Give the corresponding LL(1) and SLR(1) parsing tables.
(c)
For each grammar, show the parse tree for ([]([]))[](()).
(d) Give a trace of the actions of the parsers in constructing these trees.
2.15 Consider the following context-free grammar.
```

