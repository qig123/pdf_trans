# 2.4 Theoretical Foundations

2.4 Theoretical Foundations 103

syntax tree. To respond gracefully to certain common programming errors, the compiler writer may augment the grammar with error productions that capture language-speciﬁc idioms that are incorrect but are often written by mistake. Niklaus Wirth published an elegant implementation of phrase-level and context-speciﬁc recovery for recursive descent parsers in 1976 [Wir76, Sec. 5.9]. Exceptions (to be discussed further in Section 9.4) provide a simpler alternative if supported by the language in which the compiler is written. For table-driven top-down parsers, Fischer, Milton, and Quiring published an algorithm in 1980 that automatically implements a well-deﬁned notion of locally least-cost syntax repair. Locally least-cost repair is also possible in bottom-up parsers, but it is sig- niﬁcantly more difﬁcult. Most bottom-up parsers rely on more straightforward phrase-level recovery; a typical example can be found in yacc/bison.

2.4 Theoretical Foundations

Our understanding of the relative roles and computational power of scanners, parsers, regular expressions, and context-free grammars is based on the formal- isms of automata theory. In automata theory, a formal language is a set of strings of symbols drawn from a ﬁnite alphabet. A formal language can be speciﬁed ei- ther by a set of rules (such as regular expressions or a context-free grammar) that generates the language, or by a formal machine that accepts (recognizes) the lan- guage. A formal machine takes strings of symbols as input and outputs either “yes” or “no.” A machine is said to accept a language if it says “yes” to all and only those strings that are in the language. Alternatively, a language can be deﬁned as the set of strings for which a particular machine says “yes.” Formal languages can be grouped into a series of successively larger classes known as the Chomsky hierarchy.14 Most of the classes can be characterized in two ways: by the types of rules that can be used to generate the set of strings, or by the type of formal machine that is capable of recognizing the language. As we have seen, regular languages are deﬁned by using concatenation, alternation, and Kleene closure, and are recognized by a scanner. Context-free languages are a proper superset of the regular languages. They are deﬁned by using concatena- tion, alternation, and recursion (which subsumes Kleene closure), and are recog- nized by a parser. A scanner is a concrete realization of a ﬁnite automaton, a type of formal machine. A parser is a concrete realization of a push-down automaton. Just as context-free grammars add recursion to regular expressions, push-down automata add a stack to the memory of a ﬁnite automaton. There are additional levels in the Chomsky hierarchy, but they are less directly applicable to compiler construction, and are not covered here.

14 Noam Chomsky (1928–), a linguist and social philosopher at the Massachusetts Institute of Tech- nology, developed much of the early theory of formal languages.

