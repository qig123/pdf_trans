# 4.8 Exercises

4.8 Exercises
**209**

Just as context-free grammars can be categorized according to the parsing al-
gorithm(s) that can use them, attribute grammars can be categorized according to
the complexity of their pattern of* attribute ﬂow*. S-attributed grammars, in which
all attributes are synthesized, can naturally be evaluated in a single bottom-up
pass over a parse tree, in precisely the order the tree is discovered by an LR-family
parser. L-attributed grammars, in which all attribute ﬂow is depth-ﬁrst left-to-
right, can be evaluated in precisely the order that the parse tree is predicted and
matched by an LL-family parser. Attribute grammars with more complex pat-
terns of attribute ﬂow are not commonly used for the parse trees of production
compilers, but are valuable for syntax-based editors, incremental compilers, and
various other tools.
While it is possible to construct automatic tools to analyze attribute ﬂow and
decorate parse trees, most compilers rely on* action routines*, which the compiler
writer embeds in the right-hand sides of productions to evaluate attribute rules at
speciﬁc points in a parse. In an LL-family parser, action routines can be embed-
ded at arbitrary points in a production’s right-hand side. In an LR-family parser,
action routines must follow the production’s* left corner*. Space for attributes in
a bottom-up compiler is naturally allocated in parallel with the parse stack, but
this complicates the management of inherited attributes. Space for attributes in a
top-down compiler can be allocated automatically, or managed explicitly by the
writer of action routines. The automatic approach has the advantage of regularity,
and is easier to maintain; the ad hoc approach is slightly faster and more ﬂexible.
In a* one-pass* compiler, which interleaves scanning, parsing, semantic analysis,
and code generation in a single traversal of its input, semantic functions or action
routines are responsible for all of semantic analysis and code generation. More
commonly, action routines simply build a syntax tree, which is then decorated
during separate traversal(s) in subsequent pass(es). The code for these traversals
is usually written by hand, in the form of mutually recursive subroutines, allowing
the compiler to accommodate essentially arbitrary attribute ﬂow on the syntax
tree.
In subsequent chapters (6–10 in particular) we will consider a wide variety
of programming language constructs. Rather than present the actual attribute
grammars required to implement these constructs, we will describe their seman-
tics informally, and give examples of the target code. We will return to attribute
grammars in Chapter 15, when we consider the generation of intermediate code
in more detail.
## 4.8

**Exercises**
```
4.1
Basic results from automata theory tell us that the language L = anbncn =
ϵ, abc, aabbcc, aaabbbccc, ... is not context free. It can be captured,
however, using an attribute grammar. Give an underlying CFG and a set of
attribute rules that associates a Boolean attribute ok with the root R of each
```

a

b

c

*ϵ*

*ϵ*

*ϵ*


![Figure 4.16 Natural syntax...](images/page_243_vector_243.png)
*Figure 4.16 Natural syntax tree for the Lisp expression (cdr ‚(a b c)).*

```
parse tree, such that R.ok = true if and only if the string corresponding to
the fringe of the tree is in L.
4.2
Modify the grammar of Figure 2.25 so that it accepts only programs that
contain at least one write statement. Make the same change in the solution
to Exercise 2.17. Based on your experience, what do you think of the idea of
using the CFG to enforce the rule that every function in C must contain at
least one return statement?
4.3
Give two examples of reasonable semantic rules that cannot be checked at
reasonable cost, either statically or by compiler-generated code at run time.
4.4
Write an S-attributed attribute grammar, based on the CFG of Example 4.7,
that accumulates the value of the overall expression into the root of the
tree. You will need to use dynamic memory allocation so that individual
attributes can hold an arbitrary amount of information.
4.5
Lisp has the unusual property that its programs take the form of parenthe-
sized lists. The natural syntax tree for a Lisp program is thus a tree of binary
cells (known in Lisp as cons cells), where the ﬁrst child represents the ﬁrst
element of the list and the second child represents the rest of the list. The
syntax tree for (cdr ‚(a b c)) appears in Figure 4.16. (The notation ‚L is
syntactic sugar for (quote L).)
Extend the CFG of Exercise 2.18 to create an attribute grammar that will
build such trees. When a parse tree has been fully decorated, the root should
have an attribute v that refers to the syntax tree. You may assume that each
atom has a synthesized attribute v that refers to a syntax tree node that holds
information from the scanner. In your semantic functions, you may assume
the availability of a cons function that takes two references as arguments
and returns a reference to a new cons cell containing those references.
```

