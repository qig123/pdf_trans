# 4.4 Action Routines

### 4.4 Action Routines

### **195**

*E** −→**T TT*
** TT.st := T.ptr
** E.ptr := TT.ptr

```
TT1 −→+ T TT2
 TT2.st := make bin op(“+”, TT1.st, T.ptr)
 TT1.ptr := TT2.ptr
```

```
TT1 −→- T TT2
 TT2.st := make bin op(“−”, TT1.st, T.ptr)
 TT1.ptr := TT2.ptr
```

*TT** −→**ϵ*
** TT.ptr := TT.st

*T** −→**F FT*
** FT.st := F.ptr
** T.ptr := FT.ptr

```
FT1 −→* F FT2
 FT2.st := make bin op(“×”, FT1.st, F.ptr)
 FT1.ptr := FT2.ptr
```

```
FT1 −→/ F FT2
 FT2.st := make bin op(“÷”, FT1.st, F.ptr)
 FT1.ptr := FT2.ptr
```

*FT** −→**ϵ*
** FT.ptr := FT.st

```
F1 −→- F2
 F1.ptr := make un op(“+/−”, F2.ptr)
```

```
F −→( E )
 F.ptr := E.ptr
```

```
F −→const
 F.ptr := make leaf(const.val)
```


![Figure 4.6 Top-down (L-attributed)...](images/page_228_vector_431.png)
*Figure 4.6 Top-down (L-attributed) attribute grammar to construct a syntax tree. Here the st attribute, like the ptr attribute (and unlike the st attribute of Figure 4.3), is a pointer to a syntax tree node.*

### 9.

### What does it mean for an attribute grammar to be* S-attributed*?* L-attributed*?

### *Noncircular*? What is the signiﬁcance of these grammar classes?

## 4.4

### **Action Routines**

### Just as there are automatic tools that will construct a parser for a given context-

### free grammar, there are automatic tools that will construct a semantic analyzer

### (attribute evaluator) for a given attribute grammar. Attribute evaluator gen-

+

*F*
*

*

1
1

*E*
+
*T*

*F*

3
3

*T*

*F*

const

**(a)**

const

2

3
1

3
1

3
1

×

+

+

+


![Figure 4.7 Construction of...](images/page_229_vector_547.png)
*Figure 4.7 Construction of a syntax tree for (1 + 3) * 2 via decoration of a bottom-up parse tree, using the grammar of Figure 4.5. This ﬁgure reads from bottom to top. In diagram (a), the values of the constants 1 and 3 have been placed in new syntax tree leaves. Pointers to these leaves propagate up into the attributes of E and T. In (b), the pointers to these leaves become child pointers of a new internal + node. In (c) the pointer to this node propagates up into the attributes of T, and a new leaf is created for 2. Finally, in (d), the pointers from T and F become child pointers of a new internal × node, and a pointer to this node propagates up into the attributes of E.*

**(c)**

*ϵ*

*ϵ*

*ϵ*

*ϵ*

*ϵ*

2

3
1

3
1

+

+


![Figure 4.8 Construction of...](images/page_230_vector_515.png)
*Figure 4.8 Construction of a syntax tree via decoration of a top-down parse tree, using the grammar of Figure 4.6. In the top diagram, (a), the value of the constant 1 has been placed in a new syntax tree leaf. A pointer to this leaf then propagates to the st attribute of TT. In (b), a second leaf has been created to hold the constant 3. Pointers to the two leaves then become child pointers of a new internal + node, a pointer to which propagates from the st attribute of the bottom-most TT, where it was created, all the way up and over to the st attribute of the top-most FT. In (c), a third leaf has been created for the constant 2. Pointers to this leaf and to the + node then become the children of a new × node, a pointer to which propagates from the st of the lower FT, where it was created, all the way to the root of the tree.*

