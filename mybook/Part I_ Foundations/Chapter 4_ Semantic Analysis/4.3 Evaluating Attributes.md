# 4.3 Evaluating Attributes

4.3 Evaluating Attributes
### **187**

8
*E*

*T*

*
*F*

const

8

4
*T*

*F*

*E*
)
(

*T*

*F*

const

*E*

*T*

*F*

const

+

4

4

1

1

1

1

3

3

3

2

2


![Figure 4.2 Decoration of...](images/page_220_vector_351.png)
*Figure 4.2 Decoration of a parse tree for (1 + 3) * 2, using the attribute grammar of Figure 4.1. The val attributes of symbols are shown in boxes. Curving arrows show the attribute ﬂow, which is strictly upward in this case. Each box holds the output of a single semantic rule; the arrow(s) entering the box indicate the input(s) to the rule. At the second level of the tree, for example, the two arrows pointing into the box with the 8 represent application of the rule T1.val := product(T2.val, F.val). 4.3 Evaluating Attributes*

```
The process of evaluating attributes is called annotation or decoration of the parse
tree. Figure 4.2 shows how to decorate the parse tree for the expression (1 + 3)
EXAMPLE 4.6
```

```
Decoration of a parse tree
* 2, using the AG of Figure 4.1. Once decoration is complete, the value of the
overall expression can be found in the val attribute of the root of the tree.
■
```

**Synthesized Attributes**

The attribute grammar of Figure 4.1 is very simple. Each symbol has at most one
attribute (the punctuation marks have none). Moreover, they are all so-called
*synthesized attributes*: their values are calculated (synthesized) only in produc-
tions in which their symbol appears on the left-hand side. For annotated parse
trees like the one in Figure 4.2, this means that the* attribute ﬂow*—the pattern in
which information moves from node to node—is entirely bottom-up.

*TT*

*E*

*FT*

*F*

const

*FT*

*TT*
+

*ϵ*
*ϵ*

*ϵ*

*ϵ*

*ϵ*


![Figure 4.4 Decoration of...](images/page_224_vector_339.png)
*Figure 4.4 Decoration of a top-down parse tree for (1 + 3) * 2, using the AG of Figure 4.3. Curving arrows again indicate attribute ﬂow; the arrow(s) entering a given box represent the application of a single semantic rule. Flow in this case is no longer strictly bottom-up, but it is still left-to-right. At FT and TT nodes, the left box holds the st attribute; the right holds val.*

on itself. (A grammar can be circular and still be well deﬁned if attributes are
guaranteed to converge to a unique value.) As a general rule, practical attribute
grammars tend to be noncircular.
An algorithm that decorates parse trees by invoking the rules of an attribute
grammar in an order consistent with the tree’s attribute ﬂow is called a* translation*
*scheme*. Perhaps the simplest scheme is one that makes repeated passes over a
tree, invoking any semantic function whose arguments have all been deﬁned, and
stopping when it completes a pass in which no values change. Such a scheme is
said to be* oblivious*, in the sense that it exploits no special knowledge of either the
parse tree or the grammar. It will halt only if the grammar is well deﬁned. Better
performance, at least for noncircular grammars, may be achieved by a* dynamic*
scheme that tailors the evaluation order to the structure of a given parse tree—for
example, by constructing a topological sort of the attribute ﬂow graph and then
invoking rules in an order consistent with the sort.
The fastest translation schemes, however, tend to be* static*—based on an analy-
sis of the structure of the attribute grammar itself, and then applied mechanically
to any tree arising from the grammar. Like LL and LR parsers, linear-time static
translation schemes can be devised only for certain restricted classes of gram-

