200
Chapter 4 Semantic Analysis
side in which the production being parsed can be identiﬁed unambiguously (this
is known as the trailing part; the ambiguous preﬁx is the left corner). If the at-
tribute ﬂow of the action routines is strictly bottom-up (as it is in an S-attributed
attribute grammar), then execution at the end of right-hand sides is all that is
needed. The attribute grammars of Figures 4.1 and 4.5, in fact, are essentially
identical to the action routine versions. If the action routines are responsible for
a signiﬁcant part of semantic analysis, however (as opposed to simply building
a syntax tree), then they will often need contextual information in order to do
their job. To obtain and use this information in an LR parse, they will need some
(necessarily limited) access to inherited attributes or to information outside the
current production. We consider this issue further in Section C 4.5.1.
4.5
Space Management for Attributes
Any attribute evaluation method requires space to hold the attributes of the gram-
mar symbols. If we are building an explicit parse tree, then the obvious approach
is to store attributes in the nodes of the tree themselves. If we are not building a
parse tree, then we need to ﬁnd a way to keep track of the attributes for the sym-
bols we have seen (or predicted) but not yet ﬁnished parsing. The details differ in
bottom-up and top-down parsers.
For a bottom-up parser with an S-attributed grammar, the obvious approach
is to maintain an attribute stack that directly mirrors the parse stack: next to every
state number on the parse stack is an attribute record for the symbol we shifted
when we entered that state. Entries in the attribute stack are pushed and popped
automatically by the parser driver; space managementis not an issue for the writer
of action routines. Complications arise if we try to achieve the effect of inherited
attributes, but these can be accommodated within the basic attribute-stack frame-
work.
For a top-down parser with an L-attributed grammar, we have two principal
options. The ﬁrst option is automatic, but more complex than for bottom-up
grammars. It still uses an attribute stack, but one that does not mirror the parse
stack. The second option has lower space overhead, and saves time by “short-
cutting” copy rules, but requires action routines to allocate and deallocate space
for attributes explicitly.
In both families of parsers, it is common for some of the contextual infor-
mation for action routines to be kept in global variables. The symbol table in
particular is usually global. Rather than pass its full contents through attributes
from one production to the next, we pass an indication of the currently active
scope. Lookups in the global table then use this scope information to obtain the
right referencing environment.
