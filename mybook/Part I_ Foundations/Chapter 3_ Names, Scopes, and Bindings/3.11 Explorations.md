# 3.11 Explorations

3.11 Explorations
**175**

code should support unary negation and the four standard arithmetic oper-
ators. For extra credit, create a conversion routine that accepts two ﬂoating-
point parameters—a value and a error bound—and returns the simplest
(smallest denominator) rational number within the given error bound of
the given value.
3.22 In an imperative language with lambda expressions (e.g., C#, Ruby, C++, or
Java), write the following higher-level functions. (A higher-level function,
as we shall see in Chapter 11, takes other functions as argument and/or
returns a function as a result.)

```
compose(g, f)—returns a function h such that h(x) == g(f(x)).
map(f, L)—given a function f and a list L returns a list M such that
the ith element of M is f(e), where e is the ith element of L.
filter(L, P)—given a list L and a predicate (Boolean-returning
function) P, returns a list containing all and only those elements of L
for which P is true.
```

Ideally, your code should work for any argument or list element type.
3.23 Can you write a macro in standard C that “returns” the greatest common
divisor of a pair of arguments, without calling a subroutine? Why or why
not?
3.24–3.31 In More Depth.
## 3.11

**Explorations**
3.32 Experiment with naming rules in your favorite programming language.
Read the manual, and write and compile some test programs. Does the
language use lexical or dynamic scoping? Can scopes nest? Are they open
or closed? Does the scope of a name encompass the entire block in which it
is declared, or only the portion after the declaration? How does one declare
mutually recursive types or subroutines? Can subroutines be passed as pa-
rameters, returned from functions, or stored in variables? If so, when are
referencing environments bound?
3.33 List the keywords (reserved words) of one or more programming languages.
List the predeﬁned identiﬁers. (Recall that every keyword is a separate to-
ken. An identiﬁer cannot have the same spelling as a keyword.) What cri-
teria do you think were used to decide which names should be keywords
and which should be predeﬁned identiﬁers? Do you agree with the choices?
Why or why not?
3.34 If you have experience with a language like C, C++, or Rust, in which dy-
namically allocated space must be manually reclaimed, describe your ex-
perience with dangling references or memory leaks. How often do these

