3.11 Explorations
175
code should support unary negation and the four standard arithmetic oper-
ators. For extra credit, create a conversion routine that accepts two ﬂoating-
point parameters—a value and a error bound—and returns the simplest
(smallest denominator) rational number within the given error bound of
the given value.
3.22 In an imperative language with lambda expressions (e.g., C#, Ruby, C++, or
Java), write the following higher-level functions. (A higher-level function,
as we shall see in Chapter 11, takes other functions as argument and/or
returns a function as a result.)
compose(g, f)—returns a function h such that h(x) == g(f(x)).
map(f, L)—given a function f and a list L returns a list M such that
the ith element of M is f(e), where e is the ith element of L.
filter(L, P)—given a list L and a predicate (Boolean-returning
function) P, returns a list containing all and only those elements of L
for which P is true.
Ideally, your code should work for any argument or list element type.
3.23 Can you write a macro in standard C that “returns” the greatest common
divisor of a pair of arguments, without calling a subroutine? Why or why
not?
3.24–3.31 In More Depth.
3.11
Explorations
3.32 Experiment with naming rules in your favorite programming language.
Read the manual, and write and compile some test programs. Does the
language use lexical or dynamic scoping? Can scopes nest? Are they open
or closed? Does the scope of a name encompass the entire block in which it
is declared, or only the portion after the declaration? How does one declare
mutually recursive types or subroutines? Can subroutines be passed as pa-
rameters, returned from functions, or stored in variables? If so, when are
referencing environments bound?
3.33 List the keywords (reserved words) of one or more programming languages.
List the predeﬁned identiﬁers. (Recall that every keyword is a separate to-
ken. An identiﬁer cannot have the same spelling as a keyword.) What cri-
teria do you think were used to decide which names should be keywords
and which should be predeﬁned identiﬁers? Do you agree with the choices?
Why or why not?
3.34 If you have experience with a language like C, C++, or Rust, in which dy-
namically allocated space must be manually reclaimed, describe your ex-
perience with dangling references or memory leaks. How often do these
176
Chapter 3 Names, Scopes, and Bindings
bugs arise? How do you ﬁnd them? How much effort does it take? Learn
about open-source or commercial tools for ﬁnding storage bugs (Valgrind
is a popular open-source example). Do such tools weaken the argument for
automatic garbage collection?
3.35 A few languages—notably Euclid and Turing, make every subroutine a
closed scope, and require it to explicitly import any nonlocal names it uses.
The import lists can be thought of as explicit, mandatory documentation of
a part of the subroutine interface that is usually implicit. The use of import
lists also makes it easy for Euclid and Turing to prohibit passing a variable,
by reference, to a subroutine that also accesses that variable directly, thereby
avoiding the errors alluded to in Example 3.20.
In programs you have written, how hard would it have been to document
every use of a nonlocal variable? Would the effort be worth the improve-
ment in the quality of documentation and error rates?
3.36 We learned in Section 3.3.6 that modern languages have generally aban-
doned dynamic scoping. One place it can still be found is in the so-called
environment variables of the Unix programming environment. If you are
not familiar with these, read the manual page for your favorite shell (com-
mand interpreter—ksh/bash, csh/tcsh, etc.) to learn how these behave.
Explain why the usual alternatives to dynamic scoping (default parameters
and static variables) are not appropriate in this case.
3.37 Compare the mechanisms for overloading of enumeration names in Ada
and in Modula-3 or C# (Section 3.5.2). One might argue that the (histor-
ically more recent) Modula-3/C# approach moves responsibility from the
compiler to the programmer: it requires even an unambiguous use of an
enumeration constant to be annotated with its type. Why do you think this
approach was chosen by the language designers? Do you agree with the
choice? Why or why not?
3.38 Learn about tied variables in Perl. These allow the programmer to asso-
ciate an ordinary variable with an (object-oriented) object in such a way
that operations on the variable are automatically interpreted as method in-
vocations on the object. As an example, suppose we write tie $my_var,
"my_class";. The interpreter will create a new object of class my_class,
which it will associate with scalar variable $my_var. For purposes of dis-
cussion, call that object O. Now, any attempt to read the value of $my_var
will be interpreted as a call to method O->FETCH(). Similarly, the assign-
ment $my_var = value will be interpreted as a call to O->STORE(value).
Array, hash, and ﬁlehandle variables, which support a larger set of built-in
operations, provide access to a larger set of methods when tied.
Compare Perl’s tying mechanism to the operator overloading of C++.
Which features of each language can be convenientlyemulated by the other?
3.39 Do you think coercion is a good idea? Why or why not?
3.40 The syntax for lambda expressions in Ruby evolved over time, with the re-
sult that there are now four ways to pass a block into a method as a closure:
