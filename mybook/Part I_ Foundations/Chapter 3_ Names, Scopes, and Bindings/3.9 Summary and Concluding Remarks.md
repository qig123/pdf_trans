# 3.9 Summary and Concluding Remarks

3.8 Separate Compilation
**165**

## 3.8

**Separate Compilation**
Since most large programs are constructed and tested incrementally, and since the
compilation of a very large program can be a multihour operation, any language
designed to support large programs must provide for separate compilation.

**IN MORE DEPTH**

On the companion site we consider the relationship between modules and sepa-
rate compilation. Because they are designed for encapsulation and provide a nar-
row interface, modules are the natural choice for the “compilation units” of many
programming languages. The separate module headers and bodies of Modula-3
and Ada, for example, are explicitly intended for separate compilation, and reﬂect
experience gained with more primitive facilities in other languages. C and C++,
by contrast, must maintain backward compatibility with mechanisms designed in
the early 1970s. Modern versions of C and C++ include a* namespace* mechanism
that provides module-like data hiding, but names must still be declared before
they are used in every compilation unit, and the mechanisms used to accom-
modate this rule are purely a matter of convention. Java and C# break with the
C tradition by requiring the compiler to infer header information automatically
from separately compiled class deﬁnitions; no header ﬁles are required.

## 3.9

**Summary and Concluding Remarks**
This chapter has addressed the subject of names, and the* binding* of names to ob-
jects (in a broad sense of the word). We began with a general discussion of the
notion of* binding time*—the time at which a name is associated with a particular
object or, more generally, the time at which an answer is associated with any open
question in language or program design or implementation. We deﬁned the no-
tion of* lifetime* for both objects and name-to-object bindings, and noted that they
need not be the same. We then introduced the three principal storage allocation
mechanisms—static, stack, and heap—used to manage space for objects.
In Section 3.3 we described how the binding of names to objects is governed by
*scope rules*. In some languages, scope rules are dynamic: the meaning of a name is
found in the most recently entered scope that contains a declaration and that has
not yet been exited. In most modern languages, however, scope rules are static, or
*lexical*: the meaning of a name is found in the closest lexically surrounding scope
that contains a declaration. We found that lexical scope rules vary in important
but sometimes subtle ways from one language to another. We considered what
sorts of scopes are allowed to nest, whether scopes are* open* or* closed*, whether the
scope of a name encompasses the entire block in which it is declared, and whether

