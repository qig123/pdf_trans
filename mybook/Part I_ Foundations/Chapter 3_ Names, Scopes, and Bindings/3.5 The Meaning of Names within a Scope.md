# 3.5 The Meaning of Names within a Scope

3.5 The Meaning of Names within a Scope
**145**

max score : integer
–– maximum possible score

function scaled score(raw score : integer) : real
return raw score / max score * 100
. . .
procedure foo( )
max score : real := 0
–– highest percentage seen so far
. . .
foreach student in class
student.percent := scaled score(student.points)
if student.percent* >* max score
max score := student.percent


![Figure 3.10 The problem...](images/page_178_vector_212.png)
*Figure 3.10 The problem with dynamic scoping. Procedure scaled score probably does not do what the programmer intended when dynamic scope rules allow procedure foo to change the meaning of max score.*

An association list (or* A-list* for short) is simply a list of name/value pairs.
When used to implement dynamic scoping it functions as a stack: new declara-
tions are pushed as they are encountered, and popped at the end of the scope in
which they appeared. Bindings are found by searching down the list from the top.
A central reference table avoids the need for linear-time search by maintaining
an explicit mapping from names to their current meanings. Lookup is faster, but
scope entry and exit are somewhat more complex, and it becomes substantially
more difﬁcult to save a referencing environment for future use (we discuss this
issue further in Section 3.6.1).

## 3.5

**The Meaning of Names within a Scope**
So far in our discussion of naming and scopes we have assumed that there is
a one-to-one mapping between names and visible objects at any given point in
a program. This need not be the case. Two or more names that refer to the
same object at the same point in the program are said to be* aliases*. A name
that can refer to more than one object at a given point in the program is said
to be* overloaded*. Overloading is in turn related to the more general subject of
*polymorphism*, which allows a subroutine or other program fragment to behave
in different ways depending on the types of its arguments.

3.5.1** Aliases**

Simple examples of aliases occur in the variant records and unions of many pro-
gramming languages (we will discuss these features detail in Section C 8.1.3).

In Modula-3 and C#,* every* use of an enumeration constant must be preﬁxed with
a type name, even when there is no chance of ambiguity:

**Redeﬁning Built-in Operators**

```
Many languages also allow the built-in arithmetic operators (+, -, *, etc.) to be
overloaded with user-deﬁned functions. Ada, C++, and C# do this by deﬁning
EXAMPLE 3.25
```

```
Operator overloading
in Ada
alternative preﬁx forms of each operator, and deﬁning the usual inﬁx forms to be
abbreviations (or “syntactic sugar”) for the preﬁx forms. In Ada, A + B is short
for "+"(A, B). If "+" (the preﬁx form) is overloaded, then + (the inﬁx form)
will work for the new types as well. It must be possible to resolve the overloading
(determine which + is intended) from the types of A and B.
■
Fortran 90 provides a special interface construct that can be used to
associate an operator with some named binary function.
In C++ and C#,
EXAMPLE 3.26
```

```
Operator overloading
in C++
which are object-oriented, A + B may be short for either operator+(A, B) or
A.operator+(B). In the latter case, A is an instance of a class (module type) that
deﬁnes an operator+ function. In C++ one might say
```

