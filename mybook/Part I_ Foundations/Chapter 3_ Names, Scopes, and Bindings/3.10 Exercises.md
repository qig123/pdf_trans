# 3.10 Exercises

3.10 Exercises
**167**

```
implementation do not always go together. Many easy-to-compile features (e.g.,
goto statements) are of questionable value at best. We will also see several ex-
amples of highly useful and (conceptually) simple features, such as garbage col-
lection (Section 8.5.3) and uniﬁcation (Sections 7.2.4, C 7.3.2, and 12.2.1), whose
implementations are quite complex.
3.10
Exercises
```

3.1
Indicate the binding time (when the language is designed, when the pro-
gram is linked, when the program begins execution, etc.) for each of the
following decisions in your favorite programming language and implemen-
tation. Explain any answers you think are open to interpretation.

The number of built-in functions (math, type queries, etc.)
The variable declaration that corresponds to a particular variable refer-
ence (use)
The maximum length allowed for a constant (literal) character string
The referencing environment for a subroutine that is passed as a pa-
rameter
The address of a particular library routine
The total amount of space occupied by program code and data
3.2
In Fortran 77, local variables were typically allocated statically. In Algol
and its descendants (e.g., Ada and C), they are typically allocated in the
stack. In Lisp they are typically allocated at least partially in the heap. What
accounts for these differences? Give an example of a program in Ada or
C that would not work correctly if local variables were allocated statically.
Give an example of a program in Scheme or Common Lisp that would not
work correctly if local variables were allocated on the stack.
3.3
Give two examples in which it might make sense to delay the binding of an
implementation decision, even though sufﬁcient information exists to bind
it early.
3.4
Give three concrete examples drawn from programming languages with
which you are familiar in which a variable is live but not in scope.
3.5
Consider the following pseudocode:

1.
procedure main()
2.
a : integer := 1
3.
b : integer := 2

4.
procedure middle()
5.
b : integer := a

6.
procedure inner()
7.
print a, b

procedure A(n : integer)
g := n

procedure R(m : integer)
write integer(x)
x /:= 2 –– integer division
if x > 1
R(m + 1)
else
A(m)

–– body of B
x := a × a
R(1)

–– body of main
B(3)
write integer(g)

### (a) What does this program print?

