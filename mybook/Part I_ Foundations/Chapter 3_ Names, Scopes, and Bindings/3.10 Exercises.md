3.10 Exercises
167
implementation do not always go together. Many easy-to-compile features (e.g.,
goto statements) are of questionable value at best. We will also see several ex-
amples of highly useful and (conceptually) simple features, such as garbage col-
lection (Section 8.5.3) and uniﬁcation (Sections 7.2.4, C 7.3.2, and 12.2.1), whose
implementations are quite complex.
3.10
Exercises
3.1
Indicate the binding time (when the language is designed, when the pro-
gram is linked, when the program begins execution, etc.) for each of the
following decisions in your favorite programming language and implemen-
tation. Explain any answers you think are open to interpretation.
The number of built-in functions (math, type queries, etc.)
The variable declaration that corresponds to a particular variable refer-
ence (use)
The maximum length allowed for a constant (literal) character string
The referencing environment for a subroutine that is passed as a pa-
rameter
The address of a particular library routine
The total amount of space occupied by program code and data
3.2
In Fortran 77, local variables were typically allocated statically. In Algol
and its descendants (e.g., Ada and C), they are typically allocated in the
stack. In Lisp they are typically allocated at least partially in the heap. What
accounts for these differences? Give an example of a program in Ada or
C that would not work correctly if local variables were allocated statically.
Give an example of a program in Scheme or Common Lisp that would not
work correctly if local variables were allocated on the stack.
3.3
Give two examples in which it might make sense to delay the binding of an
implementation decision, even though sufﬁcient information exists to bind
it early.
3.4
Give three concrete examples drawn from programming languages with
which you are familiar in which a variable is live but not in scope.
3.5
Consider the following pseudocode:
1.
procedure main()
2.
a : integer := 1
3.
b : integer := 2
4.
procedure middle()
5.
b : integer := a
6.
procedure inner()
7.
print a, b
168
Chapter 3 Names, Scopes, and Bindings
8.
a : integer := 3
9.
–– body of middle
10.
inner()
11.
print a, b
12.
–– body of main
13.
middle()
14.
print a, b
Suppose this was code for a language with the declaration-order rules of C
(but with nested subroutines)—that is, names must be declared before use,
and the scope of a name extends from its declaration through the end of
the block. At each print statement, indicate which declarations of a and b
are in the referencing environment. What does the program print (or will
the compiler identify static semantic errors)? Repeat the exercise for the
declaration-order rules of C# (names must be declared before use, but the
scope of a name is the entire block in which it is declared) and of Modula-3
(names can be declared in any order, and their scope is the entire block in
which they are declared).
3.6
Consider the following pseudocode, assuming nested subroutines and static
scope:
procedure main()
g : integer
procedure B(a : integer)
x : integer
procedure A(n : integer)
g := n
procedure R(m : integer)
write integer(x)
x /:= 2 –– integer division
if x > 1
R(m + 1)
else
A(m)
–– body of B
x := a × a
R(1)
–– body of main
B(3)
write integer(g)
(a) What does this program print?
3.10 Exercises
169
typedef struct list_node {
void* data;
struct list_node* next;
} list_node;
list_node* insert(void* d, list_node* L) {
list_node* t = (list_node*) malloc(sizeof(list_node));
t->data = d;
t->next = L;
return t;
}
list_node* reverse(list_node* L) {
list_node* rtn = 0;
while (L) {
rtn = insert(L->data, rtn);
L = L->next;
}
return rtn;
}
void delete_list(list_node* L) {
while (L) {
list_node* t = L;
L = L->next;
free(t->data);
free(t);
}
}


![Figure 3.16 List management...](images/page_202_caption_Figure%203.16%20List%20management%20routines%20for%20Exercise%203.7.png)
*Figure 3.16 List management routines for Exercise 3.7.*

(b) Show the frames on the stack when A has just been called. For each
frame, show the static and dynamic links.
(c)
Explain how A ﬁnds g.
3.7
As part of the development team at MumbleTech.com, Janet has written a
list manipulation library for C that contains, among other things, the code
in Figure 3.16.
(a) Accustomed to Java, new team member Brad includes the following
code in the main loop of his program:
list_node* L = 0;
while (more_widgets()) {
L = insert(next_widget(), L);
}
L = reverse(L);
170
Chapter 3 Names, Scopes, and Bindings
Sadly, after running for a while, Brad’s program always runs out of
memory and crashes. Explain what’s going wrong.
(b) After Janet patiently explains the problem to him, Brad gives it another
try:
list_node* L = 0;
while (more_widgets()) {
L = insert(next_widget(), L);
}
list_node* T = reverse(L);
delete_list(L);
L = T;
This seems to solve the insufﬁcient memory problem, but where the
program used to produce correct results (before running out of mem-
ory), now its output is strangely corrupted, and Brad goes back to Janet
for advice. What will she tell him this time?
3.8
Rewrite Figures 3.6 and 3.7 in C. You will need to use separate compilation
for name hiding.
3.9
Consider the following fragment of code in C:
{
int a, b, c;
...
{
int d, e;
...
{
int f;
...
}
...
}
...
{
int g, h, i;
...
}
...
}
(a) Assume that each integer variable occupies four bytes. How much total
space is required for the variables in this code?
(b) Describe an algorithm that a compiler could use to assign stack frame
offsets to the variables of arbitrary nested blocks, in a way that mini-
mizes the total space required.
3.10 Consider the design of a Fortran 77 compiler that uses static allocation for
the local variables of subroutines. Expanding on the solution to the pre-
vious question, describe an algorithm to minimize the total space required
for these variables. You may ﬁnd it helpful to construct a call graph data
3.10 Exercises
171
structure in which each node represents a subroutine, and each directed arc
indicates that the subroutine at the tail may sometimes call the subroutine
at the head.
3.11 Consider the following pseudocode:
procedure P(A, B : real)
X : real
procedure Q(B, C : real)
Y : real
. . .
procedure R(A, C : real)
Z : real
. . .
–– (*)
. . .
Assuming static scope, what is the referencing environment at the location
marked by (*)?
3.12 Write a simple program in Scheme that displays three different behaviors,
depending on whether we use let, let*, or letrec to declare a given set
of names. (Hint: To make good use of letrec, you will probably want your
names to be functions [lambda expressions].)
3.13 Consider the following program in Scheme:
(define A
(lambda()
(let* ((x 2)
(C (lambda (P)
(let ((x 4))
(P))))
(D (lambda ()
x))
(B (lambda ()
(let ((x 3))
(C D)))))
(B))))
What does this program print? What would it print if Scheme used dynamic
scoping and shallow binding? Dynamic scoping and deep binding? Explain
your answers.
3.14 Consider the following pseudocode:
x : integer
–– global
procedure set x(n : integer)
x := n
172
Chapter 3 Names, Scopes, and Bindings
procedure print x()
write integer(x)
procedure ﬁrst()
set x(1)
print x()
procedure second()
x : integer
set x(2)
print x()
set x(0)
ﬁrst()
print x()
second()
print x()
What does this program print if the language uses static scoping? What does
it print with dynamic scoping? Why?
3.15 The principal argument in favor of dynamic scoping is that it facilitates
the customization of subroutines. Suppose, for example, that we have a
library routine print integer that is capable of printing its argument in any
of several bases (decimal, binary, hexadecimal, etc.). Suppose further that
we want the routine to use decimal notation most of the time, and to use
other bases only in a few special cases: we do not want to have to specify
a base explicitly on each individual call. We can achieve this result with
dynamic scoping by having print integer obtain its base from a nonlocal
variable print base. We can establish the default behavior by declaring a
variable print base and setting its value to 10 in a scope encountered early
in execution. Then, any time we want to change the base temporarily, we
can write
begin
–– nested block
print base : integer := 16
–– use hexadecimal
print integer(n)
The problem with this argument is that there are usually other ways to
achieve the same effect, without dynamic scoping. Describe at least two
for the print integer example.
3.16 As noted in Section 3.6.3, C# has unusually sophisticated support for ﬁrst-
class subroutines. Among other things, it allows delegates to be instantiated
from anonymous nested methods, and gives local variables and parameters
unlimited extent when they may be needed by such a delegate. Consider the
implications of these features in the following C# program:
3.10 Exercises
173
using System;
public delegate int UnaryOp(int n);
// type declaration: UnaryOp is a function from ints to ints
public class Foo {
static int a = 2;
static UnaryOp b(int c) {
int d = a + c;
Console.WriteLine(d);
return delegate(int n) { return c + n; };
}
public static void Main(string[] args) {
Console.WriteLine(b(3)(4));
}
}
What does this program print? Which of a, b, c, and d, if any, is likely to be
statically allocated? Which could be allocated on the stack? Which would
need to be allocated in the heap? Explain.
3.17 If you are familiar with structured exception handling, as provided in Ada,
C++, Java, C#, ML, Python, or Ruby, consider how this mechanism relates
to the issue of scoping. Conventionally, a raise or throw statement is
thought of as referring to an exception, which it passes as a parameter to
a handler-ﬁnding library routine. In each of the languages mentioned, the
exception itself must be declared in some surrounding scope, and is sub-
ject to the usual static scope rules. Describe an alternative point of view, in
which the raise or throw is actually a reference to a handler, to which it
transfers control directly. Assuming this point of view, what are the scope
rules for handlers? Are these rules consistent with the rest of the language?
Explain. (For further information on exceptions, see Section 9.4.)
3.18 Consider the following pseudocode:
x : integer
–– global
procedure set x(n : integer)
x := n
procedure print x()
write integer(x)
procedure foo(S, P : function; n : integer)
x : integer := 5
if n in {1, 3}
set x(n)
else
S(n)
174
Chapter 3 Names, Scopes, and Bindings
if n in {1, 2}
print x()
else
P
set x(0); foo(set x, print x, 1); print x()
set x(0); foo(set x, print x, 2); print x()
set x(0); foo(set x, print x, 3); print x()
set x(0); foo(set x, print x, 4); print x()
Assume that the language uses dynamic scoping. What does the program
print if the language uses shallow binding? What does it print with deep
binding? Why?
3.19 Consider the following pseudocode:
x : integer := 1
y : integer := 2
procedure add()
x := x + y
procedure second(P : procedure)
x : integer := 2
P()
procedure ﬁrst
y : integer := 3
second(add)
ﬁrst()
write integer(x)
(a) What does this program print if the language uses static scoping?
(b) What does it print if the language uses dynamic scoping with deep bind-
ing?
(c)
What does it print if the language uses dynamic scoping with shallow
binding?
3.20 Consider mathematical operations in a language like C++, which supports
both overloading and coercion. In many cases, it may make sense to pro-
vide multiple, overloaded versions of a function, one for each numeric type
or combination of types. In other cases, we might use a single version—
probably deﬁned for double-precision ﬂoating point arguments—and rely
on coercion to allow that function to be used for other numeric types (e.g.,
integers). Give an example in which overloading is clearly the preferable
approach. Give another in which coercion is almost certainly better.
3.21 In a language that supports operator overloading, build support for ration-
al numbers. Each number should be represented internally as a (numera-
tor, denominator) pair in simplest form, with a positive denominator. Your
