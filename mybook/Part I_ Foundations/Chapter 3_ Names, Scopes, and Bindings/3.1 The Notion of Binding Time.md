# 3.1 The Notion of Binding Time

**116**
Chapter 3* Names, Scopes, and Bindings*

the lifetime of an object and the lifetime of a binding of a name to that object.1
Most name-to-object bindings are usable only within a limited region of a given
high-level program. Section 3.3 explores the* scope* rules that deﬁne this region;
Section 3.4 (mostly on the companion site) considers their implementation.
The complete set of bindings in effect at a given point in a program is known as
the current* referencing environment*. Section 3.5 discusses aliasing, in which more
than one name may refer to a given object in a given scope, and overloading, in
which a name may refer to more than one object in a given scope, depending on
the context of the reference. Section 3.6 expands on the notion of scope rules
by considering the ways in which a referencing environment may be bound to a
subroutine that is passed as a parameter, returned from a function, or stored in a
variable. Section 3.7 discusses macro expansion, which can introduce new names
via textual substitution, sometimes in ways that are at odds with the rest of the
language. Finally, Section 3.8 (mostly on the companion site) discusses separate
compilation.
## 3.1

**The Notion of Binding Time**
A* binding* is an association between two things, such as a name and the thing it
names.* Binding time* is the time at which a binding is created or, more generally,
the time at which any implementation decision is made (we can think of this
as binding an answer to a question). There are many different times at which
decisions may be bound:

*Language design time:* In most languages, the control-ﬂow constructs, the set of
fundamental (primitive) types, the available* constructors* for creating complex
types, and many other aspects of language semantics are chosen when the lan-
guage is designed.
*Language implementation time:* Most language manuals leave a variety of issues
to the discretion of the language implementor. Typical (though by no means
universal) examples include the precision (number of bits) of the fundamental
types, the coupling of I/O to the operating system’s notion of ﬁles, and the
organization and maximum sizes of the stack and heap.
*Program writing time:* Programmers, of course, choose algorithms, data struc-
tures, and names.
*Compile time:* Compilers choose the mapping of high-level constructs to ma-
chine code, including the layout of statically deﬁned data in memory.

**1**
For want of a better term, we will use the term “object” throughout Chapters 3–9 to refer to
anything that might have a name: variables, constants, types, subroutines, modules, and oth-
ers. In many modern languages “object” has a more formal meaning, which we will consider in
Chapter 10.

