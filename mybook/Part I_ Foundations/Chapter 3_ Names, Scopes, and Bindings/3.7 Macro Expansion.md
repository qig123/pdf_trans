# 3.7 Macro Expansion

**162**
Chapter 3* Names, Scopes, and Bindings*

```
Lambda expressions appear in Java 8 as well, but in a restricted form. In situa-
tions where they might be useful, Java has traditionally relied on an idiom known
as a functional interface. The Arrays.sort routine, for example, expects a pa-
EXAMPLE 3.41
```

```
Lambda expressions in
Java 8
rameter of type Comparator. To sort an array of personnel records by age, we
would (traditionally) have written
```

```
class AgeComparator implements Comparator<Person> {
public int compare(Person p1, Person p2) {
return Integer.compare(p1.age, p2.age);
}
}
Person[] People = ...
...
Arrays.sort(People, new AgeComparator());
```

```
Signiﬁcantly, Comparator has only a single abstract method: the compare rou-
tine provided by our AgeComparator class. With lambda expressions in Java 8, we
can omit the declaration of AgeComparator and simply write
```

```
Arrays.sort(People, (p1, p2) -> Integer.compare(p1.age, p2.age));
```

```
The key to the simpler syntax is that Comparator is a functional interface, and
thus has only a single abstract method. When a variable or formal parameter
is declared to be of some functional interface type, Java 8 allows a lambda ex-
pression whose parameter and return types match those of the interface’s single
method to be assigned into the variable or passed as the parameter. In effect, the
compiler uses the lambda expression to create an instance of an anonymous class
that implements the interface.
■
As it turns out, coercion to functional interface types is the only use of lambda
expressions in Java. In particular, lambda expressions have no types of their own:
they are not really objects, and cannot be directly manipulated. Their behav-
ior with respect to variable capture is entirely determined by the usual rules for
nested classes. We will consider these rules in more detail in Section 10.2.3;
for now, sufﬁce it to note that Java, like C++, does not support unlimited
extent.
```

## 3.7

**Macro Expansion**
Prior to the development of high-level programming languages, assembly lan-
guage programmers could ﬁnd themselves writing highly repetitive code. To ease
the burden, many assemblers provided sophisticated* macro expansion* facilities.
Consider the task of loading an element of a two-dimensional array from memory
**EXAMPLE** 3.42

A simple assembly macro
into a register. As we shall see in Section 8.2.3, this operation can easily require

