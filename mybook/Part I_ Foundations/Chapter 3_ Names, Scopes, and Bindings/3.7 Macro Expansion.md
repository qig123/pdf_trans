# 3.7 Macro Expansion

162 Chapter 3 Names, Scopes, and Bindings

Lambda expressions appear in Java 8 as well, but in a restricted form. In situa- tions where they might be useful, Java has traditionally relied on an idiom known as a functional interface. The Arrays.sort routine, for example, expects a pa- EXAMPLE 3.41

Lambda expressions in Java 8 rameter of type Comparator. To sort an array of personnel records by age, we would (traditionally) have written

class AgeComparator implements Comparator<Person> { public int compare(Person p1, Person p2) { return Integer.compare(p1.age, p2.age); } } Person[] People = ... ... Arrays.sort(People, new AgeComparator());

Signiﬁcantly, Comparator has only a single abstract method: the compare rou- tine provided by our AgeComparator class. With lambda expressions in Java 8, we can omit the declaration of AgeComparator and simply write

Arrays.sort(People, (p1, p2) -> Integer.compare(p1.age, p2.age));

The key to the simpler syntax is that Comparator is a functional interface, and thus has only a single abstract method. When a variable or formal parameter is declared to be of some functional interface type, Java 8 allows a lambda ex- pression whose parameter and return types match those of the interface’s single method to be assigned into the variable or passed as the parameter. In effect, the compiler uses the lambda expression to create an instance of an anonymous class that implements the interface. ■ As it turns out, coercion to functional interface types is the only use of lambda expressions in Java. In particular, lambda expressions have no types of their own: they are not really objects, and cannot be directly manipulated. Their behav- ior with respect to variable capture is entirely determined by the usual rules for nested classes. We will consider these rules in more detail in Section 10.2.3; for now, sufﬁce it to note that Java, like C++, does not support unlimited extent.

3.7 Macro Expansion

Prior to the development of high-level programming languages, assembly lan- guage programmers could ﬁnd themselves writing highly repetitive code. To ease the burden, many assemblers provided sophisticated macro expansion facilities. Consider the task of loading an element of a two-dimensional array from memory EXAMPLE 3.42

A simple assembly macro into a register. As we shall see in Section 8.2.3, this operation can easily require

3.7 Macro Expansion 163

half a dozen instructions, with details depending on the hardware instruction set; the size of the array elements; and whether the indices are constants, values in memory, or values in registers. In many early assemblers, one could deﬁne a macro that would replace an expression like ld2d(target reg, array name, row, col- umn, row size, element size) with the appropriate multi-instruction sequence. In a numeric program containing hundreds or thousands of array access operations, this macro could prove extremely useful. ■ When C was created in the early 1970s, it was natural to include a macro pre- EXAMPLE 3.43

Preprocessor macros in C processing facility:

#define LINE_LEN 80 #define DIVIDES(a,n) (!((n) % (a))) /* true iff n has zero remainder modulo a */ #define SWAP(a,b) {int t = (a); (a) = (b); (b) = t;} #define MAX(a,b) ((a) > (b) ? (a) : (b))

Macros like LINE_LEN avoided the need (in early versions of C) to support named constants in the language itself. Perhaps more important, parameterized macros like DIVIDES, MAX, and SWAP were much more efﬁcient than equivalent C func- tions. They avoided the overhead of the subroutine call mechanism (including register saves and restores), and the code they generated could be integrated into any code improvements that the compiler was able to effect in the code surround- ing the call. ■ Unfortunately, C macros suffer from severallimitations, all of which stem from EXAMPLE 3.44

“Gotchas” in C macros the fact that they are implementedby textual substitution, and are not understood by the rest of the compiler. Put another way, they provide a naming and binding mechanism that is separate from—and often at odds with—the rest of the pro- gramming language. In the deﬁnition of DIVIDES, the parentheses around the occurrences of a and n are essential. Without them, DIVIDES(y + z, x) would be replaced by (!(x % y + z)), which is the same as (!((x % y) + z)), according to the rules of prece- dence. In a similar vein, SWAP may behave unexpectedly if the programmer writes SWAP(x, t): textual substitution of arguments allows the macro’s declaration of t to capture the t that was passed. MAX(x++, y++) may also behave unexpect- edly, since the increment side effects will happen more than once. Unfortunately,

DESIGN & IMPLEMENTATION

3.11 Generics as macros In some sense, the ability to import names into an ordinary module provides a primitive sort of generic facility. A stack module that imports its element type, for example, can be inserted (with a text editor) into any context in which the appropriate type name has been declared, and will produce a “customized” stack for that context when compiled. Early versions of C++ formalized this mechanism by using macros to implement templates. Later versions of C++ have made templates (generics) a fully supported language feature, giving them much of the ﬂavor of hygienic macros. (More on templates and on template metaprogramming can be found in Section C 7.3.2.)

164 Chapter 3 Names, Scopes, and Bindings

in standard C we cannot avoid the extra side effects by assigning the parameters into temporary variables: a C macro that “returns” a value must be an expression, and declarations are one of many language constructs that cannot appear inside (see also Exercise 3.23). ■ Modern languages and compilers have, for the most part, abandoned macros as an anachronism. Named constants are type-safe and easy to implement, and in-line subroutines (to be discussed in Section 9.2.4) provide almost all the per- formance of parameterized macros without their limitations. A few languages (notably Scheme and Common Lisp) take an alternative approach, and integrate macros into the language in a safe and consistent way. So-called hygienic macros implicitly encapsulate their arguments, avoiding unexpected interactions with as- sociativity and precedence. They rename variables when necessary to avoid the capture problem, and they can be used in any expression context. Unlike subrou- tines, however, they are expanded during semantic analysis, making them gen- erally unsuitable for unbounded recursion. Their appeal is that, like all macros, they take unevaluated arguments, which they evaluate lazily on demand. Among other things, this means that they preserve the multiple side effect “gotcha” of our MAX example. Delayed evaluation was a bug in this context, but can sometimes be a feature. We will return to it in Sections 6.1.5 (short-circuit Boolean eval- uation), 9.3.2 (call-by-name parameters), and 11.5 (normal-order evaluation in functional programming languages).

3CHECK YOUR UNDERSTANDING 34. Describe the difference between deep and shallow binding of referencing en- vironments. 35. Why are binding rules particularly important for languages with dynamic scoping? 36. What are ﬁrst-class subroutines? What languages support them? 37. What is a subroutine closure? What is it used for? How is it implemented?

38. What is an object closure? How is it related to a subroutine closure? 39. Describe how the delegates of C# extend and unify both subroutine and object closures. 40. Explain the distinction between limited and unlimited extent of objects in a local scope. 41. What is a lambda expression? How does the support for lambda expressions in functional languages compare to that of C# or Ruby? To that of C++ or Java?

42. What are macros? What was the motivation for including them in C? What problems may they cause?

