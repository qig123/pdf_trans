# 3.2 Object Lifetime and Storage Management

**118**
Chapter 3* Names, Scopes, and Bindings*

the following section, a compiler will not usually be able to predict the address of
a local variable at compile time, since space for the variable will be allocated dy-
namically on a stack, but it can arrange for the variable to appear at a ﬁxed offset
from the location pointed to by a certain register at run time.
Some languages are difﬁcult to compile because their semantics require funda-
mental decisions to be postponed until run time, generally in order to increase the
ﬂexibility or expressiveness of the language. Most scripting languages, for exam-
ple, delay all type checking until run time. References to objects of arbitrary types
(classes) can be assigned into arbitrary named variables, as long as the program
never ends up applying an operator to (invoking a method of) an object that is
not prepared to handle it. This form of* polymorphism*—applicability to objects or
expressions of multiple types—allows the programmer to write unusually ﬂexi-
ble and general-purpose code. We will mention polymorphism again in several
future sections, including 7.1.2, 7.3, 10.1.1, and 14.4.4.
## 3.2

**Object Lifetime and Storage Management**
In any discussion of names and bindings, it is important to distinguish between
names and the objects to which they refer, and to identify several key events:

Creation and destruction of objects
Creation and destruction of bindings
Deactivation and reactivation of bindings that may be temporarily unusable
References to variables, subroutines, types, and so on, all of which use bindings

```
The period of time between the creation and the destruction of a name-to-
object binding is called the binding’s lifetime. Similarly, the time between the
creation and destruction of an object is the object’s lifetime. These lifetimes need
not necessarily coincide. In particular, an object may retain its value and the po-
tential to be accessed even when a given name can no longer be used to access it.
When a variable is passed to a subroutine by reference, for example (as it typically
is in Fortran or with ‘&’ parameters in C++), the binding between the parame-
ter name and the variable that was passed has a lifetime shorter than that of the
variable itself. It is also possible, though generally a sign of a program bug, for a
name-to-object binding to have a lifetime longer than that of the object. This can
happen, for example, if an object created via the C++ new operator is passed as a
& parameter and then deallocated (delete-ed) before the subroutine returns. A
binding to an object that is no longer live is called a dangling reference. Dangling
references will be discussed further in Sections 3.6 and 8.5.2.
Object lifetimes generally correspond to one of three principal storage alloca-
tion mechanisms, used to manage the object’s space:
```

**1.*** Static* objects are given an absolute address that is retained throughout the
program’s execution.

3.2 Recursion in Fortran
The lack of recursion in (pre-Fortran 90) Fortran is generally attributed to the
expense of stack manipulation on the IBM 704, on which the language was
ﬁrst implemented. Many (perhaps most) Fortran implementations choose to
use a stack for local variables, but because the language deﬁnition permits the
use of static allocation instead, Fortran programmers were denied the beneﬁts
of language-supported recursion for over 30 years.

Miscellaneous
bookkeeping

Return address

Arguments
to called
routines

sp

fp

fp (when subroutine
        C is running) 
Subroutine B

procedure C
      D;  E

procedure B
      if ... then B else C

procedure A
      B

−− main program
      A


![Figure 3.1 Stack-based allocation...](images/page_154_vector_345.png)
*Figure 3.1 Stack-based allocation of space for subroutines. We assume here that subroutines have been called as shown in the upper right. In particular, B has called itself once, recursively, before calling C. If D returns and C calls E, E’s frame (activation record) will occupy the same space previously used for D’s frame. At any given time, the stack pointer (sp) register points to the ﬁrst unused location on the stack (or the last used location on some machines), and the frame pointer (fp) register points to a known location within the frame of the current subroutine. The relative order of ﬁelds within a frame may vary from machine to machine and compiler to compiler.*

```
can do so by adding a predetermined offset to the value in the frame pointer.
As we discuss in Section C 5.3.1, almost every processor provides a displacement
addressing mechanism that allows this addition to be speciﬁed implicitly as part
of an ordinary load or store instruction. The stack grows “downward” toward
lower addresses in most language implementations. Some machines provide spe-
cial push and pop instructions that assume this direction of growth. Local vari-
ables, temporaries, and bookkeeping information typically have negative offsets
from the frame pointer. Arguments and returns typically have positive offsets;
they reside in the caller’s frame.
Even in a language without recursion, it can be advantageous to use a stack for
local variables, rather than allocating them statically. In most programs the pat-
tern of potential calls among subroutines does not permit all of those subroutines
to be active at the same time. As a result, the total space needed for local vari-
ables of currently active subroutines is seldom as large as the total space across all
```

