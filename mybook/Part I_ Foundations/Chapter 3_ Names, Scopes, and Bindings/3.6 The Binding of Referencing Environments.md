# 3.6 The Binding of Referencing Environments

**152**
Chapter 3* Names, Scopes, and Bindings*

## 3.6

**The Binding of Referencing Environments**
We have seen in Section 3.3 how scope rules determine the referencing environ-
ment of a given statement in a program. Static scope rules specify that the refer-
encing environment depends on the lexical nesting of program blocks in which
names are declared. Dynamic scope rules specify that the referencing environ-
ment depends on the order in which declarations are encountered at run time.
An additional issue that we have not yet considered arises in languages that allow
one to create a* reference* to a subroutine—for example, by passing it as a parame-
ter. When should scope rules be applied to such a subroutine: when the reference
is ﬁrst created, or when the routine is ﬁnally called? The answer is particularly im-
portant for languages with dynamic scoping, though we shall see that it matters
even in languages with static scoping.
A dynamic scoping example appears as pseudocode in Figure 3.13. Procedure
**EXAMPLE** 3.30

Deep and shallow binding
print selected records is assumed to be a general-purpose routine that knows
how to traverse the records in a database, regardless of whether they represent
people, sprockets, or salads. It takes as parameters a database, a predicate to make
print/don’t print decisions, and a subroutine that knows how to format the data
in the records of this particular database. We have hypothesized that procedure
print person uses the value of nonlocal variable line length to calculate the num-
ber and width of columns in its output. In a language with dynamic scoping, it is
natural for procedure print selected records to declare and initialize this variable
locally, knowing that code inside print routine will pick it up if needed. For this
coding technique to work, the referencing environment of print routine must not
be created until the routine is actually called by print selected records. This late
binding of the referencing environment of a subroutine that has been passed as a
parameter is known as* shallow binding*. It is usually the default in languages with
dynamic scoping.
For function older than threshold, by contrast, shallow binding may not work
well. If, for example, procedure print selected records happens to have a local
variable named threshold, then the variable set by the main program to inﬂu-
ence the behavior of older than threshold will not be visible when the function
is ﬁnally called, and the predicate will be unlikely to work correctly. In such a
situation, the code that originally passes the function as a parameter has a par-
ticular referencing environment (the current one) in mind; it does not want the
routine to be called in any other environment. It therefore makes sense to bind
the environment at the time the routine is ﬁrst passed as a parameter, and then
restore that environment when the routine is ﬁnally called. That is, we arrange
for older than threshold to see, when it is eventually called, the same referencing
environment it would have seen if it had been called at the point where the refer-
ence was created. This early binding of the referencing environment is known as
*deep binding*. It is almost always the default in languages with static scoping, and
is sometimes available as an option with dynamic scoping as well.
■

procedure print selected records(db : database;
predicate, print routine : procedure)
line length : integer

if device type(stdout) = terminal
line length := 80
else
–– Standard output is a ﬁle or printer.
line length := 132
foreach record r in db
–– Iterating over these may actually be
–– a lot more complicated than a ‘for’ loop.
if predicate(r)
print routine(r)

–– main program
. . .
threshold := 35
print selected records(people, older than threshold, print person)


![Figure 3.13 Program (in...](images/page_186_vector_431.png)
*Figure 3.13 Program (in pseudocode) to illustrate the importance of binding rules. One might argue that deep binding is appropriate for the environment of function older than threshold (for access to threshold), while shallow binding is appropriate for the environment of procedure print person (for access to line length).*

## 3.6.1** Subroutine Closures**

### Deep binding is implemented by creating an explicit representation of a refer-

### encing environment (generally the one in which the subroutine would execute

### if called at the present time) and bundling it together with a reference to the

### subroutine. The bundle as a whole is referred to as a* closure*. Usually the sub-

### routine itself can be represented in the closure by a pointer to its code. In a lan-

### guage with dynamic scoping, the representation of the referencing environment

### depends on whether the language implementation uses an association list or a


![Figure 3.14 Deep binding...](images/page_187_vector_225.png)
*Figure 3.14 Deep binding in Python. At right is a conceptual view of the run-time stack. Referencing environments captured in closures are shown as dashed boxes and arrows. When B is called via formal parameter P, two instances of I exist. Because the closure for P was created in the initial invocation of A, B’s static link (solid arrow) points to the frame of that earlier invocation. B uses that invocation’s instance of I in its print statement, and the output is a 1.*

```
central reference table for run-time lookup of names; we consider these alterna-
tives at the end of Section C 3.4.2.
In early dialects of Lisp, which used dynamic scoping, deep binding was avail-
able via the built-in primitive function, which took a function as its argument
and returned a closure whose referencing environment was the one in which the
function would have executed if called at that moment in time. The closure could
then be passed as a parameter to another function. If and when it was eventually
called, it would execute in the saved environment. (Closures work slightly differ-
ently from “bare” functions in most Lisp dialects: they must be called by passing
them to the built-in primitives funcall or apply.)
At ﬁrst glance, one might be tempted to think that the binding time of refer-
encing environments would not matter in a language with static scoping. After
all, the meaning of a statically scoped name depends on its lexical nesting, not on
the ﬂow of execution, and this nesting is the same whether it is captured at the
time a subroutine is passed as a parameter or at the time the subroutine is called.
The catch is that a running program may have more than one instance of an ob-
ject that is declared within a recursive subroutine. A closure in a language with
static scoping captures the current instance of every object, at the time the closure
is created. When the closure’s subroutine is called, it will ﬁnd these captured in-
stances, even if newer instances have subsequently been created by recursive calls.
One could imagine combining static scoping with shallow binding [VF82], but
the combination does not seem to make much sense, and does not appear to have
been adopted in any language. Figure 3.14 contains a Python program that illus-
EXAMPLE 3.31
```

Binding rules with static
scoping
trates the impact of binding rules in the presence of static scoping. This program
prints a 1. With shallow binding it would print a 2.
■

```
->(i, j){ i > j ? i : j }
# Ruby
```

Each of these expressions evaluates to the larger of two parameters.

