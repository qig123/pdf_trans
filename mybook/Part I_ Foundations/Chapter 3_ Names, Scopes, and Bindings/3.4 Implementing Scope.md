# 3.4 Implementing Scope

We create a binding for n when we enter the main program. We create another when and if we enter procedure second. When we execute the assignment state- ment at line 3, the n to which we are referring will depend on whether we entered ﬁrst through second or directly from the main program. If we entered through second, we will assign the value 1 to second’s local n. If we entered from the main program, we will assign the value 1 to the global n. In either case, the write at line 12 will refer to the global n, since second’s local n will be destroyed, along with its binding, when control returns to the main program. ■ With dynamic scoping, errors associated with the referencing environment EXAMPLE 3.19

Run-time errors with dynamic scoping may not be detected until run time. In Figure 3.10, for example, the declara- tion of local variable max score in procedure foo accidentally redeﬁnes a global variable used by function scaled score, which is then called from foo. Since the global max score is an integer, while the local max score is a ﬂoating-point num- ber, dynamic semantic checks in at least some languages will result in a type clash message at run time. If the local max score had been an integer, no error would have been detected, but the program would almost certainly have produced in- correct results. This sort of error can be very hard to ﬁnd. ■ 3.4 Implementing Scope

To keep track of the names in a statically scoped program, a compiler relies on a data abstraction called a symbol table. In essence, the symbol table is a dictionary: it maps names to the information the compiler knows about them. The most ba- sic operations are to insert a new mapping (a name-to-object binding) or to look up the information that is already present for a given name. Static scope rules add complexity by allowing a given name to correspond to differentobjects—and thus to different information—in different parts of the program. Most variations on static scoping can be handled by augmenting a basic dictionary-style symbol table with enter scope and leave scope operations to keep track of visibility. Nothing is ever deleted from the table; the entire structure is retained throughout compi- lation, and then saved for use by debuggers or run-time reﬂection (type lookup) mechanisms. In a language with dynamic scoping, an interpreter (or the output of a com- piler) must perform operations analogous to symbol table insert and lookup at run time. In principle, any organization used for a symbol table in a compiler could be used to track name-to-object bindings in an interpreter, and vice versa. In practice, implementations of dynamic scoping tend to adopt one of two spe- ciﬁc organizations: an association list or a central reference table.

IN MORE DEPTH

A symbol table with visibility support can be implemented in several different ways. One appealing approach, due to LeBlanc and Cook [CL83], is described on the companion site, along with both association lists and central reference tables.

