# 1.7 Summary and Concluding Remarks

1.7 Summary and Concluding Remarks
**37**

29. On modern machines, do assembly language programmers still tend to write
better code than a good compiler can? Why or why not?

## 1.7

**Summary and Concluding Remarks**
In this chapter we introduced the study of programming language design and
implementation. We considered why there are so many languages, what makes
them successful or unsuccessful, how they may be categorized for study, and what
beneﬁts the reader is likely to gain from that study. We noted that language design
and language implementation are intimately tied to one another. Obviously an
implementation must conform to the rules of the language. At the same time,
a language designer must consider how easy or difﬁcult it will be to implement
various features, and what sort of performance is likely to result.
Language implementations are commonly differentiated into those based on
interpretation and those based on compilation. We noted, however, that the dif-
ference between these approaches is fuzzy, and that most implementations in-
clude a bit of each. As a general rule, we say that a language is compiled if exe-
cution is preceded by a translation step that (1) fully analyzes both the structure
(syntax) and meaning (semantics) of the program, and (2) produces an equiva-
lent program in a signiﬁcantly different form. The bulk of the implementation
material in this book pertains to compilation.
Compilers are generally structured as a series of* phases*. The ﬁrst few phases—
scanning, parsing, and semantic analysis—serve to analyze the source program.
Collectively these phases are known as the compiler’s* front end*. The ﬁnal few
phases—target code generation and machine-speciﬁc code improvement—are
known as the* back end*. They serve to build a target program—preferably a fast
one—whose semantics match those of the source. Between the front end and the
back end, a good compiler performs extensive machine-independent code im-
provement; the phases of this “middle end” typically comprise the bulk of the
code of the compiler, and account for most of its execution time.
Chapters 3, 6, 7, 8, 9, and 10 form the core of the rest of this book. They cover
fundamental issues of language design, both from the point of view of the pro-
grammer and from the point of view of the language implementor. To support
the discussion of implementations, Chapters 2 and 4 describe compiler front ends
in more detail than has been possible in this introduction. Chapter 5 provides an
overview of assembly-level architecture. Chapters 15 through 17 discuss com-
piler back ends, including assemblers and linkers, run-time systems, and code
improvement techniques. Additional language paradigms are covered in Chap-
ters 11 through 14. Appendix A lists the principal programming languages men-
tioned in the text, together with a genealogical chart and bibliographic references.
Appendix B contains a list of “Design & Implementation” sidebars; Appendix C
contains a list of numbered examples.

