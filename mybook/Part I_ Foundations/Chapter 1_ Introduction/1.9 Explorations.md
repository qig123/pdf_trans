# 1.9 Explorations

1.9 Explorations 39

implications of size limits on the portability of programs from one ma- chine/compiler to another? How do the answers to these questions differ for Java? For Ada? For Pascal? For Scheme? (You may need to ﬁnd a man- ual.) 1.8 The Unix make utility allows the programmer to specify dependences among the separately compiled pieces of a program. If ﬁle A depends on ﬁle B and ﬁle B is modiﬁed, make deduces that A must be recompiled, in case any of the changes to B would affect the code produced for A. How accurate is this sort of dependence management? Under what circumstances will it lead to unnecessary work? Under what circumstances will it fail to recompile something that needs to be recompiled? 1.9 Why is it difﬁcult to tell whether a program is correct? How do you go about ﬁnding bugs in your code? What kinds of bugs are revealed by testing? What kinds of bugs are not? (For more formal notions of program correctness, see the bibliographic notes at the end of Chapter 4.) 1.9 Explorations

1.10 (a) What was the ﬁrst programming language you learned? If you chose it, why did you do so? If it was chosen for you by others, why do you think they chose it? What parts of the language did you ﬁnd the most difﬁcult to learn? (b) For the language with which you are most familiar (this may or may not be the ﬁrst one you learned), list three things you wish had been differently designed. Why do you think they were designed the way they were? How would you ﬁx them if you had the chance to do it over? Would there be any negative consequences, for example in terms of compiler complexity or program execution speed? 1.11 Get together with a classmate whose principal programming experience is with a language in a different category of Figure 1.1. (If your experience is mostly in C, for example, you might search out someone with experience in Lisp.) Compare notes. What are the easiest and most difﬁcult aspects of programming, in each of your experiences? Pick a simple problem (e.g., sorting, or identiﬁcation of connected components in a graph) and solve it using each of your favorite languages. Which solution is more elegant (do the two of you agree)? Which is faster? Why? 1.12 (a) If you have access to a Unix system, compile a simple program with the -S command-line ﬂag. Add comments to the resulting assembly language ﬁle to explain the purpose of each instruction. (b) Now use the -o command-line ﬂag to generate a relocatable object ﬁle. Using appropriate local tools (look in particular for nm, objdump, or

