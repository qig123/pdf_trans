# 1.2 The Programming Language Spectrum

1.2 The Programming Language Spectrum
**11**

declarative
functional
Lisp/Scheme, ML, Haskell
dataﬂow
Id, Val
logic, constraint-based
Prolog, spreadsheets, SQL
imperative
von Neumann
C, Ada, Fortran, ...
object-oriented
Smalltalk, Eiffel, Java, ...
scripting
Perl, Python, PHP, ...


![Figure 1.1 Classiﬁcation of...](images/page_44_vector_171.png)
*Figure 1.1 Classiﬁcation of programming languages. Note that the categories are fuzzy, and open to debate. In particular, it is possible for a functional language to be object-oriented, and many authors do not consider functional programming to be declarative. 1.2 The Programming Language Spectrum*

The many existing languages can be classiﬁed into families based on their model
**EXAMPLE** 1.3

Classiﬁcation of
programming languages
of computation. Figure 1.1 shows a common set of families. The top-level di-
vision distinguishes between the* declarative* languages, in which the focus is on
*what* the computer is to do, and the* imperative* languages, in which the focus is
on* how* the computer should do it.
■
Declarative languages are in some sense “higher level”; they are more in tune
with the programmer’s point of view, and less with the implementor’s point of
view. Imperative languages predominate, however, mainly for performance rea-
sons. There is a tension in the design of declarative languages between the desire
to get away from “irrelevant” implementation details and the need to remain close
enough to the details to at least control the outline of an algorithm. The design of
efﬁcient algorithms, after all, is what much of computer science is about. It is not
yet clear to what extent, and in what problem domains, we can expect compilers
to discover good algorithms for problems stated at a very high level of abstrac-
tion. In any domain in which the compiler cannot ﬁnd a good algorithm, the
programmer needs to be able to specify one explicitly.
Within the declarative and imperative families, there are several important
subfamilies:

*Functional* languages employ a computational model based on the recursive
deﬁnition of functions. They take their inspiration from the* lambda calculus*,
a formal computational model developed by Alonzo Church in the 1930s. In
essence, a program is considered a function from inputs to outputs, deﬁned in
terms of simpler functions through a process of reﬁnement. Languages in this
category include Lisp, ML, and Haskell.
*Dataﬂow* languages model computation as the ﬂow of information (*tokens*)
among primitive functional* nodes*. They provide an inherently parallel model:
nodes are triggered by the arrival of input tokens, and can operate concur-
rently. Id and Val are examples of dataﬂow languages. Sisal, a descendant of
Val, is more often described as a functional language.

```
The gcd of a and b is deﬁned to be (1) a when a and b are equal, (2) the gcd of b and
a - b when a > b, and (3) the gcd of a and b - a when b > a. To compute the gcd of
a given pair of numbers, expand and simplify this deﬁnition until it terminates.
```

```
An OCaml version of this algorithm appears in the middle of Figure 1.2. The key-
word let introduces a deﬁnition; rec indicates that it is permitted to be recursive
(self-referential); arguments for a function come between the name (in this case,
gcd) and the equals sign.
■
In a logic language, the programmer speciﬁes a set of axioms and proof rules
EXAMPLE 1.6
```

GCD rules in Prolog
that allows the system to ﬁnd desired values:

```
The proposition gcd(a, b, g) is true if (1) a, b, and g are all equal; (2) a is greater
than b and there exists a number c such that c is a - b and gcd(c, b, g) is true; or
(3) a is less than b and there exists a number c such that c is b - a and gcd(c, a,
g) is true. To compute the gcd of a given pair of numbers, search for a number g (and
various numbers c) for which these rules allow one to prove that gcd(a, b, g) is true.
```

```
A Prolog version of this algorithm appears at the bottom of Figure 1.2. It may be
easier to understand if one reads “if” for :- and “and” for commas.
■
It should be emphasized that the distinctions among language families are not
clear-cut. The division between the von Neumann and object-oriented languages,
for example, is often very fuzzy, and many scripting languages are also object-
oriented. Most of the functional and logic languages include some imperative
features, and several recent imperative languages have added functional features.
The descriptions above are meant to capture the general ﬂavor of the families,
without providing formal deﬁnitions.
Imperative languages—von Neumann and object-oriented—receive the bulk
of the attention in this book. Many issues cut across family lines, however, and
the interested reader will discover much that is applicable to alternative compu-
tational models in most chapters of the book. Chapters 11 through 14 contain
additional material on functional, logic, concurrent, and scripting languages.
```

