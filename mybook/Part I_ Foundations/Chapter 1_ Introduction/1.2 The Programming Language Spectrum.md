# 1.2 The Programming Language Spectrum

![Figure 1.1 Classiﬁcation of...](images/page_44_vector_171.png)
*Figure 1.1 Classiﬁcation of programming languages. Note that the categories are fuzzy, and open to debate. In particular, it is possible for a functional language to be object-oriented, and many authors do not consider functional programming to be declarative. 1.2 The Programming Language Spectrum*

1.2 The Programming Language Spectrum 11

declarative functional Lisp/Scheme, ML, Haskell dataﬂow Id, Val logic, constraint-based Prolog, spreadsheets, SQL imperative von Neumann C, Ada, Fortran, ... object-oriented Smalltalk, Eiffel, Java, ... scripting Perl, Python, PHP, ...

The many existing languages can be classiﬁed into families based on their model EXAMPLE 1.3

Classiﬁcation of programming languages of computation. Figure 1.1 shows a common set of families. The top-level di- vision distinguishes between the declarative languages, in which the focus is on what the computer is to do, and the imperative languages, in which the focus is on how the computer should do it. ■ Declarative languages are in some sense “higher level”; they are more in tune with the programmer’s point of view, and less with the implementor’s point of view. Imperative languages predominate, however, mainly for performance rea- sons. There is a tension in the design of declarative languages between the desire to get away from “irrelevant” implementation details and the need to remain close enough to the details to at least control the outline of an algorithm. The design of efﬁcient algorithms, after all, is what much of computer science is about. It is not yet clear to what extent, and in what problem domains, we can expect compilers to discover good algorithms for problems stated at a very high level of abstrac- tion. In any domain in which the compiler cannot ﬁnd a good algorithm, the programmer needs to be able to specify one explicitly. Within the declarative and imperative families, there are several important subfamilies:

Functional languages employ a computational model based on the recursive deﬁnition of functions. They take their inspiration from the lambda calculus, a formal computational model developed by Alonzo Church in the 1930s. In essence, a program is considered a function from inputs to outputs, deﬁned in terms of simpler functions through a process of reﬁnement. Languages in this category include Lisp, ML, and Haskell. Dataﬂow languages model computation as the ﬂow of information (tokens) among primitive functional nodes. They provide an inherently parallel model: nodes are triggered by the arrival of input tokens, and can operate concur- rently. Id and Val are examples of dataﬂow languages. Sisal, a descendant of Val, is more often described as a functional language.

12 Chapter 1 Introduction

Logic or constraint-based languages take their inspiration from predicate logic. They model computation as an attempt to ﬁnd values that satisfy certain spec- iﬁed relationships, using goal-directed search through a list of logical rules. Prolog is the best-known logic language. The term is also sometimes applied to the SQL database language, the XSLT scripting language, and programmable aspects of spreadsheets such as Excel and its predecessors. The von Neumann languages are probably the most familiar and widely used. They include Fortran, Ada, C, and all of the others in which the basic means of computation is the modiﬁcation of variables.7 Whereas functional languages are based on expressions that have values, von Neumann languages are based on statements (assignments in particular) that inﬂuence subsequent computa- tion via the side effect of changing the value of memory. Object-oriented languages trace their roots to Simula 67. Most are closely related to the von Neumann languages, but have a much more structured and distributed model of both memory and computation. Rather than pic- ture computation as the operation of a monolithic processor on a monolithic memory, object-oriented languages picture it as interactions among semi- independent objects, each of which has both its own internal state and sub- routines to manage that state. Smalltalk is the purest of the object-oriented languages; C++ and Java are probably the most widely used. It is also possi- ble to devise object-oriented functional languages (the best known of these are CLOS [Kee89] and OCaml), but they tend to have a strong imperative ﬂavor. Scripting languages are distinguished by their emphasis on coordinating or “gluing together” components drawn from some surrounding context. Sev- eral scripting languages were originally developed for speciﬁc purposes: csh and bash are the input languages of job control (shell) programs; PHP and JavaScript are primarily intended for the generation of dynamic web content; Lua is widely used to control computer games. Other languages, including Perl, Python, and Ruby, are more deliberately general purpose. Most place an emphasis on rapid prototyping, with a bias toward ease of expression over speed of execution.

One might suspect that concurrent (parallel) languages would form a separate family (and indeed this book devotes a chapter to such languages), but the dis- tinction between concurrent and sequential execution is mostly independent of the classiﬁcations above. Most concurrent programs are currently written using special library packages or compilers in conjunction with a sequential language such as Fortran or C. A few widely used languages, including Java, C#, and Ada, have explicitly concurrent features. Researchers are investigating concurrency in each of the language families mentioned here.

7 John von Neumann (1903–1957) was a mathematician and computer pioneer who helped to develop the concept of stored program computing, which underlies most computer hardware. In a stored program computer, both programs and data are represented as bits in memory, which the processor repeatedly fetches, interprets, and updates.

1.2 The Programming Language Spectrum 13

As a simple example of the contrast among language families, consider the greatest common divisor (GCD) problem introduced at the beginning of this chapter. The choice among, say, von Neumann, functional, or logic program- ming for this problem inﬂuences not only the appearance of the code, but how the programmer thinks. The von Neumann algorithm version of the algorithm is EXAMPLE 1.4

GCD function in C very imperative:

To compute the gcd of a and b, check to see if a and b are equal. If so, print one of them and stop. Otherwise, replace the larger one by their difference and repeat.

C code for this algorithm appears at the top of Figure 1.2. ■ In a functional language, the emphasis is on the mathematical relationship of EXAMPLE 1.5

GCD function in OCaml outputs to inputs:

The gcd of a and b is deﬁned to be (1) a when a and b are equal, (2) the gcd of b and a - b when a > b, and (3) the gcd of a and b - a when b > a. To compute the gcd of a given pair of numbers, expand and simplify this deﬁnition until it terminates.

An OCaml version of this algorithm appears in the middle of Figure 1.2. The key- word let introduces a deﬁnition; rec indicates that it is permitted to be recursive (self-referential); arguments for a function come between the name (in this case, gcd) and the equals sign. ■ In a logic language, the programmer speciﬁes a set of axioms and proof rules EXAMPLE 1.6

GCD rules in Prolog that allows the system to ﬁnd desired values:

The proposition gcd(a, b, g) is true if (1) a, b, and g are all equal; (2) a is greater than b and there exists a number c such that c is a - b and gcd(c, b, g) is true; or (3) a is less than b and there exists a number c such that c is b - a and gcd(c, a, g) is true. To compute the gcd of a given pair of numbers, search for a number g (and various numbers c) for which these rules allow one to prove that gcd(a, b, g) is true.

A Prolog version of this algorithm appears at the bottom of Figure 1.2. It may be easier to understand if one reads “if” for :- and “and” for commas. ■ It should be emphasized that the distinctions among language families are not clear-cut. The division between the von Neumann and object-oriented languages, for example, is often very fuzzy, and many scripting languages are also object- oriented. Most of the functional and logic languages include some imperative features, and several recent imperative languages have added functional features. The descriptions above are meant to capture the general ﬂavor of the families, without providing formal deﬁnitions. Imperative languages—von Neumann and object-oriented—receive the bulk of the attention in this book. Many issues cut across family lines, however, and the interested reader will discover much that is applicable to alternative compu- tational models in most chapters of the book. Chapters 11 through 14 contain additional material on functional, logic, concurrent, and scripting languages.

