# 1.6 An Overview of Compilation

**26**
Chapter 1* Introduction*

15. What is P-code?

16. What is bootstrapping?
17. What is a just-in-time compiler?

18. Name two languages in which a program can write new pieces of itself “on
the ﬂy.”

19. Brieﬂy describe three “unconventional” compilers—compilers whose pur-
pose is not to prepare a high-level program for execution on a general-
purpose processor.
20. List six kinds of tools that commonly support the work of a compiler within
a larger programming environment.
21. Explain how an integrated development environment (IDE) differs from a
collection of command-line tools.

## 1.6

**An Overview of Compilation**
Compilers are among the most well-studied computer programs. We will con-
sider them repeatedly throughout the rest of the book, and in chapters 2, 4, 15,
and 17 in particular. The remainder of this section provides an introductory
overview.
In a typical compiler, compilation proceeds through a series of well-deﬁned
**EXAMPLE** 1.19

Phases of compilation and
interpretation
*phases*, shown in Figure 1.3. Each phase discovers information of use to later
phases, or transforms the program into a form that is more useful to the subse-
quent phase.
The ﬁrst few phases (up through semantic analysis) serve to ﬁgure out the
meaning of the source program. They are sometimes called the* front end* of the
compiler. The last few phases serve to construct an equivalent target program.
They are sometimes called the* back end* of the compiler.
An interpreter (Figure 1.4) shares the compiler’s front-end structure, but
“executes” (interprets) the intermediate form directly, rather than translating
it into machine language. The execution typically takes the form of a set of
mutually recursive subroutines that traverse (“walk”) the syntax tree, “execut-
ing” its nodes in program order. Many compiler and interpreter phases can
be created automatically from a formal description of the source and/or target
languages.
■
One will sometimes hear compilation described as a series of* passes*. A pass
is a phase or set of phases that is serialized with respect to the rest of compila-
tion: it does not start until previous phases have completed, and it ﬁnishes before
any subsequent phases start. If desired, a pass may be written as a separate pro-
gram, reading its input from a ﬁle and writing its output to a ﬁle. Compilers are
commonly divided into passes so that the front end may be shared by compilers

Scanner (lexical analysis)

Parser (syntax analysis)

Semantic analysis and
intermediate code generation

Machine-independent
code improvement (optional)

Target code generation

Machine-specific
code improvement (optional)

Symbol table

Front
end

Back
end


![Figure 1.3 Phases of...](images/page_60_vector_275.png)
*Figure 1.3 Phases of compilation. Phases are listed on the right and the forms in which information is passed between phases are listed on the left. The symbol table serves throughout compilation as a repository for information about identiﬁers.*

Character stream

Token stream

Parse tree

Abstract syntax tree or
other intermediate form

Scanner (lexical analysis)

Program input

Program output

Parser (syntax analysis)

Semantic analysis and
intermediate code generation

Tree-walk routines

Symbol table

Front
end


![Figure 1.4 Phases of...](images/page_60_vector_505.png)
*Figure 1.4 Phases of interpretation. The front end is essentially the same as that of a compiler. The ﬁnal phase “executes” the intermediate form, typically using a set of mutually recursive subroutines that walk the syntax tree.*

for more than one machine (target language), and so that the back end may be
shared by compilers for more than one source language. In some implementa-
tions the front end and the back end may be separated by a “middle end” that
is responsible for language- and machine-independent code improvement. Prior

}
{
*block-item-list_opt*

*block-item-list*

*function-definition*

*translation-unit*

int

int

*declaration-specifiers_opt*

*direct-declarator*

*declarator*

*block-item*

*block-item*

*declaration-specifiers_opt*

*declaration*

*compound-statement*

ident(main)

ident(i)

1

*postfix-expression*
13

### **A**

### **B**

1

)
(
*postfix-expression*

*argument-expression-list_opt*
1
ident(getint)

ident(j)
*postfix-expression*
13

)
(
*postfix-expression*

*argument-expression-list_opt*
1
ident(getint)

