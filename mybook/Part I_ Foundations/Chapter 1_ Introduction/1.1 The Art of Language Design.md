1.1 The Art of Language Design
7
program maintenance—enhancement and correction. Labor costs now heavily
outweigh the cost of computing hardware.
1.1
The Art of Language Design
Today there are thousands of high-level programming languages, and new ones
continue to emerge. Why are there so many? There are several possible answers:
Evolution. Computer science is a young discipline; we’re constantly ﬁnding bet-
ter ways to do things. The late 1960s and early 1970s saw a revolution in
“structured programming,” in which the goto-based control ﬂow of languages
like Fortran, Cobol, and Basic3 gave way to while loops, case (switch)
statements, and similar higher-level constructs. In the late 1980s the nested
block structure of languages like Algol, Pascal, and Ada began to give way to
the object-oriented structure of languages like Smalltalk, C++, Eiffel, and—a
decade later—Java and C#. More recently, scripting languages like Python and
Ruby have begun to displace more traditional compiled languages, at least for
rapid development.
Special Purposes. Some languages were designed for a speciﬁc problem domain.
The various Lisp dialects are good for manipulating symbolic data and com-
plex data structures.
Icon and Awk are good for manipulating character
strings. C is good for low-level systems programming. Prolog is good for rea-
soning about logical relationships among data. Each of these languages can be
used successfully for a wider range of tasks, but the emphasis is clearly on the
specialty.
Personal Preference. Different people like different things. Much of the parochi-
alism of programming is simply a matter of taste. Some people love the terse-
ness of C; some hate it. Some people ﬁnd it natural to think recursively; others
prefer iteration. Some people like to work with pointers; others prefer the im-
plicit dereferencing of Lisp, Java, and ML. The strength and variety of personal
preference make it unlikely that anyone will ever develop a universally accept-
able programming language.
Of course, some languages are more successful than others. Of the many that
have been designed, only a few dozen are widely used. What makes a language
successful? Again there are several answers:
Expressive Power. One commonly hears arguments that one language is more
“powerful” than another, though in a formal mathematical sense they are all
3
The names of these languages are sometimes written entirely in uppercase letters and sometimes
in mixed case. For consistency’s sake, I adopt the convention in this book of using mixed case for
languages whose names are pronounced as words (e.g., Fortran, Cobol, Basic), and uppercase for
those pronounced as a series of letters (e.g., APL, PL/I, ML).
8
Chapter 1 Introduction
Turing complete—each can be used, if awkwardly, to implement arbitrary algo-
rithms. Still, language features clearly have a huge impact on the programmer’s
ability to write clear, concise, and maintainable code, especially for very large
systems. There is no comparison, for example, between early versions of Basic
on the one hand, and C++ on the other. The factors that contribute to ex-
pressive power—abstraction facilities in particular—are a major focus of this
book.
Ease of Use for the Novice. While it is easy to pick on Basic, one cannot deny its
success. Part of that success was due to its very low “learning curve.” Pascal was
taught for many years in introductory programming language courses because,
at least in comparison to other “serious” languages, it was compact and easy
to learn. Shortly after the turn of the century, Java came to play a similar role;
though substantially more complex than Pascal, it is simpler than, say, C++. In
a renewed quest for simplicity, some introductory courses in recent years have
turned to scripting languages like Python.
Ease of Implementation. In addition to its low learning curve, Basic was success-
ful because it could be implemented easily on tiny machines, with limited re-
sources. Forth had a small but dedicated following for similar reasons. Ar-
guably the single most important factor in the success of Pascal was that its de-
signer, Niklaus Wirth, developed a simple, portable implementation of the lan-
guage, and shipped it free to universities all over the world (see Example 1.15).4
The Java and Python designers took similar steps to make their language avail-
able for free to almost anyone who wants it.
Standardization. Almost every widely used language has an ofﬁcial international
standard or (in the case of several scripting languages) a single canonical im-
plementation; and in the latter case the canonical implementation is almost
invariably written in a language that has a standard.
Standardization—of
both the language and a broad set of libraries—is the only truly effective way
to ensure the portability of code across platforms. The relatively impover-
ished standard for Pascal, which was missing several features considered essen-
tial by many programmers (separate compilation, strings, static initialization,
random-access I/O), was at least partially responsible for the language’s drop
from favor in the 1980s. Many of these features were implemented in different
ways by different vendors.
Open Source. Most programming languages today have at least one open-source
compiler or interpreter, but some languages—C in particular—are much
more closely associated than others with freely distributed, peer-reviewed,
community-supported computing. C was originally developed in the early
4
Niklaus Wirth (1934–), Professor Emeritus of Informatics at ETH in Zürich, Switzerland, is
responsible for a long line of inﬂuential languages, including Euler, Algol W, Pascal, Modula,
Modula-2, and Oberon. Among other things, his languages introduced the notions of enumera-
tion, subrange, and set types, and uniﬁed the concepts of records (structs) and variants (unions).
He received the annual ACM Turing Award, computing’s highest honor, in 1984.
1.1 The Art of Language Design
9
1970s by Dennis Ritchie and Ken Thompson at Bell Labs,5 in conjunction
with the design of the original Unix operating system. Over the years Unix
evolved into the world’s most portable operating system—the OS of choice for
academic computer science—and C was closely associated with it. With the
standardization of C, the language became available on an enormous variety
of additional platforms. Linux, the leading open-source operating system, is
written in C. As of June 2015, C and its descendants account for well over half
of a variety of language-related on-line content, including web page references,
book sales, employment listings, and open-source repository updates.
Excellent Compilers. Fortran owes much of its success to extremely good com-
pilers. In part this is a matter of historical accident. Fortran has been around
longer than anything else, and companies have invested huge amounts of time
and money in making compilers that generate very fast code. It is also a matter
of language design, however: Fortran dialects prior to Fortran 90 lacked recur-
sion and pointers, features that greatly complicate the task of generating fast
code (at least for programs that can be written in a reasonable fashion with-
out them!). In a similar vein, some languages (e.g., Common Lisp) have been
successful in part because they have compilers and supporting tools that do an
unusually good job of helping the programmer manage very large projects.
Economics, Patronage, and Inertia. Finally, there are factors other than technical
merit that greatly inﬂuence success. The backing of a powerful sponsor is one.
PL/I, at least to ﬁrst approximation, owed its life to IBM. Cobol and Ada owe
their life to the U. S. Department of Defense. C# owes its life to Microsoft. In
recent years, Objective-C has enjoyed an enormous surge in popularity as the
ofﬁcial language for iPhone and iPad apps. At the other end of the life cycle,
some languages remain widely used long after “better” alternatives are avail-
able, because of a huge base of installed software and programmer expertise,
which would cost too much to replace. Much of the world’s ﬁnancial infras-
tructure, for example, still functions primarily in Cobol.
Clearly no single factor determines whether a language is “good.” As we study
programming languages, we shall need to consider issues from several points of
view. In particular, we shall need to consider the viewpoints of both the pro-
grammer and the language implementor. Sometimes these points of view will be
in harmony, as in the desire for execution speed. Often, however, there will be
conﬂicts and tradeoffs, as the conceptual appeal of a feature is balanced against
the cost of its implementation. The tradeoff becomes particularly thorny when
the implementation imposes costs not only on programs that use the feature, but
also on programs that do not.
5
Ken Thompson (1943–) led the team that developed Unix. He also designed the B programming
language, a child of BCPL and the parent of C. Dennis Ritchie (1941–2011) was the principal
force behind the development of C itself. Thompson and Ritchie together formed the core of an
incredibly productive and inﬂuential group. They shared the ACM Turing Award in 1983.
10
Chapter 1 Introduction
In the early days of computing the implementor’s viewpoint was predominant.
Programming languages evolved as a means of telling a computer what to do. For
programmers, however, a language is more aptly deﬁned as a means of expressing
algorithms. Just as natural languages constrain exposition and discourse, so pro-
gramming languages constrain what can and cannot easily be expressed, and have
both profound and subtle inﬂuence over what the programmer can think. Donald
Knuth has suggested that programming be regarded as the art of telling another
human being what one wants the computer to do [Knu84].6 This deﬁnition per-
haps strikes the best sort of compromise. It acknowledges that both conceptual
clarity and implementation efﬁciency are fundamental concerns. This book at-
tempts to capture this spirit of compromise, by simultaneously considering the
conceptual and implementation aspects of each of the topics it covers.
DESIGN & IMPLEMENTATION
1.1 Introduction
Throughout the book, sidebars like this one will highlight the interplay of
language design and language implementation. Among other things, we will
consider
Cases (such as those mentioned in this section) in which ease or difﬁculty
of implementation signiﬁcantly affected the success of a language
Language features that many designers now believe were mistakes, at least
in part because of implementation difﬁculties
Potentially useful features omitted from some languages because of concern
that they might be too difﬁcult or slow to implement
Language features introduced at least in part to facilitate efﬁcient or elegant
implementations
Cases in which a machine architecture makes reasonable features unreason-
ably expensive
Various other tradeoffs in which implementation plays a signiﬁcant role
A complete list of sidebars appears in Appendix B.
6
Donald E. Knuth (1938–), Professor Emeritus at Stanford University and one of the foremost
ﬁgures in the design and analysis of algorithms, is also widely known as the inventor of the TEX
typesetting system (with which this book was produced) and of the literate programming method-
ology with which TEX was constructed. His multivolume The Art of Computer Programming has
an honored place on the shelf of most professional computer scientists. He received the ACM
Turing Award in 1974.
