# Chapter 1: Introduction

1 Introduction

The ﬁrst electronic computers were monstrous contraptions, ﬁlling several rooms, consuming as much electricity as a good-size factory, and costing millions of 1940s dollars (but with much less computing power than even the sim- plest modern cell phone). The programmers who used these machines believed that the computer’s time was more valuable than theirs. They programmed in machine language. Machine language is the sequence of bits that directly controls a processor, causing it to add, compare, move data from one place to another, and so forth at appropriate times. Specifying programs at this level of detail is an enormously tedious task. The following program calculates the greatest common EXAMPLE 1.1

GCD program in x86 machine language divisor (GCD) of two integers, using Euclid’s algorithm. It is written in machine language, expressed here as hexadecimal (base 16) numbers, for the x86 instruc- tion set.

55 89 e5 53 83 ec 04 83 e4 f0 e8 31 00 00 00 89 c3 e8 2a 00 00 00 39 c3 74 10 8d b6 00 00 00 00 39 c3 7e 13 29 c3 39 c3 75 f6 89 1c 24 e8 6e 00 00 00 8b 5d fc c9 c3 29 d8 eb eb 90 ■

As people began to write larger programs, it quickly became apparent that a less error-prone notation was required. Assembly languages were invented to al- low operations to be expressed with mnemonic abbreviations. Our GCD program EXAMPLE 1.2

GCD program in x86 assembler looks like this in x86 assembly language:

jle D subl %eax, %ebx B: cmpl %eax, %ebx jne A C: movl %ebx, (%esp) call putint movl -4(%ebp), %ebx leave ret D: subl %ebx, %eax jmp B ■

pushl %ebp movl %esp, %ebp pushl %ebx subl $4, %esp andl $-16, %esp call getint movl %eax, %ebx call getint cmpl %eax, %ebx je C A: cmpl %eax, %ebx

Assembly languages were originally designed with a one-to-one correspon- dence between mnemonics and machine language instructions, as shown in this example.1 Translating from mnemonics to machine language became the job of a systems program known as an assembler. Assemblers were eventually aug- mented with elaborate “macro expansion” facilities to permit programmers to deﬁne parameterized abbreviations for common sequences of instructions. The correspondence between assembly language and machine language remained ob- vious and explicit, however. Programming continued to be a machine-centered enterprise: each different kind of computer had to be programmed in its own as- sembly language, and programmers thought in terms of the instructions that the machine would actually execute. As computers evolved, and as competing designs developed, it became increas- ingly frustrating to have to rewrite programs for every new machine. It also be- came increasingly difﬁcult for human beings to keep track of the wealth of de- tail in large assembly language programs. People began to wish for a machine- independent language, particularly one in which numerical computations (the most common type of program in those days) could be expressed in something more closely resembling mathematical formulae. These wishes led in the mid- 1950s to the development of the original dialect of Fortran, the ﬁrst arguably high-level programming language. Other high-level languages soon followed, no- tably Lisp and Algol. Translating from a high-level language to assembly or machine language is the job of a systems program known as a compiler.2 Compilers are substantially more complicated than assemblers because the one-to-one correspondence between source and target operations no longer exists when the source is a high-level language. Fortran was slow to catch on at ﬁrst, because human programmers, with some effort, could almost always write assembly language programs that would run faster than what a compiler could produce. Over time, however, the performance gap has narrowed, and eventually reversed. Increases in hardware complexity (due to pipelining, multiple functional units, etc.) and continuing improvements in compiler technology have led to a situation in which a state- of-the-art compiler will usually generate better code than a human being will. Even in cases in which human beings can do better, increases in computer speed and program size have made it increasingly important to economize on program- mer effort, not only in the original construction of programs, but in subsequent

1 The 22 lines of assembly code in the example are encoded in varying numbers of bytes in ma- chine language. The three cmp (compare) instructions, for example, all happen to have the same register operands, and are encoded in the two-byte sequence (39 c3). The four mov (move) in- structions have different operands and lengths, and begin with 89 or 8b. The chosen syntax is that of the GNU gcc compiler suite, in which results overwrite the last operand, not the ﬁrst.

2 High-level languages may also be interpreted directly, without the translation step. We will return to this option in Section 1.4. It is the principal way in which scripting languages like Python and JavaScript are implemented.

