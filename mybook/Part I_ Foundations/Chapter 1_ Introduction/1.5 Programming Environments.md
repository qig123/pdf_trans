# 1.5 Programming Environments

**24**
Chapter 1* Introduction*

On some machines (particularly those designed before the mid-1980s), the
**EXAMPLE** 1.18

Microcode (ﬁrmware)
assembly-level instruction set is not actually implemented in hardware, but in
fact runs on an interpreter. The interpreter is written in low-level instructions
called* microcode* (or* ﬁrmware*), which is stored in read-only memory and ex-
ecuted by the hardware. Microcode and microprogramming are considered
further in Section C 5.4.1.
■

As some of these examples make clear, a compiler does not necessarily translate
from a high-level programming language into machine language. Some compil-
ers, in fact, accept inputs that we might not immediately think of as programs at
all. Text formatters like TEX, for example, compile high-level document descrip-
tions into commands for a laser printer or phototypesetter. (Many laser printers
themselves contain pre-installed interpreters for the Postscript page-description
language.) Query language processors for database systems translate languages
like SQL into primitive operations on ﬁles. There are even compilers that trans-
late logic-level circuit speciﬁcations into photographic masks for computer chips.
Though the focus in this book is on imperative programming languages, the term
“compilation” applies whenever we translate automatically from one nontrivial
language to another, with full analysis of the meaning of the input.
## 1.5

**Programming Environments**
Compilers and interpreters do not exist in isolation. Programmers are assisted in
their work by a host of other tools. Assemblers, debuggers, preprocessors, and
linkers were mentioned earlier. Editors are familiar to every programmer. They
may be augmented with cross-referencing facilities that allow the programmer to
ﬁnd the point at which an object is deﬁned, given a point at which it is used. Pretty
printers help enforce formatting conventions. Style checkers enforce syntactic or
semantic conventions that may be tighter than those enforced by the compiler
(see Exploration 1.14). Conﬁguration management tools help keep track of de-
pendences among the (many versions of) separately compiled modules in a large
software system. Perusal tools exist not only for text but also for intermediate
languages that may be stored in binary. Proﬁlers and other performance analysis
tools often work in conjunction with debuggers to help identify the pieces of a
program that consume the bulk of its computation time.
In older programming environments, tools may be executed individually, at
the explicit request of the user. If a running program terminates abnormally with
a “bus error” (invalid address) message, for example, the user may choose to in-
voke a debugger to examine the “core” ﬁle dumped by the operating system. He
or she may then attempt to identify the program bug by setting breakpoints, en-
abling tracing and so on, and running the program again under the control of the
debugger. Once the bug is found, the user will invoke the editor to make an ap-
propriate change. He or she will then recompile the modiﬁed program, possibly
with the help of a conﬁguration manager.

**DESIGN & IMPLEMENTATION**

1.4 Powerful development environments
Sophisticated development environments can be a two-edged sword.
The
quality of the Common Lisp environment has arguably contributed to its
widespread acceptance. On the other hand, the particularity of the graphi-
cal environment for Smalltalk (with its insistence on speciﬁc fonts, window
styles, etc.) made it difﬁcult to port the language to systems accessed through
a textual interface, or to graphical systems with a different “look and feel.”

