# 1.10 Bibliographic Notes

**40**
Chapter 1* Introduction*

```
a symbolic debugger like gdb or dbx), identify the machine language
corresponding to each line of assembler.
(c)
Using nm, objdump, or a similar tool, identify the undeﬁned external
symbols in your object ﬁle. Now run the compiler to completion, to
produce an executable ﬁle. Finally, run nm or objdump again to see
what has happened to the symbols in part (b). Where did they come
from—how did the linker resolve them?
(d) Run the compiler to completion one more time, using the -v command-
line ﬂag. You should see messages describing the various subprograms
invoked during the compilation process (some compilers use a dif-
ferent letter for this option; check the man page). The subprograms
may include a preprocessor, separate passes of the compiler itself (of-
ten two), probably an assembler, and the linker. If possible, run these
subprograms yourself, individually. Which of them produce the ﬁles
described in the previous subquestions? Explain the purpose of the
various command-line ﬂags with which the subprograms were invoked.
1.13 Write a program that commits a dynamic semantic error (e.g., division by
zero, access off the end of an array, dereference of a null pointer). What
happens when you run this program? Does the compiler give you options
to control what happens? Devise an experiment to evaluate the cost of run-
time semantic checks. If possible, try this exercise with more than one lan-
guage or compiler.
1.14 C has a reputation for being a relatively “unsafe” high-level language. For
example: it allows the programmer to mix operands of different sizes and
types in many more ways than its “safer” cousins. The Unix lint utility can
be used to search for potentially unsafe constructs in C programs. In effect,
many of the rules that are enforced by the compiler in other languages are
optional in C, and are enforced (if desired) by a separate program. What do
you think of this approach? Is it a good idea? Why or why not?
1.15 Using an Internet search engine or magazine indexing service, read up on
the history of Java and C#, including the conﬂict between Sun and Microsoft
over Java standardization. Some have claimed that C# was, at least in part,
an attempt by Microsoft to undermine the spread of Java. Others point to
philosophical and practical differences between the languages, and argue
that C# more than stands on its merits. In hindsight, how would you char-
acterize Microsoft’s decision to pursue an alternative to Java?
1.10
Bibliographic Notes
```

The compiler-oriented chapters of this book attempt to convey a sense of what
the compiler does, rather than explaining how to build one. A much greater level
of detail can be found in other texts. Leading options include the work of Aho

