# 1.3 Why Study Programming Languages?

**14**
Chapter 1* Introduction*

```
int gcd(int a, int b) {
// C
while (a != b) {
if (a > b) a = a - b;
else b = b - a;
}
return a;
}
```

```
let rec gcd a b =
(* OCaml *)
if a = b then a
else if a > b then gcd b (a - b)
else gcd a (b - a)
```

```
gcd(A,B,G) :- A = B, G = A.
% Prolog
gcd(A,B,G) :- A > B, C is A-B, gcd(C,B,G).
gcd(A,B,G) :- B > A, C is B-A, gcd(C,A,G).
```


![Figure 1.2 The GCD...](images/page_47_vector_256.png)
*Figure 1.2 The GCD algorithm in C (top), OCaml (middle), and Prolog (bottom). All three versions assume (without checking) that their inputs are positive integers. 1.3 Why Study Programming Languages?*

Programming languages are central to computer science, and to the typical com-
puter science curriculum. Like most car owners, students who have become fa-
miliar with one or more high-level languages are generally curious to learn about
other languages, and to know what is going on “under the hood.” Learning about
languages is interesting. It’s also practical.
For one thing, a good understanding of language design and implementation
can help one choose the most appropriate language for any given task. Most lan-
guages are better for some things than for others. Few programmers are likely to
choose Fortran for symbolic computing or string processing, but other choices
are not nearly so clear-cut. Should one choose C, C++, or C# for systems pro-
gramming? Fortran or C for scientiﬁc computations? PHP or Ruby for a web-
based application? Ada or C for embedded systems? Visual Basic or Java for a
graphical user interface? This book should help equip you to make such deci-
sions.
Similarly, this book should make it easier to learn new languages. Many lan-
guages are closely related. Java and C# are easier to learn if you already know
C++; Common Lisp if you already know Scheme; Haskell if you already know
ML. More importantly, there are basic concepts that underlie all programming
languages. Most of these concepts are the subject of chapters in this book: types,
control (iteration, selection, recursion, nondeterminacy, concurrency), abstrac-
tion, and naming. Thinking in terms of these concepts makes it easier to assim-
ilate the syntax (form) and semantics (meaning) of new languages, compared to
picking them up in a vacuum. The situation is analogous to what happens in nat-

8.
What is generally considered the ﬁrst high-level programming language?
9.
What was the ﬁrst functional language?
10. Why aren’t concurrent languages listed as a separate family in Figure 1.1?

