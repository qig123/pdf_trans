# 4.10 Register Allocation

var = (eq? atm1 atm2); ⇒ cmpq arg2, arg1 sete %al movzbq %al, var

The translations for the other comparison operators are similar to this but use different condition codes for the set instruction. Regarding the tail nonterminal, we have two new cases: goto and if statements. Both are straightforward to translate to x86. A goto statement becomes a jump instruction. goto ℓ; ⇒ jmp ℓ

An if statement becomes a compare instruction followed by a conditional jump (for the then branch), and the fall-through is to a regular jump (for the else branch). Again, arg1 and arg2 are the translations of atm1 and atm2, respectively.

if (eq? atm1 atm2) goto ℓ1; else goto ℓ2;

⇒ cmpq arg2, arg1 je ℓ1 jmp ℓ2

Again, the translations for the other comparison operators are similar to this but use different condition codes for the conditional jump instruction.

Exercise 4.6 Expand your select_instructions pass to handle the new features of the CIf language. Add the following entry to the list of passes in run-tests.rkt

(list "select_instructions" select_instructions interp-pseudo-x86-1)

Run the script to test your compiler on all the test programs.

4.10 Register Allocation

The changes required for compiling LIf affect liveness analysis, building the inter- ference graph, and assigning homes, but the graph coloring algorithm itself does not change.

4.10.1 Liveness Analysis Recall that for LVar we implemented liveness analysis for a single basic block (section 3.2). With the addition of if expressions to LIf, explicate_control produces many basic blocks. The first question is, in what order should we process the basic blocks? Recall that to perform liveness analysis on a basic block we need to know the live-after set for the last instruction in the block. If a basic block has no successors (i.e., contains no jumps to other blocks), then it has an empty live-after set and we can immediately apply liveness analysis to it. If a basic block has some successors, then we need to complete liveness analysis on those blocks first. These ordering constraints are the reverse of a topological order on a graph representation of the program. In particular, the control flow graph (CFG) (Allen 1970) of a program has a node for each basic block and an edge for each jump from one block to another. It is straightforward to

generate a CFG from the dictionary of basic blocks. One then transposes the CFG and applies the topological sort algorithm. We recommend using the tsort and transpose functions of the Racket graph package to accomplish this. As an aside, a topological ordering is only guaranteed to exist if the graph does not contain any cycles. This is the case for the control-flow graphs that we generate from LIf programs. However, in chapter 5 we add loops to create LWhile and learn how to handle cycles in the control-flow graph. You need to construct a directed graph to represent the control-flow graph. Do not use the directed-graph of the graph package because that allows at most one edge between each pair of vertices, whereas a control-flow graph may have multiple edges between a pair of vertices. The multigraph.rkt file in the support code implements a graph representation that allows multiple edges between a pair of vertices. The next question is how to analyze jump instructions. Recall that in section 3.2 we maintain an alist named label->live that maps each label to the set of live locations at the beginning of its block. We use label->live to determine the live- before set for each (Jmp label) instruction. Now that we have many basic blocks, label->live needs to be updated as we process the blocks. In particular, after per- forming liveness analysis on a block, we take the live-before set of its first instruction and associate that with the block’s label in the label->live alist. In x86Var If we also have the conditional jump (JmpIf cc label) to deal with. Liveness analysis for this instruction is particularly interesting because during compilation, we do not know which way a conditional jump will go. Thus we do not know whether to use the live-before set for the block associated with the label or the live-before set for the following instruction. So we use both, by taking the union of the live-before sets from the following instruction and from the mapping for label in label->live. The auxiliary functions for computing the variables in an instruction’s argument and for computing the variables read-from (R) or written-to (W) by an instruction need to be updated to handle the new kinds of arguments and instructions in x86Var If .

Exercise 4.7 Update the uncover_live pass to apply liveness analysis to every basic block in the program. Add the following entry to the list of passes in the run-tests.rkt script:

(list "uncover_live" uncover_live interp-pseudo-x86-1)

4.10.2 Build the Interference Graph Many of the new instructions in x86Var If can be handled in the same way as the instructions in x86Var. Some instructions, such as the movzbq instruction, require special care, similar to the movq instruction. Refer to rule number 1 in section 3.3.

Exercise 4.8 Update the build_interference pass for x86Var If . Add the following entries to the list of passes in the run-tests.rkt script:

```
(list "build_interference" build_interference interp-pseudo-x86-1)
(list "allocate_registers" allocate_registers interp-pseudo-x86-1)
```

