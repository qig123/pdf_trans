# 4.5 Shrink the LIf Language

![Figure 4.10...](images/page_80_vector_269.png)
*Figure 4.10*

register. This register cannot be accessed directly, but it can be queried by a num- ber of instructions, including the set instruction. The instruction setcc d puts a 1 or 0 into the destination d, depending on whether the contents of the EFLAGS register matches the condition code cc: e for equal, l for less, le for less-or-equal, g for greater, ge for greater-or-equal. The set instruction has a quirk in that its destination argument must be a single-byte register, such as al (l for lower bits) or ah (h for higher bits), which are part of the rax register. Thankfully, the movzbq instruction can be used to move from a single-byte register to a normal 64-bit reg- ister. The abstract syntax for the set instruction differs from the concrete syntax in that it separates the instruction name from the condition code. The x86 instruction for conditional jump is relevant to the compilation of if expressions. The instruction jcc label updates the program counter to point to the instruction after label, depending on whether the result in the EFLAGS register matches the condition code cc; otherwise, the jump instruction falls through to the next instruction. Like the abstract syntax for set, the abstract syntax for condi- tional jump separates the instruction name from the condition code. For example, (JmpIf 'le 'foo) corresponds to jle foo. Because the conditional jump instruc- tion relies on the EFLAGS register, it is common for it to be immediately preceded by a cmpq instruction to set the EFLAGS register.

4.5 Shrink the LIf Language

The shrink pass translates some of the language features into other features, thereby reducing the kinds of expressions in the language. For example, the short- circuiting nature of the and and or logical operators can be expressed using if as

