# 4.1 The LIf Language

![Figure 4.1...](images/page_72_vector_cluster_221.png)
*Figure 4.1*

later passes. The main event of this chapter is the explicate_control pass that is responsible for translating ifs into conditional gotos (section 4.8). Regarding register allocation, there is the interesting question of how to handle conditional gotos during liveness analysis.

4.1 The LIf Language

Definitions of the concrete syntax and abstract syntax of the LIf language are shown in figures 4.1 and 4.2, respectively. The LIf language includes all of LVar (shown in gray), the Boolean literals #t and #f, and the if expression. We expand the set of operators to include

* the logical operators and, or, and not,
* the eq? operation for comparing integers or Booleans for equality, and
* the <, <=, >, and >= operations for comparing integers.

We reorganize the abstract syntax for the primitive operations given in figure 4.2, using only one grammar rule for all of them. This means that the grammar no longer checks whether the arity of an operator matches the number of arguments. That responsibility is moved to the type checker for LIf (section 4.2). Figure 4.3 shows the definition of the interpreter for LIf, which inherits from the interpreter for LVar (figure 2.4). The constants #t and #f evaluate to the corre- sponding Boolean values, behavior that is inherited from the interpreter for LInt (figure 2.3). The conditional expression (if e1 e2 e3) evaluates expression e1 and then either evaluates e2 or e3, depending on whether e1 produced #t or #f. The logical operations and, or, and not behave according to propositional logic. In addi- tion, the and and or operations perform short-circuit evaluation. That is, given the expression (and e1 e2), the expression e2 is not evaluated if e1 evaluates to #f. Similarly, given (or e1 e2), the expression e2 is not evaluated if e1 evaluates to #t. With the increase in the number of primitive operations, the interpreter would become repetitive without some care. We refactor the case for Prim, moving the code

