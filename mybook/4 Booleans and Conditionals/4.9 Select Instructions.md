# 4.9 Select Instructions

```
start:
tmp1 = (read);
if (eq? tmp1 0) goto block40;
else goto block39;
block40:
tmp2 = (read);
if (eq? tmp2 1) goto block38;
else goto block39;
block38:
return 0;
block39:
return 42;
```

Exercise 4.5 Implement the pass explicate_control by adding the cases for Boolean constants and if to the explicate_tail and explicate_assign func- tions. Implement the auxiliary function explicate_pred for predicate contexts. Create test cases that exercise all the new cases in the code for this pass. Add the following entry to the list of passes in run-tests.rkt:

(list "explicate_control" explicate_control interp-Cif type-check-Cif)

and then run run-tests.rkt to test your compiler.

4.9 Select Instructions

The select_instructions pass translates CIf to x86Var If . Recall that we implement this pass using three auxiliary functions, one for each of the nonterminals atm, stmt, and tail in CIf (figure 4.8). For atm, we have new cases for the Booleans. As previously discussed, we encode them as integers.

#t ⇒ 1 #f ⇒ 0

For translating statements, we discuss some of the cases. The not operation can be implemented in terms of xorq, as we discussed at the beginning of this section. Given an assignment, if the left-hand-side variable is the same as the argument of not, then just the xorq instruction suffices.

var = (not var); ⇒ xorq $1, var

Otherwise, a movq is needed to adapt to the update-in-place semantics of x86. In the following translation, let arg be the result of translating atm to x86.

var = (not atm); ⇒ movq arg, var xorq $1, var

Next consider the cases for equality comparisons. Translating this operation to x86 is slightly involved due to the unusual nature of the cmpq instruction that we discussed in section 4.4. We recommend translating an assignment with an equality on the right-hand side into a sequence of three instructions. Let arg1 be the translation of atm1 to x86 and likewise for arg2.

