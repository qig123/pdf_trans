# 5.4 Uncover get!

temporary variable t2 gets the value of x after the set!, so it is 40. We do not generate a temporary variable for the occurrence of y because it’s an immutable variable. We want to avoid such unnecessary extra temporaries because they would needlessly increase the number of variables, making it more likely for some of them to be spilled. The result of this program is 42, the same as the result prior to remove_complex_operands. The approach that we’ve sketched requires only a small modification to remove_complex_operands to handle get!. However, it requires a new pass, called uncover-get!, that we discuss in section 5.4. As an aside, this problematic interaction between set! and the pass remove_complex_operands is particular to Racket and not its predecessor, the Scheme language. The key difference is that Scheme does not specify an order of evaluation for the arguments of an operator or function call (Sperber et al. 2009). Thus, a compiler for Scheme is free to choose any ordering: both 42 and 80 would be correct results for the example program. Interestingly, Racket is implemented on top of the Chez Scheme compiler (Dybvig 2006) and an approach similar to the one presented in this section (using extra let bindings to control the order of evaluation) is used in the translation from Racket to Scheme (Flatt et al. 2019). Having discussed the complications that arise from adding support for assignment and loops, we turn to discussing the individual compilation passes.

5.4 Uncover get!

The goal of this pass is to mark uses of mutable variables so that remove_complex_operands can treat them as complex expressions and thereby pre- serve their ordering relative to the side effects in other operands. So, the first step is to collect all the mutable variables. We recommend creating an auxiliary function for this, named collect-set!, that recursively traverses expressions, returning the set of all variables that occur on the left-hand side of a set!. Here’s an excerpt of its implementation.

```
(define (collect-set! e)
(match e
[(Var x) (set)]
[(Int n) (set)]
[(Let x rhs body)
(set-union (collect-set! rhs) (collect-set! body))]
[(SetBang var rhs)
(set-union (set var) (collect-set! rhs))]
...))
```

By placing this pass after uniquify, we need not worry about variable shadowing, and our logic for Let can remain simple, as in this excerpt. The second step is to mark the occurrences of the mutable variables with the new GetBang AST node (get! in concrete syntax). The following is an excerpt of the uncover-get!-exp function, which takes two parameters: the set of mutable

