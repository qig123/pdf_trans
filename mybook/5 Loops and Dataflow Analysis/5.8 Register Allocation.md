# 5.8 Register Allocation

includes the generated code for the input expression followed by the continua- tion. If the expression is obviously pure, that is, never causes side effects, then the expression can be removed, so the result is just the continuation. The case for (WhileLoop cnd body) expressions is interesting; the generated code is depicted in the following diagram:

else

goto loop / loop: cnd′

cont

then

body′ goto loop

We start by creating a fresh label loop for the top of the loop. Next, recursively process the body (in effect position) with a goto to loop as the continuation, pro- ducing body′. Process the cnd (in predicate position) with body′ as the then branch and the continuation block as the else branch. The result should be added to the dictionary of basic-blocks with the label loop. The result for the whole while loop is a goto to the loop label. The auxiliary functions for tail, assignment, and predicate positions need to be updated. The three new language forms, while, set!, and begin, can appear in assignment and tail positions. Only begin may appear in predicate positions; the other two have result type Void.

5.7 Select Instructions

Only two small additions are needed in the select_instructions pass to handle the changes to C⟲. First, to handle the addition of (Void) we simply translate it to 0. Second, read may appear as a stand-alone statement instead of appearing only on the right-hand side of an assignment statement. The code generation is nearly identical to the one for assignment; just leave off the instruction for moving the result into the left-hand side.

5.8 Register Allocation

As discussed in section 5.2, the presence of loops in LWhile means that the control- flow graphs may contain cycles, which complicates the liveness analysis needed for register allocation. We recommend using the generic analyze_dataflow function that was presented at the end of section 5.2 to perform liveness analysis, replacing the code in uncover_live that processed the basic blocks in topological order (section 4.10.1). The analyze_dataflow function has the following four parameters.

* The first parameter G should be passed the transpose of the control-flow graph.

![Figure 5.8...](images/page_109_vector_301.png)
*Figure 5.8*

* The second parameter transfer should be passed a function that applies liveness
  analysis to a basic block. It takes two parameters: the label for the block to
  analyze and the live-after set for that block. The transfer function should return
  the live-before set for the block. Also, as a side effect, it should update the
  block’s info with the liveness information for each instruction.
  To implement
  the transfer function, you should be able to reuse the code you already have
  for analyzing basic blocks.
* The third and fourth parameters of analyze_dataflow are bottom and join
  for the lattice of abstract states, that is, sets of locations. For liveness analysis,
  the bottom of the lattice is the empty set, and the join operator is set union.

![Figure 5.8...](images/page_109_vector_477.png)
*Figure 5.8*

