# 11.3 Erase Generic Types

generic functions is performed in two passes, resolve and erase_types, that we discuss next. The output of erase_types is LCast (section 10.3), so the rest of the compilation is handled by the compiler of chapter 10.

11.2 Resolve Instantiation

Recall that the type checker for LGen deduces the type arguments at call sites to a generic function. The purpose of the resolve pass is to turn this implicit instanti- ation into an explicit one, by adding inst nodes to the syntax of the intermediate language. An inst node records the mapping of type parameters to type arguments. The semantics of the inst node is to instantiate the result of its first argument, a generic function, to produce a monomorphic function. However, because the inter- preter never analyzes type annotations, instantiation can be a no-op and simply return the generic function. The output language of the resolve pass is LInst, for which the definition is shown in figure 11.8. The resolve pass combines the type declaration and polymorphic function into a single definition, using the Poly form, to make polymorphic functions more convenient to process in the next pass of the compiler. The output of the resolve pass on the generic map example is listed in figure 11.9. Note that the use of map is wrapped in an inst node, with the parameter T chosen to be Integer.

11.3 Erase Generic Types

We use the Any type presented in chapter 9 to represent type variables. For exam- ple, figure 11.10 shows the output of the erase_types pass on the generic map (figure 11.1). The occurrences of type parameter T are replaced by Any, and the generic All types are removed from the type of map. This process of type erasure creates a challenge at points of instantiation. For example, consider the instantiation of map shown in figure 11.9. The type of map is

(All (T) ((T -> T) (Vector T T) -> (Vector T T)))

and it is instantiated to

```
((Integer -> Integer) (Vector Integer Integer)
-> (Vector Integer Integer))
```

After erasure, the type of map is

((Any -> Any) (Vector Any Any) -> (Vector Any Any))

but we need to convert it to the instantiated type. This is easy to do in the language LCast with a single cast. In the example shown in figure 11.10, the instantiation of map has been compiled to a cast from the type of map to the instantiated type. The source and the target type of a cast must be consistent (figure 10.4), which indeed is the case because both the source and target are obtained from the same generic type of map, replacing the type parameters with Any in the former and with

![Figure 11.8...](images/page_222_vector_388.png)
*Figure 11.8*

![Figure 11.9...](images/page_222_vector_552.png)
*Figure 11.9*

the deduced type arguments in the latter. (Recall that the Any type is consistent with any type.) To implement the erase_types pass, we first recommend defining a recursive function that translates types, named erase_type. It replaces type variables with Any as follows.

![Figure 11.10...](images/page_223_vector_236.png)
*Figure 11.10*

where Tt = (erase_type (substitute_type s T)), and s = (map cons xs ts). Finally, each generic function is translated to a regular function in which type erasure has been applied to all the type annotations and the body.

Exercise 11.1 Implement a compiler for the polymorphic language LGen by extend- ing and adapting your compiler for L?. Create six new test programs that use polymorphic functions. Some of them should make use of first-class generics.

![Figure 11.11...](images/page_223_vector_608.png)
*Figure 11.11*

![Figure 11.11...](images/page_224_vector_390.png)
*Figure 11.11*

