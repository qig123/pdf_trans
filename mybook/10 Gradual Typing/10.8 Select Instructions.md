# 10.8 Select Instructions 

10.7 Closure Conversion

The auxiliary function that translates type annotations needs to be updated to handle the PVector type. Otherwise, the only other changes are adding cases that copy the new AST nodes.

10.8 Select Instructions

Recall that the select_instructions pass is responsible for lowering the primitive operations into x86 instructions. So, we need to translate the new operations on PVector to x86. To do so, the first question we need to answer is how to differentiate between tuple and tuple proxies. We need just one bit to accomplish this; we use the bit in position 63 of the 64-bit tag at the front of every tuple (see figure 6.8). So far, this bit has been set to 0, so for inject-vector we leave it that way.

(Assign lhs (Prim 'inject-vector (list e1))) ⇒ movq e′ 1, lhs′

On the other hand, inject-proxy sets bit 63 to 1.

(Assign lhs (Prim 'inject-proxy (list e1))) ⇒ movq e′ 1, %r11 movq (1 << 63), %rax orq 0(%r11), %rax movq %rax, 0(%r11) movq %r11, lhs′

The proxy? operation consumes the information so carefully stashed away by the injections. It isolates bit 63 to tell whether the value is a proxy.

(Assign lhs (Prim 'proxy? (list e1))) ⇒ movq e′ 1, %r11 movq 0(%r11), %rax sarq $63, %rax andq $1, %rax movq %rax, lhs′

The project-vector operation is straightforward to translate, so we leave that to the reader. Regarding the element access operations for tuples, the runtime provides proce- dures that implement them (they are recursive functions!), so here we simply need to translate these tuple operations into the appropriate function call. For example, here is the translation for proxy-vector-ref.

