# 10.9 Further Reading

(Assign lhs (Prim 'proxy-vector-ref (list e1 e2))) ⇒ movq e′ 1, %rdi movq e′ 2, %rsi callq proxy_vector_ref movq %rax, lhs′

![Figure 10.18 provides an...](images/page_210_vector_542.png)
*Figure 10.18 provides an overview of the passes needed for the compilation of L?.*

10.9 Further Reading

This chapter just scratches the surface of gradual typing. The basic approach described here is missing two key ingredients that one would want in an imple- mentation of gradual typing: blame tracking (Tobin-Hochstadt and Felleisen 2006;

![Figure 10.18 Diagram of...](images/page_211_vector_390.png)
*Figure 10.18 Diagram of the passes for L? (gradual typing).*

Wadler and Findler 2009) and space-efficient casts (Herman, Tomb, and Flana- gan 2007, 2010). The problem addressed by blame tracking is that when a cast on a higher-order value fails, it often does so at a point in the program that is far removed from the original cast. Blame tracking is a technique for propagating extra information through casts and proxies so that when a cast fails, the error message can point back to the original location of the cast in the source program. The problem addressed by space-efficient casts also relates to higher-order casts. It turns out that in partially typed programs, a function or tuple can flow through a great many casts at runtime. With the approach described in this chapter, each cast adds another lambda wrapper or a tuple proxy. Not only does this take up considerable space, but it also makes the function calls and tuple operations slow. For example, a partially typed version of quicksort could, in the worst case, build a chain of proxies of length O(n) around the tuple, changing the overall time com- plexity of the algorithm from O(n2) to O(n3)! Herman, Tomb, and Flanagan (2007) suggested a solution to this problem by representing casts using the coercion cal- culus of Henglein (1994), which prevents the creation of long chains of proxies by compressing them into a concise normal form. Siek, Thiemann, and Wadler (2015)

give an algorithm for compressing coercions, and Kuhlenschmidt, Almahallawi, and Siek (2019) show how to implement these ideas in the Grift compiler:

https://github.com/Gradual-Typing/Grift

There are also interesting interactions between gradual typing and other language features, such as generics, information-flow types, and type inference, to name a few. We recommend to the reader the online gradual typing bibliography for more material:

http://samth.github.io/gradual-typing-bib/

