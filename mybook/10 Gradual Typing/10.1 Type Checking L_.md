# 10.1 Type Checking L?

10

Gradual Typing

This chapter studies the language L?, in which the programmer can choose between static and dynamic type checking in different parts of a program, thereby mix- ing the statically typed Lλ language with the dynamically typed LDyn. There are several approaches to mixing static and dynamic typing, including multilanguage integration (Tobin-Hochstadt and Felleisen 2006; Matthews and Findler 2007) and hybrid type checking (Flanagan 2006; Gronski et al. 2006). In this chapter we focus on gradual typing, in which the programmer controls the amount of static ver- sus dynamic checking by adding or removing type annotations on parameters and variables (Anderson and Drossopoulou 2003; Siek and Taha 2006). The definition of the concrete syntax of L? is shown in figure 10.1, and the definition of its abstract syntax is shown in figure 10.2. The main syntactic difference between Lλ and L? is that type annotations are optional, which is specified in the grammar using the prm and ret nonterminals. In the abstract syntax, type annotations are not optional, but we use the Any type when a type annotation is absent. Both the type checker and the interpreter for L? require some interesting changes to enable gradual typing, which we discuss in the next two sections.

10.1 Type Checking L?

We begin by discussing the type checking of a partially typed variant of the map example from chapter 7, shown in figure 10.3. The map function itself is statically typed, so there is nothing special happening there with respect to type checking. On the other hand, the inc function does not have type annotations, so the type checker assigns the type Any to parameter x and the return type. Now consider the + operator inside inc. It expects both arguments to have type Integer, but its first argument x has type Any. In a gradually typed language, such differences are allowed so long as the types are consistent; that is, they are equal except in places where there is an Any type. That is, the type Any is consistent with every other type. Figure 10.4 shows the definition of the consistent? method. So the type checker allows the + operator to be applied to x because Any is consistent with Integer. Next consider the call to the map function shown in figure 10.3 with the arguments inc and a tuple. The inc function has type (Any -> Any), but parameter f of map has type (Integer -> Integer). The type checker for L? accepts this call because the two types are consistent.

![Figure 10.1...](images/page_194_vector_cluster_328.png)
*Figure 10.1*

It is also helpful to consider how gradual typing handles programs with an error, such as applying map to a function that sometimes returns a Boolean, as shown in figure 10.5. The type checker for L? accepts this program because the type of maybe_inc is consistent with the type of parameter f of map; that is, (Any -> Any) is consistent with (Integer -> Integer). One might say that a gradual type checker is optimistic in that it accepts programs that might execute without a runtime type error. The definition of the type checker for L? is shown in figures 10.7, 10.8, and 10.9. Running this program with input 1 triggers an error when the maybe_inc function returns #t. The L? language performs checking at runtime to ensure the integrity of the static types, such as the (Integer -> Integer) annotation on parameter f of map. Here we give a preview of how the runtime checking is accomplished; the following sections provide the details. The runtime checking is carried out by a new Cast AST node that is generated in a new pass named cast_insert. The output of cast_insert is a program in the LCast language, which simply adds Cast and Any to Lλ. Figure 10.6 shows the output of cast_insert for map and maybe_inc. The idea is that Cast is inserted every time the type checker encounters two types that are consistent but not equal. In the inc function, x is cast to Integer and the result of the + is cast to Any. In the call to map, the inc argument is cast from (Any -> Any) to (Integer -> Integer). In the next section we see how to interpret the Cast node.

