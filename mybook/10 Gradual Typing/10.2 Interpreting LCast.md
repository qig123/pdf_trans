# 10.2 Interpreting LCast 

![Figure 10.2 The abstract...](images/page_195_vector_344.png)
*Figure 10.2 The abstract syntax of L?, extending LTup (figure 6.2).*

![Figure 10.3 A partially...](images/page_195_vector_509.png)
*Figure 10.3 A partially typed version of the map example.*

10.2 Interpreting LCast

The runtime behavior of casts involving simple types such as Integer and Boolean is straightforward. For example, a cast from Integer to Any can be accomplished with the Inject operator of LAny, which puts the integer into a tagged value (figure 9.8). Similarly, a cast from Any to Integer is accomplished with the Project operator, by checking the value’s tag and either retrieving the underlying integer

![Figure 10.4 The consistency...](images/page_196_vector_253.png)
*Figure 10.4 The consistency method on types.*

![Figure 10.5 A variant...](images/page_196_vector_423.png)
*Figure 10.5 A variant of the map example with an error.*

![Figure 10.6 Output of...](images/page_196_vector_614.png)
*Figure 10.6 Output of the cast_insert pass for the map and maybe_inc example.*

![Figure 10.7 Type checker...](images/page_197_vector_542.png)
*Figure 10.7 Type checker for the L? language, part 1.*

or signaling an error if the tag is not the one for integers (figure 9.9). Things get more interesting with casts involving function and tuple types. Consider the cast of the function maybe_inc from (Any -> Any) to (Integer -> Integer) shown in figure 10.5. When the maybe_inc function flows through this cast at runtime, we don’t know whether it will return an integer, because that

![Figure 10.8 Type checker...](images/page_198_vector_608.png)
*Figure 10.8 Type checker for the L? language, part 2.*

![Figure 10.9 Type checker...](images/page_199_vector_445.png)
*Figure 10.9 Type checker for the L? language, part 3.*

depends on the input from the user. The LCast interpreter therefore delays the checking of the cast until the function is applied. To do so it wraps maybe_inc in a new function that casts its parameter from Integer to Any, applies maybe_inc, and then casts the return value from Any to Integer. Consider the example presented in figure 10.11 that defines a partially typed version of map whose parameter v has type (Vector Any Any) and that updates v in place instead of returning a new tuple. We name this function map_inplace. We apply map_inplace to a tuple of integers, so the type checker inserts a cast from (Vector Integer Integer) to (Vector Any Any). A naive way for the LCast interpreter to cast between tuple types would be to build a new tuple whose elements are the result of casting each of the original elements to the target type. However, this approach is not valid for mutable data structures. In the example of figure 10.11,

```
(define/public (join t1 t2)
(match* (t1 t2)
[('Integer 'Integer) 'Integer]
[('Boolean 'Boolean) 'Boolean]
[('Void 'Void) 'Void]
[('Any t2) t2]
[(t1 'Any) t1]
[(`(Vector ,ts1 ...) `(Vector ,ts2 ...))
`(Vector ,@(for/list ([t1 ts1] [t2 ts2]) (join t1 t2)))]
[(`(,ts1 ... -> ,rt1) `(,ts2 ... -> ,rt2))
`(,@(for/list ([t1 ts1] [t2 ts2]) (join t1 t2))
-> ,(join rt1 rt2))]))
```

![Figure 10.10 Auxiliary functions...](images/page_200_vector_642.png)
*Figure 10.10 Auxiliary functions for type checking L?.*

![Figure 10.11 An example...](images/page_201_vector_225.png)
*Figure 10.11 An example involving casts on arrays.*

![Figure 10.12 Casting a...](images/page_201_vector_400.png)
*Figure 10.12 Casting a tuple to Any.*

if the cast created a new tuple, then the updates inside map_inplace would happen to the new tuple and not the original one. Instead the interpreter needs to create a new kind of value, a proxy, that inter- cepts every tuple operation. On a read, the proxy reads from the underlying tuple and then applies a cast to the resulting value. On a write, the proxy casts the argument value and then performs the write to the underlying tuple. For the first (vector-ref v 0) in map_inplace, the proxy casts 0 from Integer to Any. For the first vector-set!, the proxy casts a tagged 1 from Any to Integer. Finally we consider casts between the Any type and higher-order types such as functions and tuples. Figure 10.12 shows a variant of map_inplace in which param- eter v does not have a type annotation, so it is given type Any. In the call to map_inplace, the tuple has type (Vector Integer Integer), so the type checker inserts a cast to Any. A first thought is to use Inject, but that doesn’t work because (Vector Integer Integer) is not a flat type. Instead, we must first cast to (Vector Any Any), which is flat, and then inject to Any.

![Figure 10.13 The apply_cast...](images/page_202_vector_513.png)
*Figure 10.13 The apply_cast auxiliary method.*

The LCast interpreter uses an auxiliary function named apply_cast to cast a value from a source type to a target type, shown in figure 10.13. You’ll find that it handles all the kinds of casts that we’ve discussed in this section. The definition of the interpreter for LCast is shown in figure 10.14, with the case for Cast dispatch- ing to apply_cast. To handle the addition of tuple proxies, we update the tuple primitives in interp-op using the functions given in figure 10.15. Next we turn to the individual passes needed for compiling L?.

