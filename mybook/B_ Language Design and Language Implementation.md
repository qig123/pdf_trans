# B: Language Design and Language Implementation

## **B**

## **Language Design and Language**

## **Implementation**

Throughout this text, we have had occasion to remark on the many connections
between language design and language implementation. Some of the more direct
connections have been highlighted in separate sidebars. We list those sidebars
here.

**Chapter 1: Introduction**

1.1
Introduction
10
1.2
Compiled and interpreted languages
18
1.3
The early success of Pascal
22
1.4
Powerful development environments
25

**Chapter 2: Programming Language Syntax**

```
2.1
Contextual keywords
46
2.2
Formatting restrictions
48
2.3
Nested comments
55
2.4
Recognizing multiple kinds of token
63
2.5
Longest possible tokens
64
2.6
The dangling else
81
2.7
Recursive descent and table-driven LL parsing
86
```

**Chapter 3: Names, Scopes, and Bindings**

3.1
Binding time
117
3.2
Recursion in Fortran
119
3.3
Mutual recursion
131
3.4
Redeclarations
134
3.5
Modules and separate compilation
140
3.6
Dynamic scoping
143
3.7
Pointers in C and Fortran
146
3.8
User-deﬁned operators in OCaml
149
3.9
Binding rules and extent
156
3.10
Functions and function objects
161

**Chapter 7: Type Systems**

7.1
Systems programming
299
7.2
Dynamic typing
300
7.3
Multilingual character sets
306
7.4
Decimal types
307
7.5
Multiple sizes of integers
309
7.6
Nonconverting casts
319
7.7
Type classes for overloaded functions in Haskell
329
7.8
Uniﬁcation
331
7.9
Generics in ML
334
7.10
Overloading and polymorphism
336
7.11
Why erasure?
C*·*127

**Chapter 8: Composite Types**

```
8.1
Struct tags and typedef in C and C++
353
8.2
The order of record ﬁelds
356
```

