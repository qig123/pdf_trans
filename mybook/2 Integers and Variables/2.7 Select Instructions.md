# 2.7 Select Instructions

* If (Let x e1 e2) is in tail position, then so is e2.

We recommend implementing explicate_control using two recursive functions, explicate_tail and explicate_assign, as suggested in the skeleton code shown in figure 2.16. The explicate_tail function should be applied to expressions in tail position, whereas the explicate_assign should be applied to expressions that occur on the right-hand side of a let. The explicate_tail function takes an exp in Lmon Var as input and produces a tail in CVar (see figure 2.13). The explicate_assign function takes an exp in Lmon Var , the variable to which it is to be assigned, and a tail in CVar for the code that comes after the assignment. The explicate_assign function returns a tail in CVar. The explicate_assign function is in accumulator-passing style: the cont param- eter is used for accumulating the output. This accumulator-passing style plays an important role in the way that we generate high-quality code for conditional expres- sions in chapter 4. The abbreviation cont is for continuation because it contains the generated code that should come after the current assignment. This code orga- nization is also related to continuation-passing style, except that cont is not what happens next during compilation but is what happens next in the generated code.

Exercise 2.4 Implement the explicate_control function in compiler.rkt. Create three new LVar programs that exercise the code in explicate_control. In the run-tests.rkt script, add the following entry to the list of passes and then run the script to test your compiler.

(list "explicate control" explicate_control interp_Cvar type-check-Cvar)

2.7 Select Instructions

In the select_instructions pass we begin the work of translating from CVar to x86Var. The target language of this pass, x86Var, is a variant of x86 that still uses variables, so we add an AST node of the form (Var var) to the arg non- terminal of the x86Int abstract syntax (figure 2.10). We recommend implementing the select_instructions with three auxiliary functions, one for each of the nonterminals of CVar: atm, stmt, and tail. The cases for atm are straightforward; variables stay the same and integer constants change to immediates; that is, (Int n) changes to (Imm n). Next consider the cases for the stmt nonterminal, starting with arithmetic opera- tions. For example, consider the following addition operation, on the left side. (Let arg1 and arg2 be the translations of atm1 and atm2, respectively.) There is an addq instruction in x86, but it performs an in-place update. So, we could move arg1 into the rax register, then add arg2 to rax, and then finally move rax into var.

var = (+ atm1 atm2); â‡’ movq arg1, %rax addq arg2, %rax movq %rax, var

