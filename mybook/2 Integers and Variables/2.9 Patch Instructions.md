# 2.9 Patch Instructions

programs must necessarily resort to placing some variables on the stack. In this chapter we focus on the mechanics of placing variables on the stack. We study an algorithm for placing variables in registers in chapter 3. Consider again the following LVar program from section 2.5:

```
(let ([a 42])
(let ([b a])
b))
```

The output of select_instructions is shown next, on the left, and the output of assign_homes is on the right. In this example, we assign variable a to stack location -8(%rbp) and variable b to location -16(%rbp).

â‡’ movq $42, -8(%rbp) movq -8(%rbp), -16(%rbp) movq -16(%rbp), %rax

```
movq $42, a
movq a, b
movq b, %rax
```

The assign_homes pass should replace all variables with stack locations. The list of variables can be obtained from the locals-types entry in the info of the X86Program node. The locals-types entry is an alist mapping all the variables in the program to their types (for now, just Integer). As an aside, the locals-types entry is computed by type-check-Cvar in the support code, which installs it in the info field of the CProgram node, which you should propagate to the X86Program node. In the process of assigning variables to stack locations, it is convenient for you to compute and store the size of the frame (in bytes) in the info field of the X86Program node, with the key stack-space, which is needed later to generate the conclusion of the main procedure. The x86-64 standard requires the frame size to be a multiple of 16 bytes.

Exercise 2.6 Implement the assign_homes pass in compiler.rkt, defining auxil- iary functions for each of the nonterminals in the x86Var grammar. We recommend that the auxiliary functions take an extra parameter that maps variable names to homes (stack locations for now). In the run-tests.rkt script, add the following entry to the list of passes and then run the script to test your compiler.

(list "assign homes" assign-homes interp_x86-0)

2.9 Patch Instructions

The patch_instructions pass compiles from x86Var to x86Int by making sure that each instruction adheres to the restriction that at most one argument of an instruction may be a memory reference. We return to the following example.

```
(let ([a 42])
(let ([b a])
b))
```

The assign_homes pass produces the following translation.

