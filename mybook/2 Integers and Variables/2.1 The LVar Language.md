# 2.1 The LVar Language

2

Integers and Variables

This chapter covers compiling a subset of Racket to x86-64 assembly code (Intel 2015). The subset, named LVar, includes integer arithmetic and local variables. We often refer to x86-64 simply as x86. The chapter first describes the LVar language (section 2.1) and then introduces x86 assembly (section 2.2). Because x86 assembly language is large, we discuss only the instructions needed for compiling LVar. We introduce more x86 instructions in subsequent chapters. After introducing LVar and x86, we reflect on their differences and create a plan to break down the translation from LVar to x86 into a handful of steps (section 2.3). The rest of the chapter gives detailed hints regarding each step. We aim to give enough hints that the well- prepared reader, together with a few friends, can implement a compiler from LVar to x86 in a short time. To suggest the scale of this first compiler, we note that the instructor solution for the LVar compiler is approximately 500 lines of code.

2.1 The LVar Language

The LVar language extends the LInt language with variables. The concrete syntax of the LVar language is defined by the grammar presented in figure 2.1, and the abstract syntax is presented in figure 2.2. The nonterminal var may be any Racket identifier. As in LInt, read is a nullary operator, - is a unary operator, and + is a binary operator. Similarly to LInt, the abstract syntax of LVar includes the Program struct to mark the top of the program. Despite the simplicity of the LVar language, it is rich enough to exhibit several compilation techniques. Let us dive further into the syntax and semantics of the LVar language. The let feature defines a variable for use within its body and initializes the variable with the value of an expression. The abstract syntax for let is shown in figure 2.2. The concrete syntax for let is

(let ([var exp]) exp)

For example, the following program initializes x to 32 and then evaluates the body (+ 10 x), producing 42.

(let ([x (+ 12 20)]) (+ 10 x))

When there are multiple lets for the same variable, the closest enclosing let is used. That is, variable definitions overshadow prior definitions. Consider the

![Figure 2.1 The concrete...](images/page_28_vector_156.png)
*Figure 2.1 The concrete syntax of LVar.*

![Figure 2.2 The abstract...](images/page_28_vector_292.png)
*Figure 2.2 The abstract syntax of LVar.*

following program with two lets that define two variables named x. Can you figure out the result?

(let ([x 32]) (+ (let ([x 10]) x) x))

For the purposes of depicting which variable occurrences correspond to which defi- nitions, the following shows the x’s annotated with subscripts to distinguish them. Double-check that your answer for the previous program is the same as your answer for this annotated version of the program.

(let ([x1 32]) (+ (let ([x2 10]) x2) x1))

The initializing expression is always evaluated before the body of the let, so in the following, the read for x is performed before the read for y. Given the input 52 then 10, the following produces 42 (not −42).

(let ([x (read)]) (let ([y (read)]) (+ x (- y))))

2.1.1 Extensible Interpreters via Method Overriding To prepare for discussing the interpreter of LVar, we explain why we implement it in an object-oriented style. Throughout this book we define many interpreters, one for each language that we study. Because each language builds on the prior one, there is a lot of commonality between these interpreters. We want to write down the common parts just once instead of many times. A naive interpreter for LVar would handle the cases for variables and let but dispatch to an interpreter for LInt in the rest of the cases. The following code sketches this idea. (We explain the env parameter in section 2.1.2.)

```
(define ((interp_Lvar env) e)
(match e
[(Var x)
(dict-ref env x)]
[(Let x e body)
(define v ((interp_Lvar env) e))
(define env^ (dict-set env x v))
((interp_Lvar env^) body)]
[else ((interp_Lint env) e)]))
```

```
(define ((interp_Lint env) e)
(match e
[(Prim '- (list e1))
(fx- 0 ((interp_Lint env) e1))]
...))
```

The problem with this naive approach is that it does not handle situations in which an LVar feature, such as a variable, is nested inside an LInt feature, such as the - operator, as in the following program.

(Let 'y (Int 10) (Prim '- (list (Var 'y))))

If we invoke interp_Lvar on this program, it dispatches to interp_Lint to handle the - operator, but then it recursively calls interp_Lint again on its argument. Because there is no case for Var in interp_Lint, we get an error! To make our interpreters extensible we need something called open recursion, in which the tying of the recursive knot is delayed until the functions are composed. Object-oriented languages provide open recursion via method overriding. The fol- lowing code uses method overriding to interpret LInt and LVar using the class feature of Racket. We define one class for each language and define a method for interpreting expressions inside each class. The class for LVar inherits from the class for LInt, and the method interp_exp in LVar overrides the interp_exp in LInt. Note that the default case of interp_exp in LVar uses super to invoke interp_exp, and because LVar inherits from LInt, that dispatches to the interp_exp in LInt.

```
(define interp-Lvar-class
(class interp-Lint-class
(define/override ((interp_exp env) e)
(match e
[(Var x)
(dict-ref env x)]
[(Let x e body)
(define v ((interp_exp env) e))
(define env^ (dict-set env x v))
((interp_exp env^) body)]
[else
((super interp_exp env) e)]))
...
))
```

```
(define interp-Lint-class
(class object%
(define/public ((interp_exp env) e)
(match e
[(Prim '- (list e))
(fx- 0 ((interp_exp env) e))]
...))
...))
```

We return to the troublesome example, repeated here:

(Let 'y (Int 10) (Prim '- (list (Var 'y))))

We can invoke the interp_exp method for LVar on this expression, which we call e0, by creating an object of the LVar class and calling the interp_exp method

