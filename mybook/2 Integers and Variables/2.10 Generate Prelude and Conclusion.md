# 2.10 Generate Prelude and Conclusion

```
movq $42, -8(%rbp)
movq -8(%rbp), -16(%rbp)
movq -16(%rbp), %rax
```

The second movq instruction is problematic because both arguments are stack loca- tions. We suggest fixing this problem by moving from the source location to the register rax and then from rax to the destination location, as follows.

```
movq -8(%rbp), %rax
movq %rax, -16(%rbp)
```

There is a similar corner case that also needs to be dealt with. If one argument is an immediate integer larger than 32 bits (either greater or equal to 231 or less than −231) and the other is a memory reference, then the instruction is invalid. One can fix this, for example, by first moving the immediate integer into rax and then using rax in place of the integer.

Exercise 2.7 Implement the patch_instructions pass in compiler.rkt. Create three new example programs that are designed to exercise all the interesting cases in this pass. In the run-tests.rkt script, add the following entry to the list of passes and then run the script to test your compiler.

(list "patch instructions" patch_instructions interp_x86-0)

2.10 Generate Prelude and Conclusion

The last step of the compiler from LVar to x86 is to generate the main function with a prelude and conclusion wrapped around the rest of the program, as shown in figure 2.8 and discussed in section 2.2. When running on Mac OS X, your compiler should prefix an underscore to all labels (for example, changing main to _main). The Racket call (system-type ’os) is useful for determining which operating system the compiler is running on. It returns ’macosx, ’unix, or ’windows.

Exercise 2.8 Implement the prelude_and_conclusion pass in compiler.rkt. In the run-tests.rkt script, add the following entry to the list of passes and then run the script to test your compiler.

(list "prelude and conclusion" prelude-and-conclusion interp_x86-0)

Uncomment the call to the compiler-tests function (appendix A.2), which tests your complete compiler by executing the generated x86 code. It translates the x86 AST that you produce into a string by invoking the print-x86 method of the print-x86-class in utilities.rkt. Compile the provided runtime.c file to runtime.o using gcc. Run the script to test your compiler.

