# 7.7 Explorations

7.19 In Section 9.3.1 we noted that Ada 83 does not permit subroutines to be passed as parameters, but that some of the same effect can be achieved with generics. Suppose we want to apply a function to every member of an array. We might write the following in Ada 83:

generic type item is private; type item_array is array (integer range <>) of item; with function F(it : in item) return item; procedure apply_to_array(A : in out item_array);

procedure apply_to_array(A : in out item_array) is begin for i in A'first..A'last loop A(i) := F(A(i)); end loop; end apply_to_array;

Given an array of integers, scores, and a function on integers, foo, we can write:

procedure apply_to_ints is new apply_to_array(integer, int_array, foo); ... apply_to_ints(scores);

How general is this mechanism? What are its limitations? Is it a reasonable substitute for formal (i.e., second-class, as opposed to third-class) subrou- tines? 7.20 Modify the code of Figure 7.3 or your solution to Exercise 7.12 to throw an exception if an attempt is made to enqueue an item in a full queue, or to dequeue an item from an empty queue.

7.21–7.27 In More Depth. 7.7 Explorations

7.28 Some language deﬁnitions specify a particular representation for data types in memory, while others specify only the semantic behavior of those types. For languages in the latter class, some implementations guarantee a partic- ular representation, while others reserve the right to choose different repre- sentations in different circumstances. Which approach do you prefer? Why? 7.29 Investigate the typestate mechanism employed by Strom et al. in the Hermes programming language [SBG+91]. Discuss its relationship to the notion of deﬁnite assignment in Java and C# (Section 6.1.3).

