# 7.8 Bibliographic Notes

**348**
Chapter 7* Type Systems*

```
7.30 Several recent projects attempt to blur the line between static and dynamic
typing by adding optional type declarations to scripting languages. These
declarations support a strategy of gradual typing, in which programmers
initially write in a traditional scripting style and then add declarations in-
crementally to increase reliability or decrease run-time cost. Learn about
the Dart, Hack, and TypeScript languages, promoted by Google, Facebook,
and Microsoft, respectively. What are your impressions? How easy do you
think it will be in practice to retroﬁt declarations into programs originally
developed without them?
7.31 Research the type systems of Standard ML, OCaml, Haskell, and F#. What
are the principal differences? What might explain the different choices made
by the language designers?
7.32 Write a program in C++ or Ada that creates at least two concrete types or
subroutines from the same template/generic. Compile your code to assem-
bly language and look at the result. Describe the mapping from source to
target code.
7.33 While Haskell does not include generics (its parametric polymorphism is
implicit), its type classes can be considered a generalization of type con-
straints. Learn more about type classes. Discuss their relevance to poly-
morphic functions, as well as more general uses. You might want to look
ahead to the discussion of monads in Section 11.5.2.
7.34 Investigate the notion of type conformance, employed by Black et al. in the
Emerald programming language [BHJL07]. Discuss how conformance re-
lates to the type inference of ML and to the class-based typing of object-
oriented languages.
7.35 C++11 introduces so-called variadic templates, which take a variable num-
ber of generic parameters. Read up on how these work. Show how they
might be used to replace the usual cout << expr1 << ... << exprn syntax
of formatted output with print(expr1, ... , exprn), while retaining full
static type checking.
```

7.36–7.38 In More Depth.
## 7.8

**Bibliographic Notes**
References to general information on the various programming languages men-
tioned in this chapter can be found in Appendix A, and in the Bibliographic
Notes for Chapters 1 and 6. Welsh, Sneeringer, and Hoare [WSH77] provide a
critique of the original Pascal deﬁnition, with a particular emphasis on its type
system. Tanenbaum’s comparison of Pascal and Algol 68 also focuses largely on
types [Tan78]. Cleaveland [Cle86] provides a book-length study of many of the is-
sues in this chapter. Pierce [Pie02] provides a formal and detailed modern cover-
age of the subject. The ACM Special Interest Group on Programming Languages

