# 7.2 Type Checking

**312**
Chapter 7* Type Systems*

3.
Name two programming languages that are strongly but dynamically
typed.
4.
What is a* type clash*?

5.
Discuss the differences among the* denotational*,* structural*, and* abstraction-*
*based* views of types.

6.
What does it mean for a set of language features (e.g., a type system) to be
*orthogonal*?
7.
What are* aggregates*?
8.
What are* option* types? What purpose do they serve?

9.
What is* polymorphism*? What distinguishes its* parametric* and* subtype* vari-
eties? What are* generics*?

10. What is the difference between* discrete* and* scalar* types?
11. Give two examples of languages that lack a Boolean type. What do they use
instead?
12. In what ways may an enumeration type be preferable to a collection of named
constants? In what ways may a subrange type be preferable to its base type?
In what ways may a string be preferable to an array of characters?

## 7.2

**Type Checking**
In most statically typed languages, every deﬁnition of an object (constant, vari-
able, subroutine, etc.) must specify the object’s type. Moreover, many of the con-
texts in which an object might appear are also typed, in the sense that the rules of
the language constrain the types that an object in that context may validly possess.
In the subsections below we will consider the topics of* type equivalence*,* type com-*
*patibility*, and* type inference*. Of the three, type compatibility is the one of most
concern to programmers. It determines when an object of a certain type can be
used in a certain context. At a minimum, the object can be used if its type and the
type expected by the context are equivalent (i.e., the same). In many languages,
however, compatibility is a looser relationship than equivalence: objects and con-
texts are often compatible even when their types are different. Our discussion of
type compatibility will touch on the subjects of type* conversion* (also called* cast-*
*ing*), which changes a value of one type into a value of another; type* coercion*,
which performs a conversion automatically in certain contexts; and* nonconvert-*
*ing* type casts, which are sometimes used in systems programming to interpret
the bits of a value of one type as if they represented a value of some other type.
Whenever an expression is constructed from simpler subexpressions, the ques-
tion arises: given the types of the subexpressions (and possibly the type expected

```
type R3 = record
b : integer;
a : integer
end;
```

Should the reversal of the order of the ﬁelds change the type? ML says no; most
languages say yes.
■
In a similar vein, consider the following arrays, again in a Pascal-like notation:
**EXAMPLE** 7.18

Other minor differences in
type

```
Alias types
type new_type = old_type;
(* Algol family syntax *)
```

```
typedef old_type new_type;
/* C family syntax */
```

