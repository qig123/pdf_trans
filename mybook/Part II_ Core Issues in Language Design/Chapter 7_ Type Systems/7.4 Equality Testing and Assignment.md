# 7.4 Equality Testing and Assignment

IN MORE DEPTH

On the companion site we discuss C++, Java, and C# generics in more detail, and consider the impact of their differing designs on the quality of error messages, the speed and size of generated code, and the expressive power of the notation. We note in particular the very different mechanisms used to make generic classes and methods support as broad a class of generic arguments as possible.

7.4 Equality Testing and Assignment

For simple, primitive data types such as integers, ﬂoating-point numbers, or char- acters, equality testing and assignment are relatively straightforward operations, with obvious semantics and obvious implementations (bit-wise comparison or copy). For more complicated or abstract data types, both semantic and imple- mentation subtleties arise. Consider for example the problem of comparing two character strings. Should the expression s = t determine whether s and t

are aliases for one another? occupy storage that is bit-wise identical over its full length? contain the same sequence of characters? would appear the same if printed?

The second of these tests is probably too low level to be of interest in most pro- grams; it suggests the possibility that a comparison might fail because of garbage in currently unused portions of the space reserved for a string. The other three alternatives may all be of interest in certain circumstances, and may generate dif- ferent results. In many cases the deﬁnition of equality boils down to the distinction between l-values and r-values: in the presence of references, should expressions be con- sidered equal only if they refer to the same object, or also if the objects to which they refer are in some sense equal? The ﬁrst option (refer to the same object) is known as a shallow comparison. The second (refer to equal objects) is called a deep comparison. For complicated data structures (e.g., lists or graphs) a deep comparison may require recursive traversal. In imperative programming languages, assignment operations may also be deep or shallow. Under a reference model of variables, a shallow assignment a := b will make a refer to the object to which b refers. A deep assignment will create a copy of the object to which b refers, and make a refer to the copy. Under a value model of variables, a shallow assignment will copy the value of b into a, but if that value is a pointer (or a record containing pointers), then the objects to which the pointer(s) refer will not be copied. Most programming languages employ both shallow comparisons and shallow assignment. A few (notably Python and the various dialects of Lisp and ML) EXAMPLE 7.57

provide more than one option for comparison. Scheme, for example, has three general-purpose equality-testing functions:

(eq? a b) ; do a and b refer to the same object? (eqv? a b) ; are a and b known to be semantically equivalent? (equal? a b) ; do a and b have the same recursive structure?

Both eq? and eqv? perform a shallow comparison. The former may be faster for certain types in certain implementations; in particular, eqv? is required to detect the equality of values of the same discrete type, stored in differentlocations; eq? is not. The simpler eq? behaves as one would expect for Booleans, symbols (names), and pairs (things built by cons), but can have implementation-deﬁned behavior on numbers, characters, and strings:

(eq? #t #t) =⇒ #t (true) (eq? 'foo 'foo) =⇒ #t (eq? '(a b) '(a b)) =⇒ #f (false); created by separate cons-es (let ((p '(a b))) (eq? p p)) =⇒ #t; created by the same cons (eq? 2 2) =⇒ implementation dependent (eq? "foo" "foo") =⇒ implementation dependent

In any particular implementation, numeric, character, and string tests will always work the same way; if (eq? 2 2) returns true, then (eq? 37 37) will return true also. Implementations are free to choose whichever behavior results in the fastest code. The exact rules that govern the situations in which eqv? is guaranteed to re- turn true or false are quite involved. Among other things, they specify that eqv? should behave as one might expect for numbers, characters, and nonempty strings, and that two objects will never test true for eqv? if there are any circum- stances under which they would behave differently. (Conversely, however, eqv? is allowed to return false for certain objects—functions, for example—that would behave identically in all circumstances.)7 The eqv? predicate is “less discriminat- ing” than eq?, in the sense that eqv? will never return false when eq? returns true. For structures (lists), eqv? returns false if its arguments refer to different root cons cells. In many programs this is not the desired behavior. The equal? predicate recursively traverses two lists to see if their internal structure is the same and their leaves are eqv?. The equal? predicate may lead to an inﬁnite loop if the programmer has used the imperative features of Scheme to create a circular list. ■

7 Signiﬁcantly, eqv? is also allowed to return false when comparing numeric values of different types: (eqv? 1 1.0) may evaluate to #f. For numeric code, one generally wants the separate = function: (= val1 val2) will perform the necessary coercion and test for numeric equality (subject to rounding errors).

