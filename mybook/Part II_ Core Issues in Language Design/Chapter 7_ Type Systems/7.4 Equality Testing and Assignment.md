# 7.4 Equality Testing and Assignment

**340**
Chapter 7* Type Systems*

**IN MORE DEPTH**

On the companion site we discuss C++, Java, and C# generics in more detail, and
consider the impact of their differing designs on the quality of error messages, the
speed and size of generated code, and the expressive power of the notation. We
note in particular the very different mechanisms used to make generic classes and
methods support as broad a class of generic arguments as possible.

## 7.4

**Equality Testing and Assignment**
```
For simple, primitive data types such as integers, ﬂoating-point numbers, or char-
acters, equality testing and assignment are relatively straightforward operations,
with obvious semantics and obvious implementations (bit-wise comparison or
copy). For more complicated or abstract data types, both semantic and imple-
mentation subtleties arise.
Consider for example the problem of comparing two character strings. Should
the expression s = t determine whether s and t
```

are aliases for one another?
occupy storage that is bit-wise identical over its full length?
contain the same sequence of characters?
would appear the same if printed?

```
The second of these tests is probably too low level to be of interest in most pro-
grams; it suggests the possibility that a comparison might fail because of garbage
in currently unused portions of the space reserved for a string. The other three
alternatives may all be of interest in certain circumstances, and may generate dif-
ferent results.
In many cases the deﬁnition of equality boils down to the distinction between
l-values and r-values: in the presence of references, should expressions be con-
sidered equal only if they refer to the same object, or also if the objects to which
they refer are in some sense equal? The ﬁrst option (refer to the same object) is
known as a shallow comparison. The second (refer to equal objects) is called a
deep comparison. For complicated data structures (e.g., lists or graphs) a deep
comparison may require recursive traversal.
In imperative programming languages, assignment operations may also be
deep or shallow. Under a reference model of variables, a shallow assignment
a := b will make a refer to the object to which b refers. A deep assignment
will create a copy of the object to which b refers, and make a refer to the copy.
Under a value model of variables, a shallow assignment will copy the value of b
into a, but if that value is a pointer (or a record containing pointers), then the
objects to which the pointer(s) refer will not be copied.
Most programming languages employ both shallow comparisons and shallow
assignment. A few (notably Python and the various dialects of Lisp and ML)
EXAMPLE 7.57
```

Equality testing in Scheme

