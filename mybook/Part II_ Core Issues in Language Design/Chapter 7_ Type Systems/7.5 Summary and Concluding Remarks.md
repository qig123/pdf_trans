342
Chapter 7 Type Systems
Deep assignments are relatively rare. They are used primarily in distributed
computing, and in particular for parameter passing in remote procedure call
(RPC) systems. These will be discussed in Section C 13.5.4.
For user-deﬁned abstractions, no single language-speciﬁed mechanism for
equality testing or assignment is likely to produce the desired results in all cases.
Languages with sophisticated data abstraction mechanisms usually allow the pro-
grammer to deﬁne the comparison and assignment operators for each new data
type—or to specify that equality testing and/or assignment is not allowed.
3CHECK YOUR UNDERSTANDING
26. Explain the distinction between implicit and explicit parametric polymor-
phism. What are their comparative advantages?
27. What is duck typing? What is its connection to polymorphism? In what lan-
guages does it appear?
28. Explain the distinction between overloading and generics. Why is the former
sometimes called ad hoc polymorphism?
29. What is the principal purpose of generics? In what sense do generics serve a
broader purpose in C++ and Ada than they do in Java and C#?
30. Under what circumstances can a language implementation share code among
separate instances of a generic?
31. What are container classes? What do they have to do with generics?
32. What does it mean for a generic parameter to be constrained? Explain the
difference between explicit and implicit constraints. Describe how interface
classes can be used to specify constraints in Java and C#.
33. Why will C# accept int as a generic argument, but Java won’t?
34. Under what circumstances will C++ instantiate a generic function implicitly?
35. Why is equality testing more subtle than it ﬁrst appears?
7.5
Summary and Concluding Remarks
This chapter has surveyed the fundamental concept of types. In the typical pro-
gramming language, types serve two principal purposes: they provide implicit
context for many operations, freeing the programmer from the need to specify
that context explicitly, and they allow the compiler to catch a wide variety of
common programming errors. When discussing types, we noted that it is some-
times helpful to distinguish among denotational, structural, and abstraction-
based points of view, which regard types, respectively, in terms of their values,
their substructure, and the operations they support.
7.5 Summary and Concluding Remarks
343
In a typical programming language, the type system consists of a set of built-
in types, a mechanism to deﬁne new types, and rules for type equivalence, type
compatibility, and type inference. Type equivalence determines when two values
or named objects have the same type. Type compatibility determines when a value
of one type may be used in a context that “expects” another type. Type inference
determines the type of an expression based on the types of its components or
(sometimes) the surrounding context. A language is said to be strongly typed if it
never allows an operation to be applied to an object that does not support it; a
language is said to be statically typed if it enforces strong typing at compile time.
We introduced terminology for the common built-in types and for enumer-
ations, subranges, and the common type constructors (more on the latter will
appear in Chapter 8). We discussed several different approaches to type equiv-
alence, compatibility, and inference. We also examined type conversion, coercion,
and nonconverting casts. In the area of type equivalence, we contrasted the struc-
tural and name-based approaches, noting that while name equivalence appears to
have gained in popularity, structural equivalence retains its advocates.
Expanding on material introduced in Section 3.5.2, we explored several styles
of polymorphism, all of which allow a subroutine—or the methods of a class—to
operate on values of multiple types, so long as they only use those values in ways
their types support. We focused in particular on parametric polymorphism, in
which the types of the values on which the code will operate are passed to it as
extra parameters, implicitly or explicitly. The implicit alternative appears in the
static typing of ML and its descendants, and in the dynamic typing of Lisp, Small-
talk, and many other languages. The explicit alternative appears in the generics of
many modern languages. In Chapter 10 we will consider the related topic of sub-
type polymorphism.
In our discussion of implicit parametric polymorphism, we devoted consid-
erable attention to type checking in ML, where the compiler uses a sophisticated
system of inference to determine, at compile time, whether a type error (an at-
tempt to perform an operation on a type that doesn’t support it) could ever oc-
cur at run time—all without access to type declarations in the source code. In
our discussion of generics we explored alternative ways to express constraints on
generic parameters. We also considered implementation strategies. As examples,
we contrasted (on the companion site) the generic facilities of C++, Java, and C#.
More so, perhaps, than in previous chapters, our study of types has highlighted
fundamental differences in philosophy among language designers. As we have
seen, some languages use variables to name values; others, references. Some lan-
guages do all or most of their type checking at compile time; others wait until
run time. Among those that check at compile time, some use name equivalence;
others, structural equivalence. Some languages avoid type coercions; others em-
brace them. Some avoid overloading; others again embrace them. In each case,
the choice among design alternatives reﬂects nontrivial tradeoffs among compet-
ing language goals, including expressiveness, ease of programming, quality and
timing of error discovery, ease of debugging and maintenance, compilation cost,
and run-time performance.
