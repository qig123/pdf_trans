# 7.5 Summary and Concluding Remarks

**342**
Chapter 7* Type Systems*

Deep assignments are relatively rare. They are used primarily in distributed
computing, and in particular for parameter passing in remote procedure call
(RPC) systems. These will be discussed in Section C 13.5.4.
For user-deﬁned abstractions, no single language-speciﬁed mechanism for
equality testing or assignment is likely to produce the desired results in all cases.
Languages with sophisticated data abstraction mechanisms usually allow the pro-
grammer to deﬁne the comparison and assignment operators for each new data
type—or to specify that equality testing and/or assignment is not allowed.

```
3CHECK YOUR UNDERSTANDING
26. Explain the distinction between implicit and explicit parametric polymor-
phism. What are their comparative advantages?
27. What is duck typing? What is its connection to polymorphism? In what lan-
guages does it appear?
28. Explain the distinction between overloading and generics. Why is the former
sometimes called ad hoc polymorphism?
```

29. What is the principal purpose of generics? In what sense do generics serve a
broader purpose in C++ and Ada than they do in Java and C#?

30. Under what circumstances can a language implementation share code among
separate instances of a generic?

31. What are* container* classes? What do they have to do with generics?
32. What does it mean for a generic parameter to be* constrained*? Explain the
difference between explicit and implicit constraints. Describe how interface
classes can be used to specify constraints in Java and C#.

```
33. Why will C# accept int as a generic argument, but Java won’t?
34. Under what circumstances will C++ instantiate a generic function implicitly?
```

35. Why is equality testing more subtle than it ﬁrst appears?

## 7.5

**Summary and Concluding Remarks**
This chapter has surveyed the fundamental concept of* types*. In the typical pro-
gramming language, types serve two principal purposes: they provide implicit
context for many operations, freeing the programmer from the need to specify
that context explicitly, and they allow the compiler to catch a wide variety of
common programming errors. When discussing types, we noted that it is some-
times helpful to distinguish among denotational, structural, and abstraction-
based points of view, which regard types, respectively, in terms of their values,
their substructure, and the operations they support.

