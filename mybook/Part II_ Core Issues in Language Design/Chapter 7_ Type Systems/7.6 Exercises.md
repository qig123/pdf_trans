# 7.6 Exercises

**344**
Chapter 7* Type Systems*

## 7.6

**Exercises**
7.1
Most statically typed languages developed since the 1970s (including Java,
C#, and the descendants of Pascal) use some form of name equivalence for
types. Is structural equivalence a bad idea? Why or why not?
7.2
In the following code, which of the variables will a compiler consider to have
compatible types under structural equivalence? Under strict name equiva-
lence? Under loose name equivalence?

type T = array [1..10] of integer
S = T
A : T
B : T
C : S
D : array [1..10] of integer

7.3
Consider the following declarations:

1.
type cell
–– a forward declaration
2.
type cell ptr = pointer to cell
3.
x : cell
4.
type cell = record
5.
val : integer
6.
next : cell ptr
7.
y : cell

```
Should the declaration at line 4 be said to introduce an alias type? Under
strict name equivalence, should x and y have the same type? Explain.
7.4
Suppose you are implementing an Ada compiler, and must support arith-
metic on 32-bit ﬁxed-point binary numbers with a programmer-speciﬁed
number of fractional bits. Describe the code you would need to generate
to add, subtract, multiply, or divide two ﬁxed-point numbers. You should
assume that the hardware provides arithmetic instructions only for integers
and IEEE ﬂoating-point. You may assume that the integer instructions pre-
serve full precision; in particular, integer multiplication produces a 64-bit
result. Your description should be general enough to deal with operands
and results that have different numbers of fractional bits.
7.5
When Sun Microsystems ported Berkeley Unix from the Digital VAX to the
Motorola 680x0 in the early 1980s, many C programs stopped working, and
had to be repaired. In effect, the 680x0 revealed certain classes of program
bugs that one could “get away with” on the VAX. One of these classes of bugs
occurred in programs that use more than one size of integer (e.g., short
and long), and arose from the fact that the VAX is a little-endian machine,
while the 680x0 is big-endian (Section C 5.2). Another class of bugs oc-
curred in programs that manipulate both null and empty strings. It arose
```

