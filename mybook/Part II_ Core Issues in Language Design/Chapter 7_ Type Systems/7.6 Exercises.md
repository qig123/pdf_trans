344
Chapter 7 Type Systems
7.6
Exercises
7.1
Most statically typed languages developed since the 1970s (including Java,
C#, and the descendants of Pascal) use some form of name equivalence for
types. Is structural equivalence a bad idea? Why or why not?
7.2
In the following code, which of the variables will a compiler consider to have
compatible types under structural equivalence? Under strict name equiva-
lence? Under loose name equivalence?
type T = array [1..10] of integer
S = T
A : T
B : T
C : S
D : array [1..10] of integer
7.3
Consider the following declarations:
1.
type cell
–– a forward declaration
2.
type cell ptr = pointer to cell
3.
x : cell
4.
type cell = record
5.
val : integer
6.
next : cell ptr
7.
y : cell
Should the declaration at line 4 be said to introduce an alias type? Under
strict name equivalence, should x and y have the same type? Explain.
7.4
Suppose you are implementing an Ada compiler, and must support arith-
metic on 32-bit ﬁxed-point binary numbers with a programmer-speciﬁed
number of fractional bits. Describe the code you would need to generate
to add, subtract, multiply, or divide two ﬁxed-point numbers. You should
assume that the hardware provides arithmetic instructions only for integers
and IEEE ﬂoating-point. You may assume that the integer instructions pre-
serve full precision; in particular, integer multiplication produces a 64-bit
result. Your description should be general enough to deal with operands
and results that have different numbers of fractional bits.
7.5
When Sun Microsystems ported Berkeley Unix from the Digital VAX to the
Motorola 680x0 in the early 1980s, many C programs stopped working, and
had to be repaired. In effect, the 680x0 revealed certain classes of program
bugs that one could “get away with” on the VAX. One of these classes of bugs
occurred in programs that use more than one size of integer (e.g., short
and long), and arose from the fact that the VAX is a little-endian machine,
while the 680x0 is big-endian (Section C 5.2). Another class of bugs oc-
curred in programs that manipulate both null and empty strings. It arose
7.6 Exercises
345
from the fact that location zero in a Unix process’s address space on the VAX
always contained a zero, while the same location on the 680x0 is not in the
address space, and will generate a protection error if used. For both of these
classes of bugs, give examples of program fragments that would work on a
VAX but not on a 680x0.
7.6
Ada provides two “remainder” operators, rem and mod for integer types,
deﬁned as follows [Ame83, Sec. 4.5.5]:
Integer division and remainder are deﬁned by the relation A = (A/B)*B + (A rem
B), where (A rem B) has the sign of A and an absolute value less than the absolute
value of B. Integer division satisﬁes the identity (-A)/B = -(A/B) = A/(-B).
The result of the modulus operation is such that (A mod B) has the sign of
B and an absolute value less than the absolute value of B; in addition, for some
integer value N, this result must satisfy the relation A = B*N + (A mod B).
Give values of A and B for which A rem B and A mod B differ. For what
purposes would one operation be more useful than the other? Does it make
sense to provide both, or is it overkill?
Consider also the % operator of C and the mod operator of Pascal. The
designers of these languages could have picked semantics resembling those
of either Ada’s rem or its mod. Which did they pick? Do you think they
made the right choice?
7.7
Consider the problem of performing range checks on set expressions in Pas-
cal. Given that a set may contain many elements, some of which may be
known at compile time, describe the information that a compiler might
maintain in order to track both the elements known to belong to the set
and the possible range of unknown elements. Then explain how to update
this information for the following set operations: union, intersection, and
difference. The goal is to determine (1) when subrange checks can be elimi-
nated at run time and (2) when subrange errors can be reported at compile
time. Bear in mind that the compiler cannot do a perfect job: some unnec-
essary run-time checks will inevitably be performed, and some operations
that must always result in errors will not be caught at compile time. The
goal is to do as good a job as possible at reasonable cost.
7.8
In Section 7.2.2 we introduced the notion of a universal reference type
(void * in C) that refers to an object of unknown type. Using such ref-
erences, implement a “poor man’s generic queue” in C, as suggested in Sec-
tion 7.3.1. Where do you need type casts? Why? Give an example of a use of
the queue that will fail catastrophically at run time, due to the lack of type
checking.
7.9
Rewrite the code of Figure 7.3 in Ada, Java, or C#.
7.10 (a) Give a generic solution to Exercise 6.19.
(b) Translate this solution into Ada, Java, or C#.
7.11 In your favorite language with generics, write code for simple versions of
the following abstractions:
346
Chapter 7 Type Systems
(a) a stack, implemented as a linked list
(b) a priority queue, implemented as a skip list or a partially ordered tree
embedded in an array
(c)
a dictionary (mapping), implemented as a hash table
7.12 Figure 7.3 passes integer max_items to the queue abstraction as a generic
parameter. Write an alternative version of the code that makes max_items
a parameter to the queue constructor instead. What is the advantage of the
generic parameter version?
7.13 Rewrite the generic sorting routine of Examples 7.50–7.52 (with con-
straints) using OCaml or SML functors.
7.14 Flesh out the C++ sorting routine of Example 7.53.
Demonstrate that
this routine does “the wrong thing” when asked to sort an array of char*
strings.
7.15 In Example 7.53 we mentioned three ways to make the need for compar-
isons more explicit when deﬁning a generic sort routine in C++: make the
comparison routine a method of the generic parameter class T, an extra ar-
gument to the sort routine, or an extra generic parameter. Implement these
options and discuss their comparative strengths and weaknesses.
7.16 Yet another solution to the problem of the previous exercise is to make the
sorting routine a method of a sorter class. The comparison routine can
then be passed into the class as a constructor argument. Implement this
option and compare it to those of the previous exercise.
7.17 Consider the following code skeleton in C++:
#include <list>
using std::list;
class foo { ...
class bar : public foo { ...
static void print_all(list<foo*> &L) { ...
list<foo*> LF;
list<bar*> LB;
...
print_all(LF);
// works fine
print_all(LB);
// static semantic error
Explain why the compiler won’t allow the second call. Give an example of
bad things that could happen if it did.
7.18 Bjarne Stroustrup, the original designer of C++, once described templates
as “a clever kind of macro that obeys the scope, naming, and type rules of
C++” [Str13, 2nd ed., p. 257].
How close is the similarity? What can
templates do that macros can’t? What do macros do that templates don’t?
