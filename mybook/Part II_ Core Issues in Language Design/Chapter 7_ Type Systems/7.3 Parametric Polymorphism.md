# 7.3 Parametric Polymorphism

7.3 Parametric Polymorphism
**331**

**DESIGN & IMPLEMENTATION**

7.8 Uniﬁcation
Uniﬁcation is a powerful technique. In addition to its role in type inference
(which also arises in the templates [generics] of C++), uniﬁcation plays a cen-
tral role in the computational model of Prolog and other logic languages. We
will consider this latter role in Section 12.1. In the general case the cost of uni-
fying the types of two expressions can be exponential [Mai90], but the patho-
logical cases tend not to arise in practice.

```
3CHECK YOUR UNDERSTANDING
13. What is the difference between type equivalence and type compatibility?
```

14. Discuss the comparative advantages of* structural* and* name* equivalence for
types. Name three languages that use each approach.

15. Explain the difference between* strict* and* loose* name equivalence.
16. Explain the distinction between* derived* types and* subtypes* in Ada.

17. Explain the differences among* type conversion*,* type coercion*, and* nonconvert-*
*ing type casts*.

18. Summarize the arguments for and against coercion.
19. Under what circumstances does a type conversion require a run-time check?

20. What purpose is served by* universal* reference types?
21. What is* type inference*? Describe three contexts in which it occurs.
22. Under what circumstances does an ML compiler announce a type clash?

23. Explain how the type inference of ML leads naturally to polymorphism.
24. Why do ML programmers often declare the types of variables, even when they
don’t have to?
25. What is* uniﬁcation*? What is its role in ML?

## 7.3

**Parametric Polymorphism**
As we have seen in the previous section, functions in ML-family languages are
naturally polymorphic. Consider the simple task of ﬁnding the minimum of two
values. In OCaml, the function
**EXAMPLE** 7.44

```
Finding the minimum in
OCaml or Haskell
let min x y = if x < y then x else y;;
```

```
sort(ints, 10);
sort(reals, 50);
sort(strings, 30);
```

