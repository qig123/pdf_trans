# 7.1 Overview

to drive important performance optimizations. As a simple example, recall the EXAMPLE 7.3

Types as a source of “may alias” information concept of aliases, introduced in Section 3.5.1, and discussed in Sidebar 3.7. If a program performs an assignment through a pointer, the compiler may be able to infer that objects of unrelated types cannot possibly be affected; their values can safely remain in registers, even if loaded prior to the assignment. ■

Section 7.1 looks more closely at the meaning and purpose of types. It presents some basic deﬁnitions, and introduces the notions of polymorphism and orthog- onality. Section 7.2 takes a closer look at type checking; in particular, it considers type equivalence (when can we say that two types are the same?), type compatibility (when can we use a value of a given type in a given context?), and type inference (how do we deduce the type of an expression from the types of its components and that of the surrounding context?). As an example of both polymorphism and sophisticated inference, Sec- tion 7.2.4 surveys the type system of ML, which combines, to a large extent, the efﬁciency and early error reporting of compilation with the convenience and ﬂex- ibility of interpretation. We continue the study of polymorphism in Section 7.3, with a particular emphasis on generics, which allow a body of code to be param- eterized explicitly for multiple types. Finally, in Section 7.4, we consider what it means to compare two complex objects for equality, or to assign one into the other. In Chapter 8 we will consider syntactic, semantic, and pragmatic issues for some of the most important composite types: records, arrays, strings, sets, pointers, lists, and ﬁles. 7.1 Overview

Computer hardware can interpret bits in memory in several different ways: as in- structions, addresses, characters, and integer and ﬂoating-point numbers of var- ious lengths. The bits themselves, however, are untyped: the hardware on most machines makes no attempt to keep track of which interpretations correspond to which locations in memory. Assembly languages reﬂect this lack of typing: op- erations of any kind can be applied to values in arbitrary locations. High-level languages, by contrast, almost always associate types with values, to provide the contextual information and error checking alluded to above. Informally, a type system consists of (1) a mechanism to deﬁne types and asso- ciate them with certain language constructs, and (2) a set of rules for type equiv- alence, type compatibility, and type inference. The constructs that must have types are precisely those that have values, or that can refer to objects that have val- ues. These constructs include named constants, variables, record ﬁelds, param- eters, and sometimes subroutines; literal constants (e.g., 17, 3.14, "foo"); and more complicated expressions containing these. Type equivalence rules deter- mine when the types of two values are the same. Type compatibility rules deter- mine when a value of a given type can be used in a given context. Type inference rules deﬁne the type of an expression based on the types of its constituent parts or

(sometimes) the surrounding context. In a language with polymorphic variables or parameters, it may be important to distinguish between the type of a reference or pointer and the type of the object to which it refers: a given name may refer to objects of different types at different times. Subroutines are considered to have types in some languages, but not in others. Subroutines need to have types if they are ﬁrst- or second-class values (i.e., if they can be passed as parameters, returned by functions, or stored in variables). In each of these cases there is a construct in the language whose value is a dynami- cally determined subroutine; type information allows the language to limit the set of acceptable values to those that provide a particular subroutine interface (i.e., particular numbers and types of parameters). In a statically scoped language that never creates references to subroutines dynamically (one in which subroutines are always third-class values), the compiler can always identify the subroutine to which a name refers, and can ensure that the routine is called correctly without necessarily employing a formal notion of subroutine types. Type checking is the process of ensuring that a program obeys the language’s type compatibility rules. A violation of the rules is known as a type clash. A language is said to be strongly typed if it prohibits, in a way that the language implementation can enforce, the application of any operation to any object that is not intended to support that operation. A language is said to be statically typed if it is strongly typed and type checking can be performed at compile time. In the strictest sense of the term, few languages are statically typed. In practice, the term is often applied to languages in which most type checking can be performed at compile time, and the rest can be performed at run time. Since the mid 1970s, most newly developed languages have tended to be strongly (though not necessarily statically) typed. Interestingly, C has become more strongly typed with each successive version of the language, though various loopholes remain; these include unions, nonconverting type casts, subroutines with variable numbers of parameters, and the interoperability of pointers and arrays (to be discussed in Section 8.5.1). Implementations of C rarely check any- thing at run time.

DESIGN & IMPLEMENTATION

7.1 Systems programming The standard argument against complete type safety in C is that systems pro- grams need to be able to “break” types on occasion. Consider, for example, the code that implements dynamic memory management (e.g., malloc and free). This code must interpret the same bytes, at different times, as unal- located space, metadata, or (parts of) user-deﬁned data structures. “By ﬁat” conversions between types are inescapable. Such conversions need not, how- ever, be subtle. Largely in reaction to experience with C, the designers of C# chose to permit operations that break the type system only within blocks of code that have been explicitly labeled unsafe.

Dynamic (run-time) type checking can be seen as a form of late binding, and tends to be found in languages that delay other issues until run time as well. Static typing is thus the norm in languages intended for performance; dynamic typing is more common in languages intended for ease of programming. Lisp and Small- talk are dynamically (though strongly) typed. Most scripting languages are also dynamically typed; some (e.g., Python and Ruby) are strongly typed. Languages with dynamic scoping are generally dynamically typed (or not typed at all): if the compiler can’t identify the object to which a name refers, it usually can’t deter- mine the type of the object either.

7.1.1 The Meaning of “Type”

While every programmer has at least an informal notion of what is meant by “type,” that notion can be formalized in several different ways. Three of the most popular are what we might call the denotational, structural, and abstraction-based points of view. From the denotational point of view, a type is simply a set of val- ues. A value has a given type if it belongs to the set; an object has a given type if its value is guaranteed to be in the set. From the structural point of view, a type is either one of a small collection of built-in types (integer, character, Boolean, real, etc.; also called primitive or predeﬁned types), or a composite type created by

DESIGN & IMPLEMENTATION

7.2 Dynamic typing The growing popularity of scripting languages has led a number of promi- nent software developers to publicly question the value of static typing. They ask: given that we can’t check everything at compile time, how much pain is it worth to check the things we can? As a general rule, it is easier to write type- correct code than to prove that we have done so, and static typing requires such proofs. As type systems become more complex (due to object orienta- tion, generics, etc.), the complexity of static typing increases correspondingly. Anyone who has written extensively in Ada or C++ on the one hand, and in Python or Scheme on the other, cannot help but be struck at how much easier it is to write code, at least for modest-sized programs, without complex type declarations. Dynamic checking incurs some run-time overhead, of course, and may delay the discovery of bugs, but this is increasingly seen as insigniﬁ- cant in comparison to the potential increase in human productivity. An inter- mediate position, epitomized by the ML family of languages but increasingly adopted (in limited form) by others, retains the requirement that types be stat- ically known, but relies on the compiler to infer them automatically, without the need for some (or—in the case of ML—most) explicit declarations. We will discuss this topic more in Section 7.2.3. Static and dynamic typing and the role of inference promise to provide some of the most interesting language debates of the coming decade.

applying a type constructor (record, array, set, etc.) to one or more simpler types. (This use of the term “constructor” is unrelated to the initialization func- tions of object-oriented languages. It also differs in a more subtle way from the use of the term in ML.) From the abstraction-based point of view, a type is an in- terface consisting of a set of operations with well-deﬁned and mutually consistent semantics. For both programmers and language designers, types may also reﬂect a mixture of these viewpoints. In denotational semantics (one of several ways to formalize the meaning of programs), a set of values is known as a domain. Types are domains, and the meaning of an expression is a value from the domain that represents the expres- sion’s type. Some domains—the integers, for example—are simple and familiar. Others are more complex. An array can be thought of as a value from a domain whose elements are functions; each of these functions maps values from some ﬁ- nite index type (typically a subset of the integers) to values of some other element type. As it turns out, denotational semantics can associate a type with everything in a program—even statements with side effects. The meaning of an assignment statement is a value from a domain of higher-level functions, each of whose ele- ments maps a store—a mapping from names to values that represents the current contents of memory—to another store, which represents the contents of memory after the assignment. One of the nice things about the denotational view of types is that it allows us in many cases to describe user-deﬁned composite types (records, arrays, etc.) in terms of mathematical operations on sets. We will allude to these operations again under “Composite Types” in Section 7.1.4. Because it is based on mathematical objects, the denotational view of types usually ignores such implementation is- sues as limited precision and word length. This limitation is less serious than it might at ﬁrst appear: Checks for such errors as arithmetic overﬂow are usually implemented outside of the type system of a language anyway. They result in a run-time error, but this error is not called a type clash. When a programmer deﬁnes an enumerated type (e.g., enum hue {red, green, blue} in C), he or she certainly thinks of this type as a set of values. For other varieties of user-deﬁned type, this denotational view may not be as nat- ural. Instead, the programmer may think in terms of the way the type is built from simpler types, or in terms of its meaning or purpose. These ways of think- ing reﬂect the structural and abstraction-based points of view, respectively. The structural point of view was pioneered by Algol W and Algol 68, and is character- istic of many languages designed in the 1970s and 1980s. The abstraction-based point of view was pioneered by Simula-67 and Smalltalk, and is characteristic of modern object-oriented languages; it can also be found in the module constructs of various other languages, and it can be adopted as a matter of programming discipline in almost any language. We will consider the structural point of view in more detail in Chapter 8, and the abstraction-based in Chapter 10.

7.1.2 Polymorphism

Polymorphism, which we mentioned brieﬂy in Section 3.5.2, takes its name from the Greek, and means “having multiple forms.” It applies to code—both data structures and subroutines—that is designed to work with values of multiple types. To maintain correctness, the types must generally have certain characteris- tics in common, and the code must not depend on any other characteristics. The commonality is usually captured in one of two main ways. In parametric poly- morphism the code takes a type (or set of types) as a parameter, either explicitly or implicitly. In subtype polymorphism, the code is designed to work with values of some speciﬁc type T, but the programmer can deﬁne additional types to be extensions or reﬁnements of T, and the code will work with these subtypes as well. Explicit parametric polymorphism, also known as generics (or templates in C++), typically appears in statically typed languages, and is usually implemented at compile time. The implicit version can also be implemented at compile time— speciﬁcally, in ML-family languages; more commonly, it is paired with dynamic typing, and the checking occurs at run time. Subtype polymorphism appears primarily in object-oriented languages. With static typing, most of the work required to deal with multiple types can be per- formed at compile time: the principal run-time cost is an extra level of indirection on method invocations. Most languages that envision such an implementation, including C++, Eiffel, OCaml, Java, and C#, provide a separate mechanism for generics, also checked mainly at compile time. The combination of subtype and parametric polymorphism is particularly useful for container (collection) classes such as “list of T” (List<T>) or “stack of T” (Stack<T>), where T is initially unspeciﬁed, and can be instantiated later as almost any type. By contrast, dynamically typed object-oriented languages, including Smalltalk, Python, and Ruby, generally use a single mechanism for both parametric and sub- type polymorphism, with checking delayed until run time. A uniﬁed mechanism also appears in Objective-C, which provides dynamically typed objects on top of otherwise static typing. We will consider parametric polymorphism in more detail in Section 7.3, after our coverage of typing in ML. Subtype polymorphism will largely be deferred to Chapter 10, which covers object orientation, and to Section 14.4.4, which focuses on objects in scripting languages.

7.1.3 Orthogonality

In Section 6.1.2 we discussed the importance of orthogonality in the design of expressions, statements, and control-ﬂow constructs. In a highly orthogonal lan- guage, these features can be used, with consistent behavior, in almost any com- bination. Orthogonality is equally important in type system design. A highly or- thogonal language tends to be easier to understand, to use, and to reason about in

a formal way. We have noted that languages like Algol 68 and C enhance orthog- onality by eliminating (or at least blurring) the distinction between statements and expressions. To characterize a statement that is executed for its side effect(s), and that has no useful values, some languages provide a trivial type with a single value. In C and Algol 68, for example, a subroutine that is meant to be used as a EXAMPLE 7.4

void (trivial) type procedure is generally declared with a return type of void. In ML, the trivial type is called unit. If the programmer wishes to call a subroutine that does return a value, but the value is not needed in this particular case (all that matters is the side effect[s]), then the return value in C can be discarded by “casting” it to void:

foo_index = insert_in_symbol_table(foo); ... (void) insert_in_symbol_table(bar); /* don't care where it went */ /* cast is optional; implied if omitted */ ■

In a language (e.g., Pascal) without a trivial type, the latter of these two calls would EXAMPLE 7.5

Making do without void need to use a dummy variable:

var dummy : symbol_table_index; ... dummy := insert_in_symbol_table(bar); ■

As another example of orthogonality, consider the common need to “erase” the value of a variable—to indicate that it does not hold a valid value of its type. For pointer types, we can often use the value null. For enumerations, we can add an extra “none of the above” alternative to the set of possible values. But these two techniques are very different, and they don’t generalize to types that already make use of all available bit patterns in the underlying implementation. To address the need for “none of the above” in a more orthogonal way, many EXAMPLE 7.6

Option types in OCaml functional languages—and some imperative languages as well—provide a special type constructor, often called Option or Maybe. In OCaml, we can write

let divide n d : float option = (* n and d are parameters *) match d with (* "float option" is the return type *) | 0. -> None | _ -> Some (n /. d);; (* underscore means "anything else" *)

let show v : string = match v with | None -> "??" | Some x -> string_of_float x;;

Here function divide returns None if asked to divide by zero; otherwise it returns Some x, where x is the desired quotient. Function show returns either "??" or the string representation of x, depending on whether parameter v is None or Some x. ■

Option types appear in a variety of other languages, including Haskell (which calls them Maybe), Scala, C#, Swift, and (as generic library classes) Java and C++. In the interest of brevity, C# and Swift use a trailing question mark instead of the EXAMPLE 7.7

Option types in Swift option constructor. Here is the previous example, rewritten in Swift:

func divide(n : Double, d : Double) -> Double? { if d == 0 { return nil } return n / d }

func show(v : Double?) -> String { if v == nil { return "??" } return "\(v!)" // interpolate v into string }

With these deﬁnitions, show(divide(3.0, 4.0)) will evaluate to "0.75", while show(divide(3.0, 0.0)) will evaluate to "??". ■ Yet another example of orthogonality arises when specifying literal values for objects of composite type. Such literals are sometimes known as aggregates. They are particularly valuable for the initialization of static data structures; without them, a program may need to waste time performing initialization at run time. Ada provides aggregates for all its structured types. Given the following decla- EXAMPLE 7.8

Aggregates in Ada rations

type person is record name : string (1..10); age : integer; end record; p, q : person; A, B : array (1..10) of integer;

we can write the following assignments:

p := ("Jane Doe ", 37); q := (age => 36, name => "John Doe "); A := (1, 0, 3, 0, 3, 0, 3, 0, 0, 0); B := (1 => 1, 3 | 5 | 7 => 3, others => 0);

Here the aggregates assigned into p and A are positional; the aggregates assigned into q and B name their elements explicitly. The aggregate for B uses a shorthand notation to assign the same value (3) into array elements 3, 5, and 7, and to as- sign a 0 into all unnamed ﬁelds. Several languages, including C, C++, Fortran 90, and Lisp, provide similar capabilities. ■ ML provides a very general facility for composite expressions, based on the use of constructors (discussed in Section 11.4.3). Lambda expressions, which we saw in Section 3.6.4 and will discuss again in Chapter 11, amount to aggregates for values that are functions.

7.1.4 Classiﬁcation of Types

The terminology for types varies some from one language to another. This sub- section presents deﬁnitions for the most common terms. Most languages provide built-in types similar to those supported in hardware by most processors: inte- gers, characters, Booleans, and real (ﬂoating-point) numbers. Booleans (sometimes called logicals) are typically implemented as single-byte quantities, with 1 representing true and 0 representing false. In a few lan- guages and implementations, Booleans may be packed into arrays using only one bit per value. As noted in Section 6.1.2 (“Orthogonality”), C was historically un- usual in omitting a Boolean type: where most languages would expect a Boolean value, C expected an integer, using zero for false and anything else for true. C99 introduced a new _Bool type, but it is effectively an integer that the com- piler is permitted to store in a single bit. As noted in Section C 6.5.4, Icon replaces Booleans with a more general notion of success and failure. Characters have traditionally been implemented as one-byte quantities as well, typically (but not always) using the ASCII encoding. More recent languages (e.g., Java and C#) use a two-byte representation designed to accommodate (the com- monly used portion of) the Unicode character set. Unicode is an international standard designed to capture the characters of a wide variety of languages (see Sidebar 7.3). The ﬁrst 128 characters of Unicode (\u0000 through \u007f) are identical to ASCII. C and C++ provide both regular and “wide” characters, though for wide characters both the encoding and the actual width are imple- mentation dependent. Fortran 2003 supports four-byte Unicode characters.

Numeric Types

A few languages (e.g., C and Fortran) distinguish between different lengths of in- tegers and real numbers; most do not, and leave the choice of precision to the implementation. Unfortunately, differences in precision across language imple- mentations lead to a lack of portability: programs that run correctly on one sys- tem may produce run-time errors or erroneous results on another. Java and C# are unusual in providing several lengths of numeric types, with a speciﬁed preci- sion for each. A few languages, including C, C++, C#, and Modula-2, provide both signed and unsigned integers (Modula-2 calls unsigned integers cardinals). A few lan- guages (e.g., Fortran, C, Common Lisp, and Scheme) provide a built-in complex type, usually implemented as a pair of ﬂoating-point numbers that represent the real and imaginary Cartesian coordinates; other languages support these as a stan- dard library class. A few languages (e.g., Scheme and Common Lisp) provide a built-in rational type, usually implemented as a pair of integers that represent the numerator and denominator. Most varieties of Lisp also support integers of arbitrary precision, as do most scripting languages; the implementation uses multiple words of memory where appropriate. Ada supports ﬁxed-point types, which are represented internally by integers, but have an implied decimal point at a programmer-speciﬁed position among the digits. Several languages support

decimal types that use a base-10 encoding to avoid round-off anomalies in ﬁnan- cial and human-centered arithmetic (see Sidebar 7.4). Integers, Booleans, and characters are all examples of discrete types (also called ordinal types): the domains to which they correspond are countable (they have a one-to-one correspondence with some subset of the integers), and have a well- deﬁned notion of predecessor and successor for each element other than the ﬁrst and the last. (In most implementations the number of possible integers is ﬁnite, but this is usually not reﬂected in the type system.) Two varieties of user-deﬁned types, enumerations and subranges, are also discrete. Discrete, rational, real, and

DESIGN & IMPLEMENTATION

7.3 Multilingual character sets The ISO 10646 international standard deﬁnes a Universal Character Set (UCS) intended to include all characters of all known human languages. (It also sets aside a “private use area” for such artiﬁcial [constructed] languages as Klingon, Tengwar, and Cirth [Tolkien Elvish]. Allocation of this private space is coordi- nated by a volunteer organization known as the ConScript Unicode Registry.) All natural languages currently employ codes in the 16-bit Basic Multilingual Plane (BMP): 0x0000 through 0xfffd. Unicode is an expanded version of ISO 10646, maintained by an interna- tional consortium of software manufacturers. In addition to mapping tables, it covers such topics as rendering algorithms, directionality of text, and sorting and comparison conventions. While recent languages have moved toward 16- or 32-bit internal char- acter representations, these cannot be used for external storage—text ﬁles— without causing severe problems with backward compatibility. To accommo- date Unicode without breaking existing tools, Ken Thompson in 1992 pro- posed a multibyte “expanding” code known as UTF-8 (UCS/Unicode Trans- formation Format, 8-bit), and codiﬁed as a formal annex (appendix) to ISO 10646. UTF-8 characters occupy a maximum of 6 bytes—3 if they lie in the BMP, and only 1 if they are ordinary ASCII. The trick is to observe that ASCII is a 7-bit code; in any legacy text ﬁle the most signiﬁcant bit of every byte is 0. In UTF-8 a most signiﬁcant bit of 1 indicates a multibyte character. Two-byte codes begin with the bits 110. Three-byte codes begin with 1110. Second and subsequent bytes of multibyte characters always begin with 10. On some systems one also ﬁnds ﬁles encoded in one of ten variants of the older 8-bit ISO 8859 standard, but these are inconsistently rendered across platforms. On the web, non-ASCII characters are typically encoded with nu- meric character references, which bracket a Unicode value, written in decimal or hex, with an ampersand and a semicolon. The copyright symbol (©), for example, is &#169;. Many characters also have symbolic entity names (e.g., &copy;), but not all browsers support these.

complex types together constitute the scalar types. Scalar types are also some- times called simple types.

Enumeration Types

Enumerations were introduced by Wirth in the design of Pascal. They facilitate the creation of readable programs, and allow the compiler to catch certain kinds of programming errors. An enumeration type consists of a set of named elements. In Pascal, one could write EXAMPLE 7.9

Enumerations in Pascal type weekday = (sun, mon, tue, wed, thu, fri, sat);

The values of an enumeration type are ordered, so comparisons are generallyvalid (mon < tue), and there is usually a mechanism to determine the predecessor or successor of an enumeration value (in Pascal, tomorrow := succ(today)). The

DESIGN & IMPLEMENTATION

7.4 Decimal types A few languages, notably Cobol and PL/I, provide a decimal type for ﬁxed- point representation of integer quantities. These types were designed primarily to exploit the binary-coded decimal (BCD) integer format supported by many traditional CISC machines. BCD devotes one nibble (four bits—half a byte) to each decimal digit. Machines that support BCD in hardware can perform arithmetic directly on the BCD representation of a number, without convert- ing it to and from binary form. This capability is particularly useful in business and ﬁnancial applications, which treat their data as both numbers and charac- ter strings. With the growth in on-line commerce, the past few years have seen renewed interest in decimal arithmetic. The 2008 revision of the IEEE 754 ﬂoating- point standard includes decimal ﬂoating-point types in 32-, 64-, and 128-bit lengths. These represent both the mantissa (signiﬁcant bits) and exponent in binary, but interpret the exponent as a power of ten, not a power of two. At a given length, values of decimal type have greater precision but smaller range than binary ﬂoating-point values. They are ideal for ﬁnancial calculations, be- cause they capture decimal fractions precisely. Designers hope the new stan- dard will displace existing incompatible decimal formats, not only in hardware but also in software libraries, thereby providing the same portability and pre- dictability that the original 754 standard provided for binary ﬂoating-point. C# includes a 128-bit decimal type that is compatible with the new stan- dard. Speciﬁcally, a C# decimal variable includes 96 bits of precision, a sign, and a decimal scaling factor that can vary between 10−28 and 1028. IBM, for which business and ﬁnancial applications have always been an important mar- ket, has included a hardware implementation of the standard (64- and 128-bit widths) in its pSeries RISC machines, beginning with the POWER6.

ordered nature of enumerations facilitates the writing of enumeration-controlled loops:

for today := mon to fri do begin ...

It also allows enumerations to be used to index arrays:

var daily_attendance : array [weekday] of integer; ■

An alternative to enumerations, of course, is simply to declare a collection of EXAMPLE 7.10

Enumerations as constants constants:

const sun = 0; mon = 1; tue = 2; wed = 3; thu = 4; fri = 5; sat = 6;

In C, the difference between the two approaches is purely syntactic:

enum weekday {sun, mon, tue, wed, thu, fri, sat};

is essentially equivalent to

typedef int weekday; const weekday sun = 0, mon = 1, tue = 2, wed = 3, thu = 4, fri = 5, sat = 6; ■

In Pascal and most of its descendants, however, the difference between an enu- meration and a set of integer constants is much more signiﬁcant: the enumer- ation is a full-ﬂedged type, incompatible with integers. Using an integer or an enumeration value in a context expecting the other will result in a type clash er- ror at compile time. Values of an enumeration type are typically represented by small integers, usu- EXAMPLE 7.11

Converting to and from enumeration type ally a consecutive range of small integers starting at zero. In many languages these ordinal values are semantically signiﬁcant, because built-in functions can be used to convert an enumeration value to its ordinal value, and sometimes vice versa. In Ada, these conversions employ the attributes pos and val: weekday‚pos(mon) = 1 and weekday‚val(1) = mon. ■ Several languages allow the programmer to specify the ordinal values of enu- meration types, if the default assignment is undesirable. In C, C++, and C#, one EXAMPLE 7.12

Distinguished values for enums could write

enum arm_special_regs {fp = 7, sp = 13, lr = 14, pc = 15};

(The intuition behind these values is explained in Sections C 5.4.5 and C 9.2.2.) In Ada this declaration would be written

In recent versions of Java one can obtain a similar effect by giving values an EXAMPLE 7.13

Emulating distinguished enum values in Java extra ﬁeld (here named register):

enum arm_special_regs { fp(7), sp(13), lr(14), pc(15); private final int register; arm_special_regs(int r) { register = r; } public int reg() { return register; } } ... int n = arm_special_regs.fp.reg(); ■

As noted in Section 3.5.2, Pascal and C do not allow the same element name to be used in more than one enumeration type in the same scope. Java and C# do, but the programmer must identify elements using fully qualiﬁed names: arm_special_regs.fp. Ada relaxes this requirement by saying that element names are overloaded; the type preﬁx can be omitted whenever the compiler can infer it from context (Example 3.22). C++ historically mirrored C in prohibiting duplicate enum names. C++11 introduced a new variety of enum that mirrors Java and C# (Example 3.23).

Subrange Types

Like enumerations, subranges were ﬁrst introduced in Pascal, and are found in many subsequent languages. A subrange is a type whose values compose a con- tiguous subset of the values of some discrete base type (also called the parent type). In Pascal and most of its descendants, one can declare subranges of inte- gers, characters, enumerations, and even other subranges. In Pascal, subranges EXAMPLE 7.14

Subranges in Pascal looked like this:

type test_score = 0..100; workday = mon..fri; ■

DESIGN & IMPLEMENTATION

7.5 Multiple sizes of integers The space savings possible with (small-valued) subrange types in Pascal and Ada is achieved in several other languages by providing more than one size of built-in integer type. C and C++, for example, support integer arithmetic on signed and unsigned variants of char, short, int, long, and long long types, with monotonically nondecreasing sizes.2

2 More speciﬁcally, C requires ranges for these types corresponding to lengths of at least 1, 2, 2, 4, and 8 bytes, respectively. In practice, one ﬁnds implementations in which plain ints are 2, 4, or 8 bytes long, including some in which they are the same size as shorts but shorter than longs, and some in which they are the same size as longs, and longer than shorts.

In Ada one would write EXAMPLE 7.15

Subranges in Ada type test_score is new integer range 0..100; subtype workday is weekday range mon..fri;

The range... portion of the deﬁnition in Ada is called a type constraint. In this example test_score is a derived type, incompatible with integers. The workday type, on the other hand, is a constrained subtype; workdays and weekdays can be more or less freely intermixed. The distinction between derived types and subtypes is a valuable feature of Ada; we will discuss it further in Section 7.2.1. ■

One could of course use integers to represent test scores, or a weekday to rep- resent a workday. Using an explicit subrange has several advantages. For one thing, it helps to document the program. A comment could also serve as docu- mentation, but comments have a bad habit of growing out of date as programs change, or of being omitted in the ﬁrst place. Because the compiler analyzes a subrange declaration, it knows the expected range of subrange values, and can generate code to perform dynamic semantic checks to ensure that no subrange variable is ever assigned an invalid value. These checks can be valuable debugging tools. In addition, since the compiler knows the number of values in the sub- range, it can sometimes use fewer bits to represent subrange values than it would need to use to represent arbitrary integers. In the example above, test_score values can be stored in a single byte. Most implementations employ the same bit patterns for integers and sub- EXAMPLE 7.16

Space requirements of subrange type ranges, so subranges whose values are large require large storage locations, even if the number of distinct values is small. The following type, for example,

type water_temperature = 273..373; (* degrees Kelvin *)

would be stored in at least two bytes. While there are only 101 distinct values in the type, the largest (373) is too large to ﬁt in a single byte in its natural encoding. (An unsigned byte can hold values in the range 0 . . 255; a signed byte can hold values in the range −128 . . 127.) ■

Composite Types

Nonscalar types are usually called composite types. They are generally created by applying a type constructor to one or more simpler types. Options, which we intro- duced in Example 7.6, are arguably the simplest composite types, serving only to add an extra “none of the above” to the values of some arbitrary base type. Other common composite types include records (structures), variant records (unions), arrays, sets, pointers, lists, and ﬁles. All but pointers and lists are easily described in terms of mathematical set operations (pointers and lists can be described math- ematically as well, but the description is less intuitive).

Records (structs) were introduced by Cobol, and have been supported by most languages since the 1960s. A record consists of collection of ﬁelds, each of

which belongs to a (potentially different) simpler type. Records are akin to mathematical tuples; a record type corresponds to the Cartesian product of the types of the ﬁelds. Variant records (unions) differ from “normal” records in that only one of a vari- ant record’s ﬁelds (or collections of ﬁelds) is valid at any given time. A variant record type is the disjoint union of its ﬁeld types, rather than their Cartesian product. Arrays are the most commonly used composite types. An array can be thought of as a function that maps members of an index type to members of a compo- nent type. Arrays of characters are often referred to as strings, and are often supported by special-purpose operations not available for other arrays. Sets, like enumerations and subranges, were introduced by Pascal. A set type is the mathematical powerset of its base type, which must often be discrete. A variable of a set type contains a collection of distinct elements of the base type. Pointers are l-values. A pointer value is a reference to an object of the pointer’s base type. Pointers are often but not always implemented as addresses. They are most often used to implement recursive data types. A type T is recursive if an object of type T may contain one or more references to other objects of type T. Lists, like arrays, contain a sequence of elements, but there is no notion of map- ping or indexing. Rather, a list is deﬁned recursively as either an empty list or a pair consisting of a head element and a reference to a sublist. While the length of an array must be speciﬁed at elaboration time in most (though not all) languages, lists are always of variable length. To ﬁnd a given element of a list, a program must examine all previous elements, recursively or iteratively, starting at the head. Because of their recursive deﬁnition, lists are fundamental to programming in most functional languages. Files are intended to represent data on mass-storage devices, outside the memory in which other program objects reside. Like arrays, most ﬁles can be concep- tualized as a function that maps members of an index type (generally integer) to members of a component type. Unlike arrays, ﬁles usually have a notion of current position, which allows the index to be implied implicitly in consec- utive operations. Files often display idiosyncrasies inherited from physical in- put/output devices. In particular, the elements of some ﬁles must be accessed in sequential order.

We will examine composite types in more detail in Chapter 8.

3CHECK YOUR UNDERSTANDING 1. What purpose(s) do types serve in a programming language?

2. What does it mean for a language to be strongly typed? Statically typed? What prevents, say, C from being strongly typed?

