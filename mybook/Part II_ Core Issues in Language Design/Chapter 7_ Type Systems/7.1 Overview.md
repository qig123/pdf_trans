# 7.1 Overview

**298**
Chapter 7* Type Systems*

to drive important performance optimizations. As a simple example, recall the
**EXAMPLE** 7.3

Types as a source of “may
alias” information
concept of* aliases*, introduced in Section 3.5.1, and discussed in Sidebar 3.7.
If a program performs an assignment through a pointer, the compiler may be
able to infer that objects of unrelated types cannot possibly be affected; their
values can safely remain in registers, even if loaded prior to the assignment. ■

Section 7.1 looks more closely at the meaning and purpose of types. It presents
some basic deﬁnitions, and introduces the notions of polymorphism and orthog-
onality. Section 7.2 takes a closer look at type checking; in particular, it considers
*type equivalence* (when can we say that two types are the same?),* type compatibility*
(when can we use a value of a given type in a given context?), and* type inference*
(how do we deduce the type of an expression from the types of its components
and that of the surrounding context?).
As an example of both polymorphism and sophisticated inference, Sec-
tion 7.2.4 surveys the type system of ML, which combines, to a large extent, the
efﬁciency and early error reporting of compilation with the convenience and ﬂex-
ibility of interpretation. We continue the study of polymorphism in Section 7.3,
with a particular emphasis on* generics*, which allow a body of code to be param-
eterized explicitly for multiple types. Finally, in Section 7.4, we consider what
it means to compare two complex objects for equality, or to assign one into the
other. In Chapter 8 we will consider syntactic, semantic, and pragmatic issues
for some of the most important* composite* types: records, arrays, strings, sets,
pointers, lists, and ﬁles.
## 7.1

**Overview**
```
Computer hardware can interpret bits in memory in several different ways: as in-
structions, addresses, characters, and integer and ﬂoating-point numbers of var-
ious lengths. The bits themselves, however, are untyped: the hardware on most
machines makes no attempt to keep track of which interpretations correspond to
which locations in memory. Assembly languages reﬂect this lack of typing: op-
erations of any kind can be applied to values in arbitrary locations. High-level
languages, by contrast, almost always associate types with values, to provide the
contextual information and error checking alluded to above.
Informally, a type system consists of (1) a mechanism to deﬁne types and asso-
ciate them with certain language constructs, and (2) a set of rules for type equiv-
alence, type compatibility, and type inference. The constructs that must have types
are precisely those that have values, or that can refer to objects that have val-
ues. These constructs include named constants, variables, record ﬁelds, param-
eters, and sometimes subroutines; literal constants (e.g., 17, 3.14, "foo"); and
more complicated expressions containing these. Type equivalence rules deter-
mine when the types of two values are the same. Type compatibility rules deter-
mine when a value of a given type can be used in a given context. Type inference
rules deﬁne the type of an expression based on the types of its constituent parts or
```

7.2 Dynamic typing
The growing popularity of scripting languages has led a number of promi-
nent software developers to publicly question the value of static typing. They
ask: given that we can’t check everything at compile time, how much pain is it
worth to check the things we can? As a general rule, it is easier to write type-
correct code than to prove that we have done so, and static typing requires
such proofs. As type systems become more complex (due to object orienta-
tion, generics, etc.), the complexity of static typing increases correspondingly.
Anyone who has written extensively in Ada or C++ on the one hand, and in
Python or Scheme on the other, cannot help but be struck at how much easier
it is to write code, at least for modest-sized programs, without complex type
declarations. Dynamic checking incurs some run-time overhead, of course,
and may delay the discovery of bugs, but this is increasingly seen as insigniﬁ-
cant in comparison to the potential increase in human productivity. An inter-
mediate position, epitomized by the ML family of languages but increasingly
adopted (in limited form) by others, retains the requirement that types be stat-
ically known, but relies on the compiler to infer them automatically, without
the need for some (or—in the case of ML—most) explicit declarations. We
will discuss this topic more in Section 7.2.3. Static and dynamic typing and
the role of inference promise to provide some of the most interesting language
debates of the coming decade.

```
var dummy : symbol_table_index;
...
dummy := insert_in_symbol_table(bar);
■
```

```
As another example of orthogonality, consider the common need to “erase” the
value of a variable—to indicate that it does not hold a valid value of its type. For
pointer types, we can often use the value null. For enumerations, we can add an
extra “none of the above” alternative to the set of possible values. But these two
techniques are very different, and they don’t generalize to types that already make
use of all available bit patterns in the underlying implementation.
To address the need for “none of the above” in a more orthogonal way, many
EXAMPLE 7.6
```

```
Option types in OCaml
functional languages—and some imperative languages as well—provide a special
type constructor, often called Option or Maybe. In OCaml, we can write
```

```
let divide n d : float option =
(* n and d are parameters *)
match d with
(* "float option" is the return type *)
| 0. -> None
| _
-> Some (n /. d);;
(* underscore means "anything else" *)
```

```
let show v : string =
match v with
| None
-> "??"
| Some x -> string_of_float x;;
```

```
Here function divide returns None if asked to divide by zero; otherwise it returns
Some x, where x is the desired quotient. Function show returns either "??" or
the string representation of x, depending on whether parameter v is None or
Some x.
■
```

In Pascal and most of its descendants, however, the difference between an enu-
meration and a set of integer constants is much more signiﬁcant: the enumer-
ation is a full-ﬂedged type, incompatible with integers. Using an integer or an
enumeration value in a context expecting the other will result in a type clash er-
ror at compile time.
Values of an enumeration type are typically represented by small integers, usu-
**EXAMPLE** 7.11

```
Converting to and from
enumeration type
ally a consecutive range of small integers starting at zero. In many languages these
ordinal values are semantically signiﬁcant, because built-in functions can be used
to convert an enumeration value to its ordinal value, and sometimes vice versa. In
Ada, these conversions employ the attributes pos and val: weekday‚pos(mon)
= 1 and weekday‚val(1) = mon.
■
Several languages allow the programmer to specify the ordinal values of enu-
meration types, if the default assignment is undesirable. In C, C++, and C#, one
EXAMPLE 7.12
```

Distinguished values for
enums
could write

```
enum arm_special_regs {fp = 7, sp = 13, lr = 14, pc = 15};
```

(The intuition behind these values is explained in Sections C 5.4.5 and C 9.2.2.)
In Ada this declaration would be written

```
type arm_special_regs is (fp, sp, lr, pc);
-- must be sorted
for arm_special_regs use (fp => 7, sp => 13, lr => 14, pc => 15);
■
```

