# 10.4 Dynamic Method Binding

10.4 Dynamic Method Binding
**505**

```
In modern C++ code, storage management is often facilitated through the use of
smart pointers (Section 8.5.3). These arrange, in the destructor for a pointer, to
determine whether any other pointers to the same object continue to exist—and
if not, to reclaim that pointed-to object.
■
In languages with automatic garbage collection, there is much less need for
destructors. In fact, the entire idea of destruction is suspect in a garbage-collected
language, because the programmer has little or no control over when an object is
going to be destroyed. Java and C# allow the programmer to declare a finalize
method that will be called immediately before the garbage collector reclaims the
space for an object, but the feature is not widely used.
```

```
3CHECK YOUR UNDERSTANDING
23. Does a constructor allocate space for an object? Explain.
24. What is a metaclass in Smalltalk?
```

25. Why is object initialization simpler in a language with a reference model of
variables (as opposed to a value model)?
26. How does a C++ (or Java or C#) compiler tell which constructor to use for a
given object? How does the answer differ for Eiffel and Smalltalk?
27. What is* escape analysis*? Describe why it might be useful in a language with a
reference model of variables.
28. Summarize the rules in C++ that determine the order in which constructors
are called for a class, its base class(es), and the classes of its ﬁelds. How are
these rules simpliﬁed in other languages?

29. Explain the difference between initialization and assignment in C++.
30. Why does C++ need destructors more than Eiffel does?

## 10.4

**Dynamic Method Binding**
One of the principal consequences of inheritance/type extension is that a derived
class* D* has all the members—data and subroutines—of its base class* C*. As long
as* D* does not hide any of the publicly visible members of* C* (see Exercise 10.15),
it makes sense to allow an object of class* D* to be used in any context that expects
an object of class* C*: anything we might want to do to an object of class* C* we can
also do to an object of class* D*. In other words, a derived class that does not hide
any publicly visible members of its base class is a* subtype* of that base class.
The ability to use a derived class in a context that expects its base class is called
*subtype polymorphism*. If we imagine an administrative computing system for a
**EXAMPLE** 10.37

```
Derived class objects in a
base class context
university, we might derive classes student and professor from class person:
```

```
As with other forms of polymorphism, we depend on the fact that print_mail-
ing_label uses only those features of its formal parameter that all actual param-
eters will have in common.
■
But now suppose that we have redeﬁned print_mailing_label in each of
EXAMPLE 10.38
```

```
Static and dynamic method
binding
the two derived classes. We might, for example, want to encode certain infor-
mation (student’s year in school, professor’s home department) in the corner
of the label.
Now we have multiple versions of our subroutine—student::
print_mailing_label and professor::print_mailing_label, rather than
the single, polymorphic person::print_mailing_label.
Which version we
will get depends on the object:
```

```
s.print_mailing_label();
// student::print_mailing_label(s)
p.print_mailing_label();
// professor::print_mailing_label(p)
```

But what about

```
x->print_mailing_label();
// ??
y->print_mailing_label();
// ??
```

```
Does the choice of the method to be called depend on the types of the variables x
and y, or on the classes of the objects s and p to which those variables refer?
■
The ﬁrst option (use the type of the reference) is known as static method bind-
ing. The second option (use the class of the object) is known as dynamic method
binding. Dynamic method binding is central to object-oriented programming.
Imagine, for example, that our administrative computing program has created
a list of persons who have overdue library books. The list may contain both
students and professors. If we traverse the list and print a mailing label for
each person, dynamic method binding will ensure that the correct printing rou-
tine is called for each individual. In this situation the deﬁnitions in the derived
classes are said to override the deﬁnition in the base class.
```

a

b

w
c

bar’s vtable

foo::l

foo::n
bar::s

bar::t

bar::m
code pointers

foo::k


![Figure 10.4 Implementation of...](images/page_543_vector_354.png)
*Figure 10.4 Implementation of single inheritance. As in Figure 10.3, the representation of object B begins with the address of its class’s vtable. The ﬁrst four entries in the table represent the same members as they do for foo, except that one—m—has been overridden and now contains the address of the code for a different subroutine. Additional ﬁelds of bar follow the ones inherited from foo in the representation of B; additional virtual methods follow the ones inherited from foo in the vtable of class bar.*

r1 := f
r2 :=* ∗*r1
–– vtable address
r2 :=* ∗*(r2 + (3−1) × 4)
–– assuming 4 = sizeof (address)
call* ∗*r2

```
On a typical modern machine this calling sequence is two instructions (both of
which access memory) longer than a call to a statically identiﬁed method. The
extra overhead can be avoided whenever the compiler can deduce the type of the
relevant object at compile time. The deduction is trivial for calls to methods of
object-valued variables (as opposed to references and pointers).
■
If bar is derived from foo, we place its additional ﬁelds at the end of the
EXAMPLE 10.46
```

```
Implementation of single
inheritance
“record” that represents it. We create a vtable for bar by copying the vtable for
foo, replacing the entries of any virtual methods overridden by bar, and append-
ing entries for any virtual methods introduced in bar (see Figure 10.4).
If we
have an object of class bar we can safely assign its address into a variable of type
foo*:
```

