# 10.11 Bibliographic Notes

10.11 Bibliographic Notes
**529**

```
storage management. Under what circumstances should one delete the el-
ements of a list when deleting the list itself? What should the destructor for
list_node do? Should it delete its data member? Should it recursively
delete node next?
10.33
The discussion in this chapter has focused on the classic “class-based” ap-
proach to object-oriented programming languages, pioneered by Simula
and Smalltalk. There is an alternative, “object-based” approach that dis-
penses with the notion of class. In object-based programming, methods
are directly associated with objects, and new objects are created using ex-
isting objects as prototypes. Learn about Self, the canonical object-based
programming language, and JavaScript, the most widely used. What do
you think of their approach? How does it compare to the class-based al-
ternative? You may ﬁnd it helpful to read the coverage of JavaScript in
Section 14.4.4.
10.34
As described in Section C 5.5.1, performance on pipelined processors de-
pends critically on the ability of the hardware to successfully predict the
outcome of branches, so that processing of subsequent instructions can
begin before processing of the branch has completed. In object-oriented
programs, however, knowing the outcome of a branch is not enough: be-
cause branches are so often dispatched through vtables, one must also pre-
dict the destination. Learn how branch prediction works in one or more
modern processors. How well do these processors handle object-oriented
programs?
10.35
Explore the implementation of mix-in inheritance in a just-in-time (native
code) Java compiler. Does it follow the strategy of Section 10.5? How
efﬁcient is it?
10.36
Explore the implementation of mix-in inheritance in Ruby. How does it
differ from that of Java?
10.37
Learn about type hierarchy analysis and type propagation, which can some-
times be used to infer the concrete type of objects at compile time, al-
lowing the compiler to generate direct calls to methods, rather than indi-
recting through vtables. How effective are these techniques? What frac-
tion of method calls are they able to optimize in typical benchmarks?
What are their limitations? (You might start with the papers of Bacon
and Sweeney [BS96] and Diwan et al. [DMM96].)
```

10.38–10.39 In More Depth.
## 10.11

**Bibliographic Notes**
Appendix A contains bibliographic citations for the various languages discussed
in this chapter, including Simula, Smalltalk, C++, Eiffel, Java, C#, Modula-3,
Oberon, Ada 95, Fortran 2003, Python, Ruby, Objective-C, Swift, Go, OCaml,

