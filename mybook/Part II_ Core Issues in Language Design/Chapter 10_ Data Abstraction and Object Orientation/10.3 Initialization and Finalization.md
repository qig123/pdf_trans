10.3 Initialization and Finalization
495
3CHECK YOUR UNDERSTANDING
12. What is meant by an opaque export from a module?
13. What are private types in Ada?
14. Explain the signiﬁcance of the this parameter in object-oriented languages.
15. How do Java and C# make do without explicit class headers?
16. Explain the distinctions among private, protected, and public class
members in C++.
17. Explain the distinctions among private, protected, and public base
classes in C++.
18. Describe the notion of selective availability in Eiffel.
19. How do the rules for member name visibility in Smalltalk and Objective-C
differ from the rules of most other object-oriented languages?
20. How do inner classes in Java differ from most other nested classes?
21. Describe the key design difference between the object-oriented features of
Smalltalk, Eiffel, and C++ on the one hand, and Ada, CLOS, and Fortran
on the other.
22. What are extension methods in C#? What purpose do they serve?
10.3
Initialization and Finalization
In Section 3.2 we deﬁned the lifetime of an object to be the interval during which
it occupies space and can thus hold data. Most object-oriented languages provide
some sort of special mechanism to initialize an object automatically at the begin-
ning of its lifetime. When written in the form of a subroutine, this mechanism is
known as a constructor. Though the name might be thought to imply otherwise,
a constructor does not allocate space; it initializes space that has already been al-
located. A few languages provide a similar destructor mechanism to ﬁnalize an
object automatically at the end of its lifetime. Several important issues arise:
Choosing a constructor: An object-oriented language may permit a class to have
zero, one, or many distinct constructors. In the latter case, different construc-
tors may have different names, or it may be necessary to distinguish among
them by number and types of arguments.
References and values: If variables are references, then every object must be cre-
ated explicitly, and it is easy to ensure that an appropriate constructor is called.
If variables are values, then object creation can happen implicitly as a result of
elaboration. In this latter case, the language must either permit objects to begin
496
Chapter 10 Data Abstraction and Object Orientation
their lifetime uninitialized, or it must provide a way to choose an appropriate
constructor for every elaborated object.
Execution order: When an object of a derived class is created in C++, the com-
piler guarantees that the constructors for any base classes will be executed, out-
ermost ﬁrst, before the constructor for the derived class. Moreover, if a class
has members that are themselves objects of some class, then the constructors
for the members will be called before the constructor for the object in which
they are contained. These rules are a source of considerable syntactic and se-
mantic complexity: when combined with multiple constructors, elaborated
objects, and multiple inheritance, they can sometimes induce a complicated
sequence of nested constructor invocations, with overload resolution, before
control even enters a given scope. Other languages have simpler rules.
Garbage collection: Most object-oriented languages provide some sort of con-
structor mechanism. Destructors are comparatively rare. Their principal pur-
pose is to facilitate manual storage reclamation in languages like C++. If the
language implementation collects garbage automatically, then the need for de-
structors is greatly reduced.
In the remainder of this section we consider these issues in more detail.
10.3.1 Choosing a Constructor
Smalltalk, Eiffel, C++, Java, and C# all allow the programmer to specify more
than one constructor for a given class. In C++, Java, and C#, the constructors
behave like overloaded subroutines: they must be distinguished by their numbers
and types of arguments. In Smalltalk and Eiffel, different constructors can have
EXAMPLE 10.25
Naming constructors in
Eiffel
different names; code that creates an object must name a constructor explicitly.
In Eiffel one might say
class COMPLEX
creation
new_cartesian, new_polar
feature {ANY}
x, y : REAL
new_cartesian(x_val, y_val : REAL) is
do
x := x_val; y := y_val
end
new_polar(rho, theta : REAL) is
do
x := rho * cos(theta)
y := rho * sin(theta)
end
-- other public methods
10.3 Initialization and Finalization
497
feature {NONE}
-- private methods
end -- class COMPLEX
...
a, b : COMPLEX
...
!!b.new_cartesian(0, 1)
!!a.new_polar(1, pi/2)
The !! operator is Eiffel’s equivalent of new. Because class COMPLEX speciﬁed
constructor (“creator”) methods, the compiler will insist that every use of !!
specify a constructor name and arguments. There is no straightforward analog
of this code in C++; the fact that both constructors take two real arguments
means that they could not be distinguished by overloading.
■
Smalltalk resembles Eiffel in the use of multiple named constructors, but it dis-
tinguishes more sharply between operations that pertain to an individual object
and operations that pertain to a class of objects. Smalltalk also adopts an anthro-
pomorphic programming model in which every operation is seen as being exe-
cuted by some speciﬁc object in response to a request (a “message”) from some
other object. Since it makes little sense for an object O to create itself, O must
be created by some other object (call it C) that represents O’s class. Of course,
because C is an object, it must itself belong to some class. The result of this rea-
soning is a system in which each class deﬁnition really introduces a pair of classes
and a pair of objects to represent them. Objective-C and CLOS have similar dual
hierarchies, as do Python and Ruby.
Consider, for example, the standard class named Date. Corresponding to
EXAMPLE 10.26
Metaclasses in Smalltalk
Date is a single object (call it D) that performs operations on behalf of the class.
In particular, it is D that creates new objects of class Date. Because only objects
execute operations (classes don’t), we don’t really need a name for D; we can sim-
ply use the name of the class it represents:
todaysDate <- Date today
This code causes D to execute the today constructor of class Date, and assigns a
reference to the newly created object into a variable named todaysDate.
So what is the class of D ? It clearly isn’t Date, because D represents class Date.
Smalltalk says that D is an object (in fact the only object) of the metaclass Date
class. For technical reasons, it is also necessary for Date class to be represented
by an object. To avoid an inﬁnite regression, all objects that represent metaclasses
are instances of a single class named Metaclass.
■
A few historic languages—notably Modula-3 and Oberon— provided no con-
structors at all: the programmer had to initialize everything explicitly. Ada 95
498
Chapter 10 Data Abstraction and Object Orientation
supports automatic calls to constructors and destructors (Initialize and
Finalize routines) only for objects of types derived from the standard library
type Controlled.
10.3.2 References and Values
Many object-oriented languages, including Simula, Smalltalk, Python, Ruby, and
Java, use a programming model in which variables refer to objects. A few lan-
guages, including C++ and Ada, allow a variable to have a value that is an object.
Eiffel uses a reference model by default, but allows the programmer to specify that
certain classes should be expanded, in which case variables of those classes will
use a value model. In a similar vein, C# and Swift use struct to deﬁne types
whose variables are values, and class to deﬁne types whose variables are refer-
ences.
With a reference model for variables, every object is created explicitly, and it
is easy to ensure that an appropriate constructor is called. With a value model
for variables, object creation can happen implicitly as a result of elaboration. In
Ada, which doesn’t provide automatic calls to constructors by default, elaborated
objects begin life uninitialized, and it is possible to accidentally attempt to use a
variable before it has a value. In C++, the compiler ensures that an appropriate
constructor is called for every elaborated object, but the rules it uses to identify
constructors and their arguments can sometimes be confusing.
If a C++ variable of class type foo is declared with no initial value, then the
EXAMPLE 10.27
Declarations and
constructors in C++
compiler will call foo’s zero-argument constructor (if no such constructor exists,
but other constructors do, then the declaration is a static semantic error—a call
to a nonexistent subroutine):
foo b;
// calls foo::foo()
DESIGN & IMPLEMENTATION
10.3 The value/reference tradeoff
The reference model of variables is arguably more elegant than the value
model, particularly for object-oriented languages, but generally requires that
objects be allocated from the heap, and imposes (in the absence of compiler
optimizations) an extra level of indirection on every access. The value model
tends to be more efﬁcient, but makes it difﬁcult to control initialization. In
languages with a reference model (including Java), an optimization known
as escape analysis can sometimes allow the compiler to determine that refer-
ences to a given object will always be contained within (will never escape) a
given method. In this case the object can be allocated in the method’s stack
frame, avoiding the overhead of heap allocation and, more signiﬁcantly, even-
tual garbage collection.
10.3 Initialization and Finalization
499
If the programmer wants to call a different constructor, the declaration must spec-
ify constructor arguments to drive overload resolution:
foo b(10, 'x');
// calls foo::foo(int, char)
foo c{10, 'x'};
// alternative syntax in C++11
■
The most common argument list consists of a single object, of the same type as
EXAMPLE 10.28
Copy constructors
the object being declared:
foo a;
...
foo b(a);
// calls foo::foo(foo&)
foo c{a};
// alternative syntax
Usually the programmer’s intent is to declare a new object whose initial value is
“the same as” that of the existing object. In this case it may be more natural to
write
foo a;
// calls foo::foo()
...
foo b = a;
// calls foo::foo(foo&)
In recognition of this intent, a single-argument constructor (of matching type) is
sometimes called a copy constructor. It is important to realize that the equals sign
(=) in this most recent declaration of b indicates initialization, not assignment.
The effect is exactly the same as in the declarations foo b(a) or foo b{a}. It is
not the same as in the similar code fragment
foo a, b;
// calls foo::foo() twice
...
b = a;
// calls foo::operator=(foo&)
Here a and b are initialized with the zero-argument constructor, and the later
use of the equals sign indicates assignment, not initialization. The distinction is a
common source of confusion in C++ programs. It arises from the combination
of a value model of variables and an insistence that every elaborated object be
initialized by a constructor. The rules are simpler in languages that use a uniform
value model for class-type variables: if every object is created by an explicit call
to new or its equivalent, each such call provides the “hook” at which to call a
constructor.
■
In C++, the requirement that every object be constructed (and likewise de-
EXAMPLE 10.29
Temporary objects
structed) applies not only to objects with names but also to temporary objects.
The following, for example, entails a call to both the string(const char*) con-
structor and the ~string() destructor:
cout << string("Hi, Mom").length();
// prints 7
500
Chapter 10 Data Abstraction and Object Orientation
The destructor is called at the end of the output statement: the temporary object
behaves as if its scope were just the line shown here.
In a similar vein, the following entails not only two calls to the default string
constructor (to initialize a and b) and a call to string::operator+(), but also a
constructor call to initialize the temporary object returned by operator+()—the
object whose length is then queried by the caller:
string a, b;
...
(a + b).length();
As is customary for values returned from functions, the space for the temporary
object is likely to be allocated (at a statically known offset) in the stack frame of
the caller—that is, in the routine that calls both operator+() and length(). ■
Now consider the code for some function f, returning a value of class type
EXAMPLE 10.30
Return value optimization
foo. If instances of foo are too big to ﬁt in a register, the compiler will arrange
for f’s caller to pass an extra, hidden parameter that speciﬁes the location into
which f should construct the return value. If the return statement itself creates a
temporary object—
return foo( args )
—that object can easily be constructed at the caller-speciﬁed address. But suppose
f’s source looks more like this:
foo rtn;
...
// complex code to initialize the fields of rtn
return rtn;
Because we have used a named, non-temporary variable, the compiler may need
to invoke a copy constructor to copy rtn into the location in the caller’s frame.4
It is also permitted, however (if other return statements don’t have conﬂicting
needs), to construct rtn itself at the caller-speciﬁed location from the outset, and
to elide the copy operation. This option is known as return value optimization. It
turns out to signiﬁcantly improve the performance of many C++ programs.
In Example 10.29, the value a + b was passed immediately to length(), allow-
ing the compiler to use the same temporary object in the caller’s frame as both the
return value from operator+() and the this argument for length(). In other
programs the compiler may need to invoke a copy constructor after a function
returns:
foo c;
...
c = f( args );
4
The compiler may also use a move constructor (“R-value References,” Section 9.3.1), if available.
To avoid excess confusion, we limit the discussion here to copy constructors.
10.3 Initialization and Finalization
501
Here the location of c cannot be passed as the hidden parameter to f unless the
compiler is able to prove that c’s value will not be used (via an alias, perhaps)
during the call. The bottom line: returning an object from a function in C++
may entail zero, one, or two invocations of the return type’s copy constructor, de-
pending on whether the compiler is able to optimize either or both of the return
statement and the subsequent use in the caller.
■
While Eiffel has both dynamically allocated and expanded objects, its strategy
EXAMPLE 10.31
Eiffel constructors and
expanded objects
with regard to constructors is somewhat simpler. Speciﬁcally, every variable is
initialized to a default value. For built-in types (integer, ﬂoating-point, character,
etc.), which are always expanded, the default values are all zero. For references
to objects, the default value is void (null). For variables of expanded class types,
the defaults are applied recursively to members. As noted above, new objects are
created by invoking Eiffel’s !! creation operator:
!!var.creator(args)
where var is a variable of some class type T and creator is a constructor for
T. In the common case, var will be a reference, and the creation operator will
allocate space for an object of class T and then call the object’s constructor. This
same syntax is permitted, however, when T is an expanded class type, in which
case var will actually be an object, rather than a reference. In this case, the !!
DESIGN & IMPLEMENTATION
10.4 Initialization and assignment
Issues around initialization and assignment in C++ can sometimes have a sur-
prising effect on performance—and potentially on program behavior as well.
As noted in the body of the text, “foo a = b” is likely to be more efﬁcient than
“foo a; a = b”—and may lead to different behavior if foo’s copy constructor
and assignment operator have not been designed to be semantically equivalent.
Similar issues may arise with operator+() and operator+=(), operator*()
and operator*=(), and the other analogous pairs of operations.
Similar issues may also arise when making function calls. A parameter that
is passed by value typically induces an implicit call to a copy constructor. A
parameter that is passed by reference does not, and may be equally acceptable,
especially if declared to be const. (In C++11, the value parameter may also
use a move constructor.) From a performance perspective, the cost of a copy or
more constructor may or may not be outweighed by the cost of indirection and
the possibility that code improvement may be inhibited by potential aliases.
From a behavioral perspective, calls to different constructors and operators,
induced by tiny source code changes, can be a source of very subtle bugs. C++
programmers must exercise great care to avoid side effects in constructors and
to ensure that all intuitively equivalent methods have identical semantics in
practice. Even then, performance tradeoffs may be very hard to predict.
502
Chapter 10 Data Abstraction and Object Orientation
operator simply passes to the constructor (a reference to) the already-allocated
object.
■
10.3.3 Execution Order
As we have seen, C++ insists that every object be initialized before it can be used.
Moreover, if the object’s class (call it B) is derived from some other class (call it
A), C++ insists on calling an A constructor before calling a B constructor, so that
the derived class is guaranteed never to see its inherited ﬁelds in an inconsistent
state. When the programmer creates an object of class B (either via declaration or
with a call to new), the creation operation speciﬁes arguments for a B constructor.
These arguments allow the C++ compiler to resolve overloading when multiple
constructors exist. But where does the compiler obtain arguments for the A con-
structor? Adding them to the creation syntax (as Simula did) would be a clear
violation of abstraction. The answer adopted in C++ is to allow the header of the
EXAMPLE 10.32
Speciﬁcation of base class
constructor arguments
constructor of a derived class to specify base class constructor arguments:
foo::foo( foo params ) : bar( bar args ) {
...
Here foo is derived from bar. The list foo params consists of formal parameters
for this particular foo constructor. Between the parameter list and the opening
brace of the subroutine deﬁnition is a “call” to a constructor for the base class
bar. The arguments to the bar constructor can be arbitrarily complicated ex-
pressions involving the foo parameters. The compiler will arrange to execute the
bar constructor before beginning execution of the foo constructor.
■
Similar syntax allows the C++ programmer to specify constructor arguments
EXAMPLE 10.33
Speciﬁcation of member
constructor arguments
or initial values for members of the class. In Figure 10.1, for example, we could
have used this syntax to initialize prev, next, head_node, and val in the con-
structor for list_node:
DESIGN & IMPLEMENTATION
10.5 Initialization of “expanded” objects
C++ inherits from C a design philosophy that emphasizes execution speed,
minimal run-time support, and suitability for “systems” programming, in
which the programmer needs to be able to write code whose mapping to as-
sembly language is straightforward and self-evident. The use of a value model
for variables in C++ is thus more than an attempt to be backward compatible
with C; it reﬂects the desire to allocate variables statically or on the stack when-
ever possible, to avoid the overhead of dynamic allocation, deallocation, and
frequent indirection. In later sections we shall see several other manifestations
of the C++ philosophy, including manual storage reclamation (Section 10.3.4)
and static method binding (Section 10.4.1).
10.3 Initialization and Finalization
503
list_node() : prev(this), next(this), head_node(this), val(0) {
// empty body -- nothing else to do
}
Given that all of these members have simple (pointer or integer) types, there will
be no signiﬁcant difference in the generated code. But suppose we have members
that are themselves objects of some nontrivial class:
class foo : bar {
mem1_t member1;
// mem1_t and
mem2_t member2;
// mem2_t are classes
...
}
foo::foo( foo params ) : bar( bar args ), member1(mem1 init val ),
member2( mem2 init val ) {
...
Here the use of embedded calls in the header of the foo constructor causes the
compiler to call the copy constructors for the member objects, rather than call-
ing the default (zero-argument) constructors, followed by operator= within the
body of the constructor. Both semantics and performance may be different as a
result.
■
When the code of one constructor closely resembles that of another, C++ also
EXAMPLE 10.34
Constructor forwarding
allows the member-and-base-class-initializer syntax to be used to forward one
constructor to another. In Example 10.4 we introduced a new integer-parameter
constructor for the list_node class of Figure 10.1. Given the existence of this
new constructor, we could re-write the default (no-parameter) constructor as
class list_node {
...
list_node() : list_node(0) { }
// forward to (int) constructor
Any declaration of a list_node that does not provide an argument will now call
the integer-parameter constructor with an argument of 0.
■
Like C++, Java insists that a constructor for a base class be called before the
EXAMPLE 10.35
Invocation of base class
constructor in Java
constructor for a derived class. The syntax is a bit simpler, however; the initial
line of the code for the derived class constructor may consist of a “call” to the
base class constructor:
super( args );
(C# has a similar mechanism.) As noted in Section 10.1, super is a Java keyword
that refers to the base class of the class in whose code it appears. If the call to
super is missing, the Java compiler automatically inserts a call to the base class’s
zero-argument constructor (in which case such a constructor must exist).
■
504
Chapter 10 Data Abstraction and Object Orientation
Because Java uses a reference model uniformly for all objects, any class mem-
bers that are themselves objects will actually be references, rather than “expanded”
objects (to use the Eiffel term). Java simply initializes such members to null. If
the programmer wants something different, he or she must call new explicitly
within the constructor of the surrounding class. Smalltalk and (in the common
case) C# and Eiffel adopt a similar approach. In C#, members whose types are
structs are initialized by setting all of their ﬁelds to zero or null. In Eiffel, if a
class contains members of an expanded class type, that type is required to have
a single constructor, with no arguments; the Eiffel compiler arranges to call this
constructor when the surrounding object is created.
Smalltalk, Eiffel, CLOS, and Objective-C are all more lax than C++ regarding
the initialization of base classes. The compiler or interpreter arranges to call the
constructor (creator, initializer) for each newly created object automatically, but
it does not arrange to call constructors for base classes automatically; all it does is
initialize base class data members to default (zero or null) values. If the derived
class wants different behavior, its constructor(s) must call a constructor for the
base class explicitly.
10.3.4 Garbage Collection
When a C++ object is destroyed, the destructor for the derived class is called ﬁrst,
followed by those of the base class(es), in reverse order of derivation. By far the
most common use of destructors in C++ is manual storage reclamation. Consider
EXAMPLE 10.36
Reclaiming space with
destructors
again the queue class of Figure10.8. Because our queue is derived from the list
of Figure 10.2, its default destructor will call the explicit ~list destructor, which
will throw an exception if the list (i.e., the queue) is nonempty. Suppose instead
that we wish to allow the destruction of a nonempty queue, and simply clean up
its space. Since queue nodes are created by enqueue, and are used only within the
code of the queue itself, we can safely arrange for the queue’s destructor to delete
any nodes that remain:
~queue() {
while (!empty()) {
list_node* p = contents.head();
p->remove();
delete p;
}
}
Alternatively, since dequeue has already been designed to delete the node that
contained the dequeued element:
~queue() {
while (!empty()) {
int v = dequeue();
}
}
