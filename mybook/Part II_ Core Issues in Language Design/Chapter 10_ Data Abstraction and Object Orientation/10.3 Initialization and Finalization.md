# 10.3 Initialization and Finalization

10.3 Initialization and Finalization
**495**

```
3CHECK YOUR UNDERSTANDING
12. What is meant by an opaque export from a module?
13. What are private types in Ada?
```

```
14. Explain the signiﬁcance of the this parameter in object-oriented languages.
15. How do Java and C# make do without explicit class headers?
16. Explain the distinctions among private, protected, and public class
members in C++.
```

```
17. Explain the distinctions among private, protected, and public base
classes in C++.
```

18. Describe the notion of* selective availability* in Eiffel.
19. How do the rules for member name visibility in Smalltalk and Objective-C
differ from the rules of most other object-oriented languages?
20. How do* inner* classes in Java differ from most other nested classes?

21. Describe the key design difference between the object-oriented features of
Smalltalk, Eiffel, and C++ on the one hand, and Ada, CLOS, and Fortran
on the other.
22. What are* extension methods* in C#? What purpose do they serve?

## 10.3

**Initialization and Finalization**
In Section 3.2 we deﬁned the lifetime of an object to be the interval during which
it occupies space and can thus hold data. Most object-oriented languages provide
some sort of special mechanism to* initialize* an object automatically at the begin-
ning of its lifetime. When written in the form of a subroutine, this mechanism is
known as a* constructor*. Though the name might be thought to imply otherwise,
a constructor does not allocate space; it initializes space that has already been al-
located. A few languages provide a similar* destructor* mechanism to* ﬁnalize* an
object automatically at the end of its lifetime. Several important issues arise:

*Choosing a constructor:* An object-oriented language may permit a class to have
zero, one, or many distinct constructors. In the latter case, different construc-
tors may have different names, or it may be necessary to distinguish among
them by number and types of arguments.
*References and values:* If variables are references, then every object must be cre-
ated explicitly, and it is easy to ensure that an appropriate constructor is called.
If variables are values, then object creation can happen implicitly as a result of
elaboration. In this latter case, the language must either permit objects to begin

```
-- other public methods
```

```
Here a and b are initialized with the zero-argument constructor, and the later
use of the equals sign indicates assignment, not initialization. The distinction is a
common source of confusion in C++ programs. It arises from the combination
of a value model of variables and an insistence that every elaborated object be
initialized by a constructor. The rules are simpler in languages that use a uniform
value model for class-type variables: if every object is created by an explicit call
to new or its equivalent, each such call provides the “hook” at which to call a
constructor.
■
In C++, the requirement that every object be constructed (and likewise de-
EXAMPLE 10.29
```

```
Temporary objects
structed) applies not only to objects with names but also to temporary objects.
The following, for example, entails a call to both the string(const char*) con-
structor and the ~string() destructor:
```

```
cout << string("Hi, Mom").length();
// prints 7
```

