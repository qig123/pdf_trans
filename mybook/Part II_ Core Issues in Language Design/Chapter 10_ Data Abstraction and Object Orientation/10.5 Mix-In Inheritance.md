516
Chapter 10 Data Abstraction and Object Orientation
10.5
Mix-In Inheritance
When building an object-oriented system, it is often difﬁcult to design a perfect
inheritance tree, in which every class has exactly one parent. A cat may be an
animal, a pet, a family_member, or an object_of_affection. A widget in
the company database may be a sortable_object (from the reporting system’s
perspective), a graphable_object (from the window system’s perspective), or
a storable_object (from the ﬁle system’s perspective); how do we choose just
one?
In the general case, we could imagine allowing a class to have an arbitrary
number of parents, each of which could provide it with both ﬁelds and methods
(both abstract and concrete). This sort of “true” multiple inheritance is provided
by several languages, including C++, Eiffel, CLOS, OCaml, and Python; we will
consider it in Section 10.6. Unfortunately, it introduces considerable complexity
in both language semantics and run-time implementation. In practice, a more
limited mechanism, known as mix-in inheritance, is often all we really need.
Consider our widgets, for example. Odds are, the reporting system doesn’t
EXAMPLE 10.51
The motivation for
interfaces
really deﬁne what a widget is; it simply needs to be able to manipulate widgets in
certain well-deﬁned ways—to sort them, for example. Likewise, the windowing
system probably doesn’t need to provide any state or functionality for widgets; it
simply needs to be able to display them on a screen. To capture these sorts of re-
quirements, a language with mix-in inheritance allows the programmer to deﬁne
the interface that a class must provide in order for its objects to be used in certain
contexts. For widgets, the reporting system might deﬁne a sortable_object
interface; the window system might deﬁne a graphable_object interface; the
ﬁle system might deﬁne a storable_object interface. No actual functional-
ity would be provided by any of the interfaces: the designer of the widget class
would need to provide appropriate implementations.
■
In effect—as we noted in Section 10.4.2—an interface is a class containing only
abstract methods—no ﬁelds or method bodies. So long as it inherits from only
one “real” parent, a class can “mix in” an arbitrary number of interfaces. If a for-
mal parameter of a subroutine is declared to have an interface type, then any class
that implements (inherits from) that interface can be passed as the corresponding
actual parameter. The classes of objects that can legitimately be passed need not
have a common class ancestor.
In recent years, mix-ins have become a common approach—arguably the
dominant approach—to multiple inheritance. Though details vary from one lan-
guage to another, interfaces appear in Java, C#, Scala, Objective-C, Swift, Go,
Ada 2005, and Ruby, among others.
Elaborating on our widget example, suppose that we have been given general-
EXAMPLE 10.52
Mixing interfaces into a
derived class
purpose Java code that will sort objects according to some textual ﬁeld, display a
graphic representation of an object within a web browser window (hiding and
refreshing as appropriate), and store references to objects by name in a dictionary
data structure. Each of these capabilities would be represented by an interface.
10.5 Mix-In Inheritance
517
If we have already developed some complicated class of widget objects, we can
make use of the general-purpose code by mixing the appropriate interfaces into
classes derived from widget, as shown in Figure 10.6.
■
10.5.1 Implementation
In a language like Ruby, Objective-C, or Swift, which uses dynamic method
lookup, the methods of an interface can simply be added to the method dictio-
nary of any class that implements the interface. In any context that requires the
interface type, the usual lookup mechanism will ﬁnd the proper methods. In a
language with fully static typing, in which pointers to methods are expected to lie
at known vtable offsets, new machinery is required. The challenge boils down to
a need for multiple views of an object.
In Figure 10.6, method dictionary.insert expects a storable_object
EXAMPLE 10.53
view of its parameter—a way to ﬁnd the parameter’s get_stored_name method.
The get_stored_name method, however, is implementedby augmented_widget,
and will expect an augmented_widget view of its this parameter—a way to ﬁnd
the object’s ﬁelds and other methods. Given that augmented_widget implements
three different interfaces, there is no way that a single vtable can sufﬁce: its ﬁrst
entry can’t be the ﬁrst method of sortable_object, graphable_object, and
storable_object simultaneously.
The most common solution, shown in Figure 10.7, is to include three extra
vtable pointers in each augmented_widget object—one for each of the imple-
mented interfaces. For each interface view we can then use a pointer to the place
within the object where the corresponding vtable pointer appears. The offset of
that pointer from the beginning of the object is known as the “this correction”;
it is stored at the beginning of the vtable.
Suppose now that we wish to call dictionary.insert on an augmented_
widget object w, whose address is currently in register r1. The compiler, which
knows the offset c of w’s storable_object vtable pointer, will add c to r1 be-
fore passing it to insert. So far so good. What happens when insert calls
storable_object.get_stored_name?
Assuming that the storable_object
view of w is available in, say, register r1, the compiler will generate code that looks
something like this:
Compile-time
implementation of mix-in
inheritance
r2 := ∗r1
–– vtable address
r3 := ∗r2
–– this correction
r3 +:= r1
–– address of w
call ∗(r2+4)
–– method address
Here we have assumed that the this correction occupies the ﬁrst four bytes
of the vtable, and that the address of get_stored_name lies immediately af-
ter it, in the table’s ﬁrst regular slot. We have also assumed that this should
be passed in register r3, and that there are no other arguments. On a typi-
cal modern machine this code is two instructions (a load and a subtraction)
518
Chapter 10 Data Abstraction and Object Orientation
public class widget { ...
}
interface sortable_object {
String get_sort_name();
bool less_than(sortable_object o);
// All methods of an interface are automatically public.
}
interface graphable_object {
void display_at(Graphics g, int x, int y);
// Graphics is a standard library class that provides a context
// in which to render graphical objects.
}
interface storable_object {
String get_stored_name();
}
class named_widget extends widget implements sortable_object {
public String name;
public String get_sort_name() {return name;}
public bool less_than(sortable_object o) {
return (name.compareTo(o.get_sort_name()) < 0);
// compareTo is a method of the standard library class String.
}
}
class augmented_widget extends named_widget
implements graphable_object, storable_object {
...
// more data members
public void display_at(Graphics g, int x, int y) {
...
// series of calls to methods of g
}
public String get_stored_name() {return name;}
}
...
class sorted_list {
public void insert(sortable_object o) { ...
public sortable_object first() { ...
...
}
class browser_window extends Frame {
// Frame is the standard library class for windows.
public void add_to_window(graphable_object o) { ...
...
}
class dictionary {
public void insert(storable_object o) { ...
public storable_object lookup(String name) { ...
...
}


![Figure 10.6 Interface classes...](images/page_551_caption_Figure%2010.6%20Interface%20classes%20in%20Java.%20By%20implementing%20the%20sortable_object%20interface%20in%20named_widget.png)
*Figure 10.6 Interface classes in Java. By implementing the sortable_object interface in named_widget and the graphable_object and storable_object interfaces in augmented_ widget, we obtain the ability to pass objects of those classes to and from such routines as sorted_list.insert, browser_window.add_to_window, and dictionary.insert.*

10.5 Mix-In Inheritance
519
augmented_widget
object
vtable
widget view
augmented_
widget part
a
b
widget fields
sortable_object view
−a
c
sortable_
object part
name
graphable_object view
storable_object view
−b
graphable_
object part
−c
storable_
object part


![Figure 10.7 Implementation of...](images/page_552_caption_Figure%2010.7%20Implementation%20of%20mix-in%20inheritance.%20Objects%20of%20class%20augmented_widget%20con-%20tain%20four%20v.png)
*Figure 10.7 Implementation of mix-in inheritance. Objects of class augmented_widget con- tain four vtable addresses, one for the class itself (as in Figure 10.3), and three for the imple- mented interfaces. The view of the object that is passed to interface routines points directly at the relevant vtable pointer. The vtable then begins with a “this correction” offset, used to regenerate a pointer to the object itself.*

longer than the code required with single inheritance. Once it executes, however,
augmented_widget.get_stored_name will be running with exactly the param-
eter it expects: a reference to an augmented_widget object.
■
10.5.2 Extensions
The description of interfaces above reﬂects historical versions of Java, with one
omission: in addition to abstract methods, an interface can deﬁne static final
(constant) ﬁelds. Because such ﬁelds can never change, they introduce no run-
time complexity or overhead—the compiler can, effectively, expand them in place
wherever they are used.
Beginning with Java 8, interfaces have also been extended to allow static
and default methods, both of which are given bodies—code—in the declara-
tion of the interface. A static method, like a static final ﬁeld, introduces
no implementation complexity: it requires no access to object ﬁelds, so there is
no ambiguity about what view to pass as this—there is no this parameter. De-
fault methods are a bit more tricky. Their code is intended to be used by any
class that does not override it. This convention is particularly valuable for library
520
Chapter 10 Data Abstraction and Object Orientation
maintainers: it allows new methods to be added to an existing library interface
without breaking existing user code, which would otherwise have to be updated
to implement the new methods in any class that inherits from the interface.
Suppose, for example, that we are engaged in a localization project, which
EXAMPLE 10.54
Use of default methods
aims to adapt some existing code to multiple languages and cultures. In the
code of Figure 10.6, we might wish to add a new get_local_name method to
the storable_object interface. Given a reference to a storable_object, up-
dated user code could then call this new method, rather than get_stored_name,
to obtain a string appropriate for use in the local context. A concrete class that
inherits from storable_object, and that has been updated as part of the local-
ization project, might provide its own implementation of get_local_name. But
what about classes that haven’t been updated yet (or that may never be updated)?
These could leverage default methods to fall back on some general-purpose trans-
lation mechanism:
default String get_local_name() {
return backup_translation(get_stored_name());
}
To use the default, each concrete class that inherits from storable_object
would need to be recompiled, but its source code could remain unchanged.
■
Because a default method is deﬁned within the interface declaration, it can see
only the methods and (static) ﬁelds of the interface itself (along with any visible
names from surrounding scopes). In particular, it has no access to other mem-
bers of classes that inherit from the interface, and thus no need of an object view
that would allow it to ﬁnd those members. At the same time, the method does
require access to the object’s interface-speciﬁc vtable. In our storable_object
EXAMPLE 10.55
Implementation of
default methods
example, the default get_local_name has to be able to ﬁnd, and call, the version
of get_stored_name deﬁned by the concrete class. The usual way to implement
this access depends on tiny forwarding routines: for each class C that inherits
from storable_object and that needs the default code, the compiler generates a
static, C-speciﬁc forwarding routine that accepts the concrete-class-speciﬁc this
parameter, adds back in the this correction that the regular calling sequence just
subtracted out, and passes the resulting pointer-to-vtable-pointer to the default
method.
■
As it turns out, the equivalent of default methods has long been provided by
the Scala programming language, whose mix-ins are known as traits. In fact,
traits support not only default methods but also mutable ﬁelds. Rather than try to
create a view that would make these ﬁelds directly accessible, the Scala compiler
generates, for each concrete class that inherits from the trait, a pair of hidden
accessor methods analogous to the properties of C# (Example 10.7). References
to the accessor methods are then included in the interface-speciﬁc vtable, where
they can be called by default methods. In any class that does not provide its own
deﬁnition of a trait ﬁeld, the compiler creates a new private ﬁeld to be used by the
accessor methods.
