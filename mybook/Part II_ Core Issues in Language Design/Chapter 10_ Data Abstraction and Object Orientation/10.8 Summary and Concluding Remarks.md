524
Chapter 10 Data Abstraction and Object Orientation
46. What is repeated inheritance? What is the distinction between replicated and
shared repeated inheritance?
47. What does it mean for a language to provide a uniform object model? Name
two languages that do so.
10.8
Summary and Concluding Remarks
This has been the last of our six core chapters on language design: names (Chap-
ter 3), control ﬂow (Chapter 6), type systems (Chapter 7), composite types
(Chapter 8), subroutines (Chapter 9), and objects (Chapter 10).
We began in Section 10.1 by identifying three fundamental concepts of object-
oriented programming: encapsulation, inheritance, and dynamic method binding.
We also introduced the terminology of classes, objects, and methods. We had
already seen encapsulation in the modules of Chapter 3. Encapsulation allows
the details of a complicated data abstraction to be hidden behind a comparatively
simple interface. Inheritance extends the utility of encapsulation by making it
easy for programmers to deﬁne new abstractions as reﬁnements or extensions of
existing abstractions. Inheritance provides a natural basis for polymorphic sub-
routines: if a subroutine expects an instance of a given class as argument, then an
object of any class derived from the expected one can be used instead (assuming
that it retains the entire existing interface). Dynamic method binding extends this
form of polymorphism by arranging for a call to one of the parameter’s methods
to use the implementation associated with the class of the actual object at run
time, rather than the implementation associated with the declared class of the pa-
rameter. We noted that some languages, including Modula-3, Oberon, Ada 95,
and Fortran 2003, support object orientation through a type extension mecha-
nism, in which encapsulation is associated with modules, but inheritance and
dynamic method binding are associated with a special form of record.
In later sections we covered object initialization and ﬁnalization, dynamic
method binding, and (on the companion site) multiple inheritance in some de-
tail. In many cases we discovered tradeoffs between functionality on the one hand
and simplicity and execution speed on the other. Treating variables as references,
rather than values, often leads to simpler semantics, but requires extra indirec-
tion. Garbage collection, as previously noted in Section 8.5.3, dramatically eases
the creation and maintenance of software, but imposes run-time costs. Dynamic
method binding requires (in the general case) that methods be dispatched us-
ing vtables or some other lookup mechanism. Fully general implementations of
multiple inheritance tend to impose overheads even when unused.
In several cases we saw time/space tradeoffs as well. In-line subroutines, as pre-
viously noted in Section 9.2.4, can dramatically improve the performance of code
with many small subroutines, not only by eliminating the overhead of the sub-
routine calls themselves, but by allowing register allocation, common subexpres-
