# 10.1 Object-Oriented Programming

10.1 Object-Oriented Programming
**473**

erything as an object. Most of our discussion will focus on Smalltalk, Eiffel, C++,
and Java, though we shall have occasion to mention many other languages as well.
We will return to the subject of dynamically typed objects in Section 14.4.4.
## 10.1

**Object-Oriented Programming**
Object-oriented programming can be seen as an attempt to enhance opportuni-
ties for code reuse by making it easy to deﬁne new abstractions as* extensions* or
*reﬁnements* of existing abstractions. As a starting point for examples, consider a
**EXAMPLE** 10.1

```
list_node class in C++
collection of integers, implemented as a doubly linked list of records (we’ll con-
sider collections of other types of objects in Section 10.1.1). Figure 10.1 contains
C++ code for the elements of our collection. The example employs a “module-as-
type” style of abstraction: each element is a separate object of class list_node.
The class contains both data members (prev, next, head_node, and val) and
subroutine members (predecessor, successor, insert_before and remove).
Subroutine members are called methods in many object-oriented languages; data
members are also called ﬁelds. The keyword this in C++ refers to the object of
which the currently executing method is a member. In Smalltalk and Objective-C,
the equivalent keyword is self; in Eiffel it is current.
■
Given the existence of the list_node class, we could deﬁne a list of integers as
EXAMPLE 10.2
```

```
list class that uses
list_node
follows:
```

```
class list {
list_node header;
public:
// no explicit constructor required;
// implicit construction of 'header' suffices
int empty() {
return header.singleton();
}
list_node* head() {
return header.successor();
}
void append(list_node *new_node) {
header.insert_before(new_node);
}
~list() {
// destructor
if (!header.singleton())
throw new list_err("attempt to delete nonempty list");
}
};
```

To create an empty list, one could then write

```
list* my_list_ptr = new list;
```

```
Each in-line declaration or call to new would then need to provide a value:
```

```
list_node element1(0);
// in-line
list_node *e_ptr = new list_node(13);
// heap
```

As we shall see in Section 10.3.1, C++ actually allows us to declare* both* construc-
tors, and uses the usual rules of function overloading to differentiate between
them: declarations without a value will call the no-parameter constructor; decla-
rations with an integer argument will call the integer-parameter constructor.
■

```
class queue : private list {
...
int head() {
if (empty())
throw new list_err("attempt to peek at head of empty queue");
return list::head()->val;
}
```

```
Note that the head method of class list is still visible to methods of class
queue (but not to its users!) when identiﬁed with the scope resolution opera-
tor (list::).
■
```

