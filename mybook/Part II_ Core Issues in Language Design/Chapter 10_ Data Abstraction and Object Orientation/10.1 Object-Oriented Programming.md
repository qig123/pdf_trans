10.1 Object-Oriented Programming
473
erything as an object. Most of our discussion will focus on Smalltalk, Eiffel, C++,
and Java, though we shall have occasion to mention many other languages as well.
We will return to the subject of dynamically typed objects in Section 14.4.4.
10.1
Object-Oriented Programming
Object-oriented programming can be seen as an attempt to enhance opportuni-
ties for code reuse by making it easy to deﬁne new abstractions as extensions or
reﬁnements of existing abstractions. As a starting point for examples, consider a
EXAMPLE 10.1
list_node class in C++
collection of integers, implemented as a doubly linked list of records (we’ll con-
sider collections of other types of objects in Section 10.1.1). Figure 10.1 contains
C++ code for the elements of our collection. The example employs a “module-as-
type” style of abstraction: each element is a separate object of class list_node.
The class contains both data members (prev, next, head_node, and val) and
subroutine members (predecessor, successor, insert_before and remove).
Subroutine members are called methods in many object-oriented languages; data
members are also called ﬁelds. The keyword this in C++ refers to the object of
which the currently executing method is a member. In Smalltalk and Objective-C,
the equivalent keyword is self; in Eiffel it is current.
■
Given the existence of the list_node class, we could deﬁne a list of integers as
EXAMPLE 10.2
list class that uses
list_node
follows:
class list {
list_node header;
public:
// no explicit constructor required;
// implicit construction of 'header' suffices
int empty() {
return header.singleton();
}
list_node* head() {
return header.successor();
}
void append(list_node *new_node) {
header.insert_before(new_node);
}
~list() {
// destructor
if (!header.singleton())
throw new list_err("attempt to delete nonempty list");
}
};
To create an empty list, one could then write
list* my_list_ptr = new list;
474
Chapter 10 Data Abstraction and Object Orientation
class list_err {
// exception
public:
const char *description;
list_err(const char *s) {description = s;}
};
class list_node {
list_node* prev;
list_node* next;
list_node* head_node;
public:
int val;
// the actual data in a node
list_node() {
// constructor
prev = next = head_node = this;
// point to self
val = 0;
// default value
}
list_node* predecessor() {
if (prev == this || prev == head_node) return nullptr;
return prev;
}
list_node* successor() {
if (next == this || next == head_node) return nullptr;
return next;
}
bool singleton() {
return (prev == this);
}
void insert_before(list_node* new_node) {
if (!new_node->singleton())
throw new list_err("attempt to insert node already on list");
prev->next = new_node;
new_node->prev = prev;
new_node->next = this;
prev = new_node;
new_node->head_node = head_node;
}
void remove() {
if (singleton())
throw new list_err("attempt to remove node not currently on list");
prev->next = next;
next->prev = prev;
prev = next = head_node = this;
// point to self
}
~list_node() {
// destructor
if (!singleton())
throw new list_err("attempt to delete node still on list");
}
};


![Figure 10.1 A simple...](images/page_507_caption_Figure%2010.1%20A%20simple%20class%20for%20list%20nodes%20in%20C%2B%2B.%20In%20this%20example%20we%20envision%20a%20list%20of%20integers.png)
*Figure 10.1 A simple class for list nodes in C++. In this example we envision a list of integers.*

10.1 Object-Oriented Programming
475
Records to be inserted into a list are created in much the same way:
list_node* elem_ptr = new list_node;
■
In C++, one can also simply declare an object of a given class:
EXAMPLE 10.3
Declaration of in-line
(expanded) objects
list my_list;
list_node elem;
Our list class includes such an object (header) as a ﬁeld. When created with
new, an object is allocated in the heap; when created via elaboration of a decla-
ration it is allocated statically or on the stack, depending on lifetime (Eiffel calls
such objects “expanded”). Whether on the stack or in the heap, object creation
causes the invocation of a programmer-speciﬁed initialization routine, known as
a constructor. In C++ and its descendants, Java and C#, the name of the con-
structor is the same as that of the class itself. C++ also allows the programmer to
specify a destructor method that will be invoked automatically when an object is
destroyed, either by explicit programmer action or by return from the subroutine
in which it was declared. The destructor’s name is also the same as that of the
class, but with a leading tilde (~). Destructors are commonly used for storage
management and error checking.
■
If a constructor has parameters, corresponding arguments must be provided
when declaring an in-line object or creating an object in the heap. Suppose, for
EXAMPLE 10.4
Constructor arguments
example, that our list_node constructor had been written to take an explicit
parameter:
class list_node {
...
list_node(int v) {
prev = next = head_node = this;
val = v;
}
Each in-line declaration or call to new would then need to provide a value:
list_node element1(0);
// in-line
list_node *e_ptr = new list_node(13);
// heap
As we shall see in Section 10.3.1, C++ actually allows us to declare both construc-
tors, and uses the usual rules of function overloading to differentiate between
them: declarations without a value will call the no-parameter constructor; decla-
rations with an integer argument will call the integer-parameter constructor.
■
476
Chapter 10 Data Abstraction and Object Orientation
Public and Private Members
The public label within the declaration of list_node separates members re-
quired by the implementation of the abstraction from members available to users
of the abstraction. In the terminology of Section 3.3.4, members that appear after
the public label are exported from the class; members that appear before the la-
bel are not. C++ also provides a private label, so the publicly visible portions of
a class can be listed ﬁrst if desired (or even intermixed). In many other languages,
public data and subroutine members (ﬁelds and methods) must be individually
so labeled (more on this in Section 10.2.2). Note that C++ classes are open scopes,
as deﬁned in Section 3.3.4; nothing needs to be explicitly imported.
In many languages—C++ among them—certain information can be left out
of the initial declaration of a module or class, and provided in a separate ﬁle not
visible to users of the abstraction. In our running example, we could declare the
EXAMPLE 10.5
Method declaration
without deﬁnition
public methods of list_node without providing their bodies:
class list_node {
list_node* prev;
list_node* next;
list_node* head_node;
public:
int val;
list_node();
list_node* predecessor();
list_node* successor();
bool singleton();
void insert_before(list_node* new_node);
DESIGN & IMPLEMENTATION
10.1 What goes in a class declaration?
Two rules govern the choice of what to put in the declaration of a class, rather
than in a separate deﬁnition. First, the declaration must contain all the in-
formation that a programmer needs in order to use the abstraction correctly.
Second, the declaration must contain all the information that the compiler
needs in order to generate code. The second rule is generally broader: it tends
to force information that is not required by the ﬁrst rule into (the private part
of) the interface, particularly in languages that use a value model of variables,
instead of a reference model. If the compiler must generate code to allocate
space (e.g., in stack frames) to hold an instance of a class, then it must know
the size of that instance; this is the rationale for including private ﬁelds in the
class declaration. In addition, if the compiler is to expand any method calls in-
line then it must have their code available. In-line expansion of the smallest,
most common methods of an object-oriented program tends to be crucial for
good performance.
10.1 Object-Oriented Programming
477
void remove();
~list_node();
};
■
This somewhat abbreviated class declaration might then be put in a.h “header”
ﬁle, with method bodies relegated to a .cc “implementation” ﬁle. (C++ con-
ventions for separate compilation are similar to those of C, which we saw in Sec-
tion C 3.8. The ﬁle name sufﬁxes used here are those expected by the GNU g++
compiler.) Within a.cc ﬁle, the header of a method deﬁnition must identify the
EXAMPLE 10.6
Separate method deﬁnition
class to which it belongs by using a :: scope resolution operator:
void list_node::insert_before(list_node* new_node) {
if (!new_node->singleton())
throw new list_err("attempt to insert node already on list");
prev->next = new_node;
new_node->prev = prev;
new_node->next = this;
prev = new_node;
new_node->head_node = head_node;
}
■
Tiny Subroutines
Object-oriented programs tend to make many more subroutine calls than do
ordinary imperative programs, and the subroutines tend to be shorter. Lots of
things that would be accomplished by direct access to record ﬁelds in a von Neu-
mann language tend to be hidden inside object methods in an object-oriented
language. Many programmers in fact consider it bad style to declare public ﬁelds,
because doing so gives users of an abstraction direct access to the internal repre-
sentation, and makes it impossible to change that representation without chang-
ing the user code as well. Arguably, we should make the val ﬁeld of list_node
private, with get_val and set_val methods to read and write it.
C# provides a property mechanism speciﬁcally designed to facilitate the decla-
EXAMPLE 10.7
property and indexer
methods in C#
ration of methods (called accessors) to “get” and “set” private ﬁelds. Using this
mechanism, a C# version of our val ﬁeld could be written as follows:
class list_node {
...
int val;
// val (lower case 'v') is private
public int Val {
get {
// presence of get accessor and optional
return val;
// set accessor means that Val is a property
}
set {
val = value;
// value is a keyword: argument to set
}
}
...
}
478
Chapter 10 Data Abstraction and Object Orientation
Users of the list_node class can now access the (private) val ﬁeld through the
(public) Val property as if it were a ﬁeld:
list_node n;
...
int a = n.Val;
// implicit call to get method
n.Val = 3;
// implicit call to set method
In effect, C# indexers provide the look of direct ﬁeld access (from the perspec-
tive of a class’s users) while preserving the ability to change the implementation.
A similar indexer mechanism can make objects of arbitrary classes look like ar-
rays, with conventional subscript syntax in both l-value and r-value contexts. An
example appears in Sidebar 8.3.
In C++, operator overloading and references can be used to provide the equiv-
alent of indexers, but not of properties.
■
Derived Classes
Suppose now that we already have a list abstraction, and would like a queue ab-
EXAMPLE 10.8
queue class derived from
list
straction. We could deﬁne the queue from scratch, but much of the code would
look the same as in Figure 10.1. In an object-oriented language we have the alter-
native of deriving the queue from the list, allowing it to inherit preexisting ﬁelds
and methods:
class queue : public list {
// queue is derived from list
public:
// no specialized constructor or destructor required
void enqueue(int v) {
append(new list_node(v));
// append is inherited from list
}
int dequeue() {
if (empty())
throw new list_err("attempt to dequeue from empty queue");
list_node* p = head();
// head is also inherited
p->remove();
int v = p->val;
delete p;
return v;
}
};
Here queue is said to be a derived class (also called a child class or subclass); list
is said to be a base class (also called a parent class or superclass). The derived
class inherits all the ﬁelds and methods of the base class, automatically. All the
programmer needs to declare explicitly are members that a queue has but a list
lacks—in this case, the enqueue and dequeue methods. We shall see examples
shortly in which derived classes have extra ﬁelds as well.
■
10.1 Object-Oriented Programming
479
In C++, public members of a base class are always visible inside the methods
of a derived class. They are visible to users of the derived class only if the base class
name is preceded with the keyword public in the ﬁrst line of the derived class’s
declaration. Of course, we may not always want these members to be visible. In
EXAMPLE 10.9
Hiding members of a base
class
our queue example, we have chosen to pass integers to and from enqueue and
dequeue, and to allocate and deallocate the list_nodes internally. If we want to
keep these list nodes hidden, we must prevent the user from accessing the head
and append methods of class list. We can do so by making list a private base
class instead:
class queue : private list { ...
To make the empty method visible again, we can call it out explicitly:
public:
using list::empty;
We will discuss the visibility of class members in more detail in Section 10.2.2. ■
When an object of a derived class is created in C++, the compiler arranges to
call the constructor for the base class ﬁrst, and then to call the constructor of the
derived class. In our queue example, where the derived class lacks a constructor,
the list constructor will still be called—which is, of course, what we want. We
will discuss constructors further in Section 10.3.
By deriving new classes from old ones, the programmer can create arbitrar-
ily deep class hierarchies, with additional functionality at every level of the tree.
The standard libraries for Smalltalk and Java are as many as seven and eight levels
deep, respectively. (Unlike C++, both Smalltalk and Java have a single root su-
perclass, Object, from which all other classes are derived. C#, Objective-C, and
Eiffel have a similar class; Eiffel calls it ANY.)
Modifying Base Class Methods
In addition to deﬁning new ﬁelds and methods, and hiding those it no longer
wants to be visible, a derived class can redeﬁne a member of a base class simply by
providing a new version. In our queue example, we might want to deﬁne a new
EXAMPLE 10.10
Redeﬁning a method in a
derived class
head method that “peeks” at the ﬁrst element of the queue, without removing it:
class queue : private list {
...
int head() {
if (empty())
throw new list_err("attempt to peek at head of empty queue");
return list::head()->val;
}
Note that the head method of class list is still visible to methods of class
queue (but not to its users!) when identiﬁed with the scope resolution opera-
tor (list::).
■
480
Chapter 10 Data Abstraction and Object Orientation
Other object-oriented languages provide other means of accessing the mem-
bers of a base class. In Smalltalk, Objective-C, Java, and C#, one uses the keyword
EXAMPLE 10.11
Accessing base class
members
base or super:
list::head();
// C++
super.head();
// Java
base.head();
// C#
super head.
// Smalltalk
[super head]
// Objective-C
■
In Eiffel, one must explicitly rename methods inherited from a base class, in
EXAMPLE 10.12
Renaming methods in Eiffel
order to make them accessible:
class queue
inherit
list
rename
head as list_head
...
-- other renames
end
Within methods of queue, the head method of list can be invoked as
list_head. C++ and Eiffel cannot use the keyword super, because it would
be ambiguous in the presence of multiple inheritance.
■
Objects as Fields of Other Objects
As an alternative to deriving queue from list, we might choose to include a
EXAMPLE 10.13
A queue that contains a list
list as a ﬁeld of a queue instead:
class queue {
list contents;
public:
bool empty() {
return contents.empty();
}
void enqueue(const int v) {
contents.append(new list_node(v));
}
int dequeue() {
if (empty())
throw new list_err("attempt to dequeue from empty queue");
list_node* p = contents.head();
p->remove();
int v = p->val;
delete p;
return v;
}
};
10.1 Object-Oriented Programming
481
The practical difference is small in this example. The choice mainly boils down
to whether we think of a queue as a special kind of list, or whether we think of a
queue as an abstraction that uses a list as part of its implementation. The cases
in which inheritance is most compelling are those in which we want to be able
to use an object of a derived class (a “client,” say) in a context that expects an
object of a base class (a “person,” say), and have that object behave in a special
way by virtue of belonging to the derived class (e.g., include extra information
when printed). We will consider these sorts of cases in Section 10.4.
■
10.1.1 Classes and Generics
The astute reader may have noticed that our various lists and queues have all
embedded the assumption that the item in each list node is an integer. In practice,
we should like to be able to have lists and queues of many kinds of items, all based
on a single copy of the bulk of the code. In a dynamically typed language like Ruby
or Python, this is natural: the val ﬁeld would have no static type, and objects of
any kind could be added to, and removed from, lists and queues.
In a statically typed language like C++, it is tempting to create a general-
purpose list_node class that has no val ﬁeld, and then derive subclasses (e.g.,
int_list_node) that add the values. While this approach can be made to work,
it has some unfortunate limitations. Suppose we deﬁne a gp_list_node type,
EXAMPLE 10.14
Base class for
general-purpose lists
with the ﬁelds and methods needed to implement list operations, but without a
val payload:
class gp_list_node {
gp_list_node* prev;
gp_list_node* next;
gp_list_node* head_node;
public:
gp_list_node();
// assume method bodies given separately
gp_list_node* predecessor();
gp_list_node* successor();
bool singleton();
void insert_before(gp_list_node* new_node);
void remove();
~gp_list_node();
};
To create nodes that can be used in a list of integers, we will need a val ﬁeld and
some constructors:
class int_list_node : public gp_list_node {
public:
int val;
// the actual data in a node
int_list_node() { val = 0; }
int_list_node(int v) { val = v; }
...
482
Chapter 10 Data Abstraction and Object Orientation
Initialization of the prev, next, and head_node ﬁelds will remain in the hands of
the gp_list_node constructor, which will be called automatically whenever we
create a int_list_node object. The singleton, insert_before, and remove
methods can likewise be inherited from gp_list_node intact, as can the destruc-
tor.
■
But what about successor and predecessor? If we leave these unchanged,
EXAMPLE 10.15
The problem with
type-speciﬁc extensions
they will continue to return values of type gp_list_node, not int_list_node:
int_list_node* p = ...
// whatever
int v = p->successor().val
// won't compile!
As far as the compiler is concerned, the successor of an int_list_node will have
no val ﬁeld. To ﬁx the problem, we will need explicit casts:
int_list_node* predecessor() {
return static_cast<int_list_node*>(gp_list_node::predecessor());
}
int_list_node* successor() {
return static_cast<int_list_node*>(gp_list_node::successor());
}
In a similar vein, we can create a general-purpose list class:
class gp_list {
gp_list_node head_node;
public:
bool empty();
// method bodies again given separately
gp_list_node* head();
void append(gp_list_node *new_node);
~gp_list();
};
But if we extend it to create an int_list class, we will need a cast in the head
method:
class int_list : public gp_list {
public:
int_list_node* head() {
// redefinition; hides original
return static_cast<int_list_node*>(gp_list::head());
}
};
Assuming we write our code correctly, none of our casts will introduce bugs. They
may, however, prevent the compiler from catching bugs if we write our code in-
correctly:
10.1 Object-Oriented Programming
483
class string_list_node : public gp_list_node {
// analogous to int_list_node
...
};
...
string_list_node n("boo!");
int_list L;
L.append(&n);
cout << "0x" << hex << L.head()->val;
On the author’s 64-bit Macbook, this code prints “0x6f6f6208.” What hap-
pened?
Method int_list::append, inherited from gp_list, expects a pa-
rameter of type gp_list_node*, and since string_list_node is derived from
gp_list_node, a pointer to node n is acceptable. But when we peek at this
node, the cast in L.head() tells the compiler not to complain when we treat the
node (which can’t be proven to be anything more speciﬁc than a gp_list_node)
as if we were certain it held an int. Not coincidentally, the upper three bytes
of 0x6f6f6208 contain, in reverse order, the ASCII codes of the characters
“boo.”
■
Things get even worse if we try to deﬁne a general-purpose analogue of the
EXAMPLE 10.16
How do you name an
unknown type?
queue from Examples 10.8–10.10:
class gp_queue : private gp_list {
public:
using gp_list::empty;
void enqueue(const ?? v);
// what is "??" ?
?? dequeue();
?? head();
};
How do we talk about the objects the queue is supposed to contain when we don’t
even know their type?
■
The answer, of course, is generics (Section C 7.3.2)—templates, in C++. These
EXAMPLE 10.17
Generic lists in C++
allow us to deﬁne a list_node<T> class that can be instantiated for any data type
T, without the need for either inheritance or type casts:
template<typename V>
class list_node {
list_node<V>* prev;
list_node<V>* next;
list_node<V>* head_node;
public:
V val;
list_node<V>* predecessor() { ...
list_node<V>* successor() { ...
void insert_before(list_node<V>* new_node) { ...
...
};
484
Chapter 10 Data Abstraction and Object Orientation
template<typename V>
class list {
list_node<V> header;
public:
list_node<V>* head() { ...
void append(list_node<V> *new_node) { ...
...
};
template<typename V>
class queue : private list<V> {
public:
using list<V>::empty;
void enqueue(const V v) { ...
V dequeue() { ...
V head() { ...
};
typedef list_node<int> int_list_node;
typedef list_node<string> string_list_node;
typedef list<int> int_list;
...
DESIGN & IMPLEMENTATION
10.2 Containers/collections
In object-oriented programming, an abstraction that holds a collection of ob-
jects of some given class is often called a container. Common containers in-
clude sorted and unsorted sets, stacks, queues, and dictionaries, implemented
as lists, trees, hash tables, and various other concrete data structures. All of the
major object-oriented languages include extensive container libraries. A few of
the issues involved in their creation have been hinted at in this section: Which
classes are derived from which others? When do we say that “X is a Y” instead
of “X contains / uses a Y”? Which operations are supported, and what is their
time complexity? How much “memory churn” (heap allocation and garbage
collection) does each operation incur? Is everything type safe? How extensive
is the use of generics? How easy is it to iterate over the contents of a con-
tainer? Given these many questions, the design of safe, efﬁcient, and ﬂexible
container libraries is a complex and difﬁcult art. For an approach that builds
on the gp_list_node base class of Example 10.14, but still leverages templates
to avoid the need for type casts, see Exercise 10.8.
