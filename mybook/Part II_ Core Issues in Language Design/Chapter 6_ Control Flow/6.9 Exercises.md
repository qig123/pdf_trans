# 6.9 Exercises

**286**
Chapter 6* Control Flow*

```
In several cases, advances in compiler technology or in the simple willingness
of designers to build more complex compilers have made it possible to incorpo-
rate features once considered too expensive. Label ranges in Ada case statements
require that the compiler be prepared to generate code employing binary search.
In-line functions in C++ eliminate the need to choose between the inefﬁciency
of tiny functions and the messy semantics of macros. Exceptions (as we shall see
in Section 9.4.3) can be implemented in such a way that they incur no cost in the
common case (when they do not occur), but the implementation is quite tricky.
Iterators, boxing, generics (Section 7.3.1), and ﬁrst-class functions are likewise
rather tricky, but are increasingly found in mainstream imperative languages.
Some implementation techniques (e.g., rearranging expressions to uncover
common subexpressions, or avoiding the evaluation of guards in a nondeter-
ministic construct once an acceptable choice has been found) are sufﬁciently im-
portant to justify a modest burden on the programmer (e.g., adding parentheses
where necessary to avoid overﬂow or ensure numeric stability, or ensuring that
expressions in guards are side-effect-free). Other semantically useful mechanisms
(e.g., lazy evaluation, continuations, or truly random nondeterminacy) are usu-
ally considered complex or expensive enough to be worthwhile only in special
circumstances (if at all).
In comparatively primitive languages, we can often obtain some of the beneﬁts
of missing features through programming conventions. In early dialects of For-
tran, for example, we can limit the use of gotos to patterns that mimic the control
ﬂow of more modern languages. In languages without short-circuit evaluation,
we can write nested selection statements. In languages without iterators, we can
write sets of subroutines that provide equivalent functionality.
6.9
Exercises
```

```
6.1
We noted in Section 6.1.1 that most binary arithmetic operators are left-
associative in most programming languages. In Section 6.1.4, however, we
also noted that most compilers are free to evaluate the operands of a binary
operator in either order. Are these statements contradictory? Why or why
not?
6.2
As noted in Figure 6.1, Fortran and Pascal give unary and binary minus the
same level of precedence. Is this likely to lead to nonintuitive evaluations of
certain expressions? Why or why not?
6.3
In Example 6.9 we described a common error in Pascal programs caused by
the fact that and and or have precedence comparable to that of the arith-
metic operators. Show how a similar problem can arise in the stream-based
I/O of C++ (described in Section C 8.7.3). (Hint: Consider the precedence
of << and >>, and the operators that appear below them in the C column of
Figure 6.1.)
6.4
Translate the following expression into postﬁx and preﬁx notation:
```

```
−→other stmt
condition −→c term | condition or c term
c term −→c factor | c term and c factor
c factor −→ident relation ident | ( condition ) | not ( condition )
relation −→< | <= | = | <> | > | >=
```

```
You may assume that the code attribute has already been initialized for
other stmt and ident nodes.
(For hints, see Fischer et al.’s compiler
book [FCL10, Sec. 14.1.4].)
6.12 Describe a plausible scenario in which a programmer might wish to avoid
short-circuit evaluation of a Boolean expression.
6.13 Neither Algol 60 nor Algol 68 employs short-circuit evaluation for Boolean
expressions. In both languages, however, an if... then ... else construct
can be used as an expression.
Show how to use if... then ... else to
achieve the effect of short-circuit evaluation.
6.14 Consider the following expression in C: a/b > 0 && b/a > 0. What will
be the result of evaluating this expression when a is zero? What will be the
result when b is zero? Would it make sense to try to design a language in
which this expression is guaranteed to evaluate to false when either a or
b (but not both) is zero? Explain your answer.
6.15 As noted in Section 6.4.2, languages vary in how they handle the situation
in which the controlling expression in a case statement does not appear
among the labels on the arms. C and Fortran 90 say the statement has no
effect. Pascal and Modula say it results in a dynamic semantic error. Ada
says that the labels must cover all possible values for the type of the expres-
sion, so the question of a missing value can never arise at run time. What
are the tradeoffs among these alternatives? Which do you prefer? Why?
6.16 The equivalence of for and while loops, mentioned in Example 6.64, is
not precise. Give an example in which it breaks down. Hint: think about
the continue statement.
6.17 Write the equivalent of Figure 6.5 in C# or Ruby. Write a second version
that performs an in-order enumeration, rather than preorder.
6.18 Revise the algorithm of Figure 6.6 so that it performs an in-order enumera-
tion, rather than preorder.
6.19 Write a C++ preorder iterator to supply tree nodes to the loop in Exam-
ple 6.69. You will need to know (or learn) how to use pointers, references,
inner classes, and operator overloading in C++. For the sake of (relative)
simplicity, you may assume that the data in a tree node is always an int;
this will save you the need to use generics. You may want to use the stack
abstraction from the C++ standard library.
```

```
(Hint: Think recursively! If you need help, see Section 2.2 of the text by
Finkel [Fin96].)
6.23 Build true iterators in Java using threads. (This requires knowledge of ma-
terial in Chapter 13.) Make your solution as clean and as general as possible.
In particular, you should provide the standard Iterator or IEnumerable
interface, for use with extended for loops, but the programmer should not
have to write these. Instead, he or she should write a class with an Iterate
method, which should in turn be able to call a Yield method, which you
should also provide. Evaluate the cost of your solution. How much more
expensive is it than standard Java iterator objects?
6.24 In an expression-orientedlanguage such as Algol 68 or Lisp, a while loop (a
do loop in Lisp) has a value as an expression. How do you think this value
should be determined? (How is it determined in Algol 68 and Lisp?) Is
the value a useless artifact of expression orientation, or are there reasonable
programs in which it might actually be used? What do you think should
happen if the condition on the loop is such that the body is never executed?
6.25 Consider a mid-test loop, here written in C, that looks for blank lines in its
input:
```

Write code for binary search in your favorite imperative programming lan-
guage. What loop construct(s) did you ﬁnd to be most useful? NB: when he
asked more than a hundred professional programmers to solve this prob-
lem, Bentley found that only about 10% got it right the ﬁrst time, without
testing.
6.28 A* loop invariant* is a condition that is guaranteed to be true at a given point
within the body of a loop on every iteration. Loop invariants play a major
role in* axiomatic semantics*, a formal reasoning system used to prove prop-
erties of programs. In a less formal way, programmers who identify (and
write down!) the invariants for their loops are more likely to write correct
code. Show the loop invariant(s) for your solution to the preceding exercise.

