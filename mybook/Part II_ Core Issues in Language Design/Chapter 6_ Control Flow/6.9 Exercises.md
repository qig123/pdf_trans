# 6.9 Exercises

In several cases, advances in compiler technology or in the simple willingness of designers to build more complex compilers have made it possible to incorpo- rate features once considered too expensive. Label ranges in Ada case statements require that the compiler be prepared to generate code employing binary search. In-line functions in C++ eliminate the need to choose between the inefﬁciency of tiny functions and the messy semantics of macros. Exceptions (as we shall see in Section 9.4.3) can be implemented in such a way that they incur no cost in the common case (when they do not occur), but the implementation is quite tricky. Iterators, boxing, generics (Section 7.3.1), and ﬁrst-class functions are likewise rather tricky, but are increasingly found in mainstream imperative languages. Some implementation techniques (e.g., rearranging expressions to uncover common subexpressions, or avoiding the evaluation of guards in a nondeter- ministic construct once an acceptable choice has been found) are sufﬁciently im- portant to justify a modest burden on the programmer (e.g., adding parentheses where necessary to avoid overﬂow or ensure numeric stability, or ensuring that expressions in guards are side-effect-free). Other semantically useful mechanisms (e.g., lazy evaluation, continuations, or truly random nondeterminacy) are usu- ally considered complex or expensive enough to be worthwhile only in special circumstances (if at all). In comparatively primitive languages, we can often obtain some of the beneﬁts of missing features through programming conventions. In early dialects of For- tran, for example, we can limit the use of gotos to patterns that mimic the control ﬂow of more modern languages. In languages without short-circuit evaluation, we can write nested selection statements. In languages without iterators, we can write sets of subroutines that provide equivalent functionality. 6.9 Exercises

6.1 We noted in Section 6.1.1 that most binary arithmetic operators are left- associative in most programming languages. In Section 6.1.4, however, we also noted that most compilers are free to evaluate the operands of a binary operator in either order. Are these statements contradictory? Why or why not? 6.2 As noted in Figure 6.1, Fortran and Pascal give unary and binary minus the same level of precedence. Is this likely to lead to nonintuitive evaluations of certain expressions? Why or why not? 6.3 In Example 6.9 we described a common error in Pascal programs caused by the fact that and and or have precedence comparable to that of the arith- metic operators. Show how a similar problem can arise in the stream-based I/O of C++ (described in Section C 8.7.3). (Hint: Consider the precedence of << and >>, and the operators that appear below them in the C column of Figure 6.1.) 6.4 Translate the following expression into postﬁx and preﬁx notation:

[−b + sqrt(b × b −4 × a × c)]/(2 × a)

Do you need a special symbol for unary negation? 6.5 In Lisp, most of the arithmetic operators are deﬁned to take two or more arguments, rather than strictly two. Thus (* 2 3 4 5) evaluates to 120, and (- 16 9 4) evaluates to 3. Show that parentheses are necessary to dis- ambiguate arithmetic expressions in Lisp (in other words, give an example of an expression whose meaning is unclear when parentheses are removed). In Section 6.1.1 we claimed that issues of precedence and associativity do not arise with preﬁx or postﬁx notation. Reword this claim to make explicit the hidden assumption. 6.6 Example 6.33 claims that “For certain values of x, (0.1 + x) * 10.0 and 1.0 + (x * 10.0) can differ by as much as 25%, even when 0.1 and x are of the same magnitude.” Verify this claim. (Warning: If you’re us- ing an x86 processor, be aware that ﬂoating-point calculations [even on single-precision variables] are performed internally with 80 bits of preci- sion. Roundoff errors will appear only when intermediate results are stored out to memory [with limited precision] and read back in again.) 6.7 Is &(&i) ever valid in C? Explain. 6.8 Languages that employ a reference model of variables also tend to employ automatic garbage collection. Is this more than a coincidence? Explain. 6.9 In Section 6.1.2 (“Orthogonality”), we noted that C uses = for assignment and == for equality testing. The language designers state: “Since assignment is about twice as frequent as equality testing in typical C programs, it’s ap- propriate that the operator be half as long” [KR88, p. 17]. What do you think of this rationale? 6.10 Consider a language implementation in which we wish to catch every use of an uninitialized variable. In Section 6.1.3 we noted that for types in which every possible bit pattern represents a valid value, extra space must be used to hold an initialized/uninitialized ﬂag. Dynamic checks in such a system can be expensive, largely because of the address calculations needed to ac- cess the ﬂags. We can reduce the cost in the common case by having the compiler generate code to automatically initialize every variable with a dis- tinguished sentinel value. If at some point we ﬁnd that a variable’s value is different from the sentinel, then that variable must have been initialized. If its value is the sentinel, we must double-check the ﬂag. Describe a plausible allocation strategy for initialization ﬂags, and show the assembly language sequences that would be required for dynamic checks, with and without the use of sentinels. 6.11 Write an attribute grammar, based on the following context-free grammar, that accumulates jump code for Boolean expressions (with short-circuiting)

into a synthesized attribute code of condition, and then uses this attribute to generate code for if statements.

stmt −→if condition then stmt else stmt

−→other stmt condition −→c term | condition or c term c term −→c factor | c term and c factor c factor −→ident relation ident | ( condition ) | not ( condition ) relation −→< | <= | = | <> | > | >=

You may assume that the code attribute has already been initialized for other stmt and ident nodes. (For hints, see Fischer et al.’s compiler book [FCL10, Sec. 14.1.4].) 6.12 Describe a plausible scenario in which a programmer might wish to avoid short-circuit evaluation of a Boolean expression. 6.13 Neither Algol 60 nor Algol 68 employs short-circuit evaluation for Boolean expressions. In both languages, however, an if... then ... else construct can be used as an expression. Show how to use if... then ... else to achieve the effect of short-circuit evaluation. 6.14 Consider the following expression in C: a/b > 0 && b/a > 0. What will be the result of evaluating this expression when a is zero? What will be the result when b is zero? Would it make sense to try to design a language in which this expression is guaranteed to evaluate to false when either a or b (but not both) is zero? Explain your answer. 6.15 As noted in Section 6.4.2, languages vary in how they handle the situation in which the controlling expression in a case statement does not appear among the labels on the arms. C and Fortran 90 say the statement has no effect. Pascal and Modula say it results in a dynamic semantic error. Ada says that the labels must cover all possible values for the type of the expres- sion, so the question of a missing value can never arise at run time. What are the tradeoffs among these alternatives? Which do you prefer? Why? 6.16 The equivalence of for and while loops, mentioned in Example 6.64, is not precise. Give an example in which it breaks down. Hint: think about the continue statement. 6.17 Write the equivalent of Figure 6.5 in C# or Ruby. Write a second version that performs an in-order enumeration, rather than preorder. 6.18 Revise the algorithm of Figure 6.6 so that it performs an in-order enumera- tion, rather than preorder. 6.19 Write a C++ preorder iterator to supply tree nodes to the loop in Exam- ple 6.69. You will need to know (or learn) how to use pointers, references, inner classes, and operator overloading in C++. For the sake of (relative) simplicity, you may assume that the data in a tree node is always an int; this will save you the need to use generics. You may want to use the stack abstraction from the C++ standard library.

6.20 Write code for the tree_iter type (struct) and the ti_create, ti_done, ti_next, ti_val, and ti_delete functions employed in Example 6.73. 6.21 Write, in C#, Python, or Ruby, an iterator that yields (a) all permutations of the integers 1 . . n (b) all combinations of k integers from the range 1 . . n (0 ≤k ≤n).

You may represent your permutations and combinations using either a list or an array. 6.22 Use iterators to construct a program that outputs (in some order) all struc- turally distinct binary trees of n nodes. Two trees are considered structurally distinct if they have different numbers of nodes or if their left or right sub- trees are structurally distinct. There are, for example, ﬁve structurally dis- tinct trees of three nodes:

These are most easily output in “dotted parenthesized form”:

(((.).).) ((.(.)).) ((.).(.)) (.((.).)) (.(.(.)))

(Hint: Think recursively! If you need help, see Section 2.2 of the text by Finkel [Fin96].) 6.23 Build true iterators in Java using threads. (This requires knowledge of ma- terial in Chapter 13.) Make your solution as clean and as general as possible. In particular, you should provide the standard Iterator or IEnumerable interface, for use with extended for loops, but the programmer should not have to write these. Instead, he or she should write a class with an Iterate method, which should in turn be able to call a Yield method, which you should also provide. Evaluate the cost of your solution. How much more expensive is it than standard Java iterator objects? 6.24 In an expression-orientedlanguage such as Algol 68 or Lisp, a while loop (a do loop in Lisp) has a value as an expression. How do you think this value should be determined? (How is it determined in Algol 68 and Lisp?) Is the value a useless artifact of expression orientation, or are there reasonable programs in which it might actually be used? What do you think should happen if the condition on the loop is such that the body is never executed? 6.25 Consider a mid-test loop, here written in C, that looks for blank lines in its input:

for (;;) { line = read_line(); if (all_blanks(line)) break; consume_line(line); }

Show how you might accomplish the same task using a while or do (repeat) loop, if mid-test loops were not available. (Hint: One alterna- tive duplicates part of the code; another introduces a Boolean ﬂag variable.) How do these alternatives compare to the mid-test version? 6.26 Rubin [Rub87] used the following example (rewritten here in C) to argue in favor of a goto statement:

int first_zero_row = -1; /* none */ int i, j; for (i = 0; i < n; i++) { for (j = 0; j < n; j++) { if (A[i][j]) goto next; } first_zero_row = i; break; next: ; }

The intent of the code is to ﬁnd the ﬁrst all-zero row, if any, of an n × n matrix. Do you ﬁnd the example convincing? Is there a good structured alternative in C? In any language? 6.27 Bentley [Ben00, Chap. 4] provides the following informal description of binary search:

We are to determine whether the sorted array X[1..N] contains the element T.... Binary search solves the problem by keeping track of a range within the array in which T must be if it is anywhere in the array. Initially, the range is the entire array. The range is shrunk by comparing its middle element to T and discarding half the range. The process continues until T is discovered in the array or until the range in which it must lie is known to be empty.

Write code for binary search in your favorite imperative programming lan- guage. What loop construct(s) did you ﬁnd to be most useful? NB: when he asked more than a hundred professional programmers to solve this prob- lem, Bentley found that only about 10% got it right the ﬁrst time, without testing. 6.28 A loop invariant is a condition that is guaranteed to be true at a given point within the body of a loop on every iteration. Loop invariants play a major role in axiomatic semantics, a formal reasoning system used to prove prop- erties of programs. In a less formal way, programmers who identify (and write down!) the invariants for their loops are more likely to write correct code. Show the loop invariant(s) for your solution to the preceding exercise.

(Hint: You will ﬁnd the distinction between < and ≤[or between > and ≥] to be crucial.) 6.29 If you have taken a course in automata theory or recursive function theory, explain why while loops are strictly more powerful than for loops. (If you haven’t had such a course, skip this question!) Note that we’re referring here to Ada-style for loops, not C-style. 6.30 Show how to calculate the number of iterations of a general Fortran 90- style do loop. Your code should be written in an assembler-like notation, and should be guaranteed to work for all valid bounds and step sizes. Be careful of overﬂow! (Hint: While the bounds and step size of the loop can be either positive or negative, you can safely use an unsigned integer for the iteration count.) 6.31 Write a tail-recursive function in Scheme or ML to compute n factorial (n! =  1≤i≤n i = 1 × 2 × · · · × n). (Hint: You will probably want to deﬁne a “helper” function, as discussed in Section 6.6.1.) 6.32 Is it possible to write a tail-recursive version of the classic quicksort algo- rithm? Why or why not? 6.33 Give an example in C in which an in-line subroutine may be signiﬁcantly faster than a functionally equivalent macro. Give another example in which the macro is likely to be faster. (Hint: Think about applicative vs normal- order evaluation of arguments.) 6.34 Use lazy evaluation (delay and force) to implement iterator objects in Scheme. More speciﬁcally, let an iterator be either the null list or a pair consisting of an element and a promise which when forced will return an iterator. Give code for an uptoby function that returns an iterator, and a for-iter function that accepts as arguments a one-argument function and an iterator. These should allow you to evaluate such expressions as

(for-iter (lambda (e) (display e) (newline)) (uptoby 10 50 3))

Note that unlike the standard Scheme for-each, for-iter should not re- quire the existence of a list containing the elements over which to iterate; the intrinsic space required for (for-iter f (uptoby 1 n 1)) should be only O(1), rather than O(n). 6.35 (Difﬁcult) Use call-with-current-continuation (call/cc) to imple- ment the following structured nonlocal control transfers in Scheme. (This requires knowledge of material in Chapter 11.) You will probably want to consult a Scheme manual for documentation not only on call/cc, but on define-syntax and dynamic-wind as well. (a) Multilevel returns. Model your syntax after the catch and throw of Common Lisp. (b) True iterators. In a style reminiscent of Exercise 6.34, let an iterator be a function which when call/cc-ed will return either a null list or a pair

