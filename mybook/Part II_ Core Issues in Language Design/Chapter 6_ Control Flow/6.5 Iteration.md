# 6.5 Iteration

6.5 Iteration
**261**

```
Most of the time, however, the need to insert a break at the end of each arm—
and the compiler’s willingness to accept arms without breaks, silently—is a recipe
for unexpected and difﬁcult-to-diagnose bugs. C# retains the familiar C syntax,
including multiple consecutive labels, but requires every nonempty arm to end
with a break, goto, continue, or return.
```

```
3CHECK YOUR UNDERSTANDING
19. List the principal uses of goto, and the structured alternatives to each.
```

20. Explain the distinction between exceptions and multilevel returns.
21. What are* continuations*? What other language features do they subsume?

22. Why is sequencing a comparatively unimportant form of control ﬂow in Lisp?
23. Explain why it may sometimes be useful for a function to have side effects.
24. Describe the* jump code* implementation of short-circuit Boolean evaluation.

```
25. Why do imperative languages commonly provide a case or switch statement
in addition to if... then ... else?
26. Describe three different search strategies that might be employed in the im-
plementation of a case statement, and the circumstances in which each
would be desirable.
```

```
27. Explain the use of break to terminate the arms of a C switch statement, and
the behavior that arises if a break is accidentally omitted.
```

## 6.5

**Iteration**
Iteration and recursion are the two mechanisms that allow a computer to per-
form similar operations repeatedly. Without at least one of these mechanisms,
the running time of a program (and hence the amount of work it can do and the
amount of space it can use) would be a linear function of the size of the program
text. In a very real sense, it is iteration and recursion that make computers useful
for more than ﬁxed-size tasks. In this section we focus on iteration. Recursion is
the subject of Section 6.6.
Programmers in imperative languages tend to use iteration more than they
use recursion (recursion is more common in functional languages). In most lan-
guages, iteration takes the form of* loops*. Like the statements in a sequence, the it-
erations of a loop are generally executed for their side effects: their modiﬁcations
of variables. Loops come in two principal varieties, which differ in the mecha-
nisms used to determine how many times to iterate. An* enumeration-controlled*
loop is executed once for every value in a given ﬁnite set; the number of iterations
is known before the ﬁrst iteration begins. A* logically controlled* loop is executed

```
FOR i := first TO last BY step DO
...
END
```

```
By choosing different values of first, last, and step, we could arrange to iter-
ate over an arbitrary arithmetic sequence of integers, namely i = first, first
+ step, ..., first + ⌊(last −first)/step⌋× step.
■
Following the lead of Clu, many modern languages allow enumeration-
controlled loops to iterate over much more general ﬁnite sets—the nodes of a
tree, for example, or the elements of a collection. We consider these more general
iterators in Section 6.5.3. For the moment we focus on arithmetic sequences. For
the sake of simplicity, we use the name “for loop” as a general term, even for
languages that use a different keyword.
```

```
Code Generation for for Loops
```

Naively, the loop of Example 6.57 can be translated as
**EXAMPLE** 6.58

```
Obvious translation of a
for loop
r1 := ﬁrst
r2 := step
r3 := last
L1: if r1 > r3 goto L2
. . .
–– loop body; use r1 for i
r1 := r1 + r2
goto L1
L2:
■
```

```
do {
line = read_line(stdin);
} while (line[0] != '$');
```

■

