246
Chapter 6 Control Flow
6.2
Structured and Unstructured Flow
Control ﬂow in assembly languages is achieved by means of conditional and un-
conditional jumps (branches). Early versions of Fortran mimicked the low-level
EXAMPLE 6.39
Control ﬂow with gotos in
Fortran
approach by relying heavily on goto statements for most nonprocedural control
ﬂow:
if (A .lt. B) goto 10
! ".lt." means "<"
...
10
The 10 on the bottom line is a statement label. Goto statements also featured
prominently in other early imperative languages.
■
Beginning in the late 1960s, largely in response to an article by Edsger Dijk-
stra [Dij68b],6 language designers hotly debated the merits and evils of gotos.
It seems fair to say the detractors won. Ada and C# allow gotos only in limited
contexts. Modula (1, 2, and 3), Clu, Eiffel, Java, and most of the scripting lan-
guages do not allow them at all. Fortran 90 and C++ allow them primarily for
compatibility with their predecessor languages. (Java reserves the token goto as
a keyword, to make it easier for a Java compiler to produce good error messages
when a programmer uses a C++ goto by mistake.)
The abandonment of gotos was part of a larger “revolution” in software en-
gineering known as structured programming. Structured programming was the
“hot trend” of the 1970s, in much the same way that object-oriented program-
ming was the trend of the 1990s. Structured programming emphasizes top-down
design (i.e., progressive reﬁnement), modularization of code, structured types
(records, sets, pointers, multidimensional arrays), descriptive variable and con-
stant names, and extensive commenting conventions. The developers of struc-
tured programming were able to demonstrate that within a subroutine, almost
any well-designed imperative algorithm can be elegantly expressed with only se-
quencing, selection, and iteration. Instead of labels, structured languages rely on
the boundaries of lexically nested constructs as the targets of branching control.
Many of the structured control-ﬂow constructs familiar to modern program-
mers were pioneered by Algol 60. These include the if... then ... else con-
struct and both enumeration (for) and logically (while) controlled loops. The
modern case (switch) statement was introduced by Wirth and Hoare in Al-
gol W [WH66] as an alternative to the more unstructured computed goto and
switch constructs of Fortran and Algol 60, respectively. (The switch statement
of C bears a closer resemblance to the Algol W case statement than to the Algol
60 switch.)
6
Edsger W. Dijkstra (1930–2002) developed much of the logical foundation of our modern un-
derstanding of concurrency. He was also responsible, among many other contributions, for the
semaphores of Section 13.3.5 and for much of the practical development of structured program-
ming. He received the ACM Turing Award in 1972.
6.2 Structured and Unstructured Flow
247
6.2.1 Structured Alternatives to goto
Once the principal structured constructs had been deﬁned, most of the contro-
versy surrounding gotos revolved around a small number of special cases, each
of which was eventually addressed in structured ways. Where once a goto might
have been used to jump to the end of the current subroutine, most modern lan-
guages provide an explicit return statement. Where once a goto might have
been used to escape from the middle of a loop, most modern languages provide a
break or exit statement for this purpose. (Some languages also provide a state-
ment that will skip the remainder of the current iteration only: continue in C;
cycle in Fortran 90; next in Perl.) More signiﬁcantly, several languages allow
a program to return from a nested chain of subroutine calls in a single opera-
tion, and many provide a way to raise an exception that propagates out to some
surrounding context. Both of these capabilities might once have been attempted
with (nonlocal) gotos.
Multilevel Returns
Returns and (local) gotos allow control to return from the current subroutine.
On occasion it may make sense to return from a surrounding routine. Imagine, for
EXAMPLE 6.40
Escaping a nested
subroutine
example, that we are searching for an item matching some desired pattern within
a collection of ﬁles. The search routine might invoke several nested routines, or
a single routine multiple times, once for each place in which to search. In such a
situation certain historic languages, including Algol 60, PL/I, and Pascal, permit-
ted a goto to branch to a lexically visible label outside the current subroutine:
function search(key : string) : string;
var rtn : string;
...
procedure search_file(fname : string);
...
begin
...
for ... (* iterate over lines *)
...
if found(key, line) then begin
rtn := line;
goto 100;
end;
...
end;
...
begin (* search *)
...
248
Chapter 6 Control Flow
for ... (* iterate over files *)
...
search_file(fname);
...
100:
return rtn;
end;
■
In the event of a nonlocal goto, the language implementation must guarantee
to repair the run-time stack of subroutine call information. This repair operation
is known as unwinding. It requires not only that the implementation deallocate
the stack frames of any subroutines from which we have escaped, but also that
it perform any bookkeeping operations, such as restoration of register contents,
that would have been performed when returning from those routines.
As a more structured alternative to the nonlocal goto, Common Lisp provides
a return-from statement that names the lexically surrounding function or block
from which to return, and also supplies a return value (eliminating the need for
the artiﬁcial rtn variable in Example 6.40).
But what if search_file were not nested inside of search? We might, for
example, wish to call it from routines that search ﬁles in different orders. Algol 60,
Algol 68, and PL/I allowed labels to be passed as parameters, so a dynamically
nested subroutine could perform a goto to a caller-deﬁned location. Common
EXAMPLE 6.41
Structured nonlocal
transfers
Lisp again provides a more structured alternative, also available in Ruby. In either
language an expression can be surrounded with a catch block, whose value can
be provided by any dynamically nested routine that executes a matching throw.
In Ruby we might write
def searchFile(fname, pattern)
file = File.open(fname)
file.each {|line|
throw :found, line if line =~ /#{pattern}/
}
end
match = catch :found do
searchFile("f1", key)
searchFile("f2", key)
searchFile("f3", key)
"not found\n"
# default value for catch,
end
# if control gets this far
print match
Here the throw expression speciﬁes a tag, which must appear in a matching
catch, together with a value (line) to be returned as the value of the catch.
(The if clause attached to the throw performs a regular-expression pattern
match, looking for pattern within line. We will consider pattern matching
in more detail in Section 14.4.2.)
■
6.2 Structured and Unstructured Flow
249
Errors and Other Exceptions
The notion of a multilevel return assumes that the callee knows what the caller
expects, and can return an appropriate value. In a related and arguably more
common situation, a deeply nested block or subroutine may discover that it is
unable to proceed with its usual function, and moreover lacks the contextual in-
formation it would need to recover in any graceful way. Eiffel formalizes this
notion by saying that every software component has a contract—a speciﬁcation
of the function it performs. A component that is unable to fulﬁll its contract is
said to fail. Rather than return in the normal way, it must arrange for control to
“back out” to some context in which the program is able to recover. Conditions
that require a program to “back out” are usually called exceptions. We mentioned
an example in Section C 2.3.5, where we considered phrase-level recovery from
syntax errors in a recursive descent parser.
The most straightforward but generally least satisfactory way to cope with ex-
EXAMPLE 6.42
Error checking with status
codes
ceptions is to use auxiliary Boolean variables within a subroutine (if still_ok
then ...) and to return status codes from calls:
status := my_proc(args);
if status = ok then ...
■
The auxiliary Booleans can be eliminated by using a nonlocal goto or multilevel
return, but the caller to which we return must still inspect status codes explic-
itly. As a structured alternative, many modern languages provide an exception-
handling mechanism for convenient, nonlocal recovery from exceptions. We will
discuss exception handling in more detail in Section 9.4. Typically the program-
mer appends a block of code called a handler to any computation in which an
exception may arise. The job of the handler is to take whatever remedial action is
required to recover from the exception. If the protected computation completes
in the normal fashion, execution of the handler is skipped.
Multilevel returns and structured exceptions have strong similarities. Both in-
volve a control transfer from some inner, nested context back to an outer context,
unwinding the stack on the way. The distinction lies in where the computing oc-
curs. In a multilevel return the inner context has all the information it needs. It
completes its computation, generating a return value if appropriate, and transfers
to the outer context in a way that requires no post-processing. At an exception,
by contrast, the inner context cannot complete its work—it cannot fulﬁll its con-
tract. It performs an “abnormal” return, triggering execution of the handler.
Common Lisp and Ruby provide mechanisms for both multilevel returns and
exceptions, but this dual support is relatively rare. Most languages support only
exceptions; programmers implement multilevel returns by writing a trivial han-
dler. In an unfortunate overloading of terminology, the names catch and throw,
which Common Lisp and Ruby use for multilevel returns, are used for exceptions
in several other languages.
250
Chapter 6 Control Flow
6.2.2 Continuations
The notion of nonlocal gotos that unwind the stack can be generalized by deﬁn-
ing what are known as continuations. In low-level terms, a continuation con-
sists of a code address, a referencing environment that should be established (or
restored) when jumping to that address, and a reference to another continua-
tion that represents what to do in the event of a subsequent subroutine return.
(The chain of return continuations constitutes a backtrace of the run-time stack.)
In higher-level terms, a continuation is an abstraction that captures a context
in which execution might continue. Continuations are fundamental to deno-
tational semantics. They also appear as ﬁrst-class values in several programming
languages (notably Scheme and Ruby), allowing the programmer to deﬁne new
control-ﬂow constructs.
Continuation support in Scheme takes the form of a function named call-
with-current-continuation, often abbreviated call/cc. This function takes
a single argument f , which is itself a function of one argument. Call/cc calls f ,
passing as argument a continuation c that captures the current program counter,
referencing environment, and stack backtrace. The continuation is implemented
as a closure, indistinguishable from the closures used to represent subroutines
passed as parameters. At any point in the future, f can call c, passing it a value, v.
The call will “return” v into c’s captured context, as if it had been returned by the
original call to call/cc.
Ruby support is similar:
EXAMPLE 6.43
A simple Ruby
continuation
def foo(i, c)
printf "start %d; ", i
if i < 3 then foo(i+1, c) else c.call(i) end
printf "end %d; ", i
end
v = callcc { |d| foo(1, d) }
printf "got %d\n", v
Here the parameter to callcc is a block—roughly, a lambda expression. The
block’s parameter is the continuation c, which its body passes, together with the
DESIGN & IMPLEMENTATION
6.4 Cleaning up continuations
The implementation of continuations in Scheme and Ruby is surprisingly
straightforward. Because local variables have unlimited extent in both lan-
guages, activation records must in general be allocated on the heap. As a re-
sult, explicit deallocation of frames in the current context is neither required
nor appropriate when jumping through a continuation: if those frames are
no longer accessible, they will eventually be reclaimed by the standard garbage
collector (more on this in Section 8.5.3).
6.2 Structured and Unstructured Flow
251
number 1, to subroutine foo. The subroutine then calls itself twice recursively
before executing c.call(i). Finally, the call method jumps into the context
captured by c, making i (that is, 3) appear to have been returned by callcc.
The ﬁnal program output is start 1; start 2; start 3; got 3.
■
In this simple example, the jump into the continuation behaved much as an
exception would, popping out of a series of nested calls. But continuations can
do much more. Like other closures, they can be saved in variables, returned from
EXAMPLE 6.44
Continuation reuse and
unlimited extent
subroutines, or called repeatedly, even after control has returned out of the con-
text in which they were created (this means that they require unlimited extent; see
Section 3.6). Consider the following more subtle example:
def here
return callcc { |a| return a }
end
def bar(i)
printf "start %d; ", i
b = if i < 3 then bar(i+1) else here end
printf "end %d; ", i
return b
end
n = 3
c = bar(1)
n -= 1
puts
# print newline
if n > 0 then c.call(c) end
puts "done"
This code performs three nested calls to bar, returning a continuation created by
function here in the middle of the innermost call. Using that continuation, we
can jump back into the nested calls of bar—in fact, we can do so repeatedly. Note
that while c’s captured referencing environment remains the same each time, the
value of n can change. The ﬁnal program output is
start 1; start 2; start 3; end 3; end 2; end 1;
end 3; end 2; end 1;
end 3; end 2; end 1;
done
■
Call/cc sufﬁces to build a wide variety of control abstractions, including
gotos, midloop exits, multilevel returns, exceptions, iterators (Section 6.5.3),
call-by-name parameters (Section 9.3.1), and coroutines (Section 9.5). It even
subsumes the notion of returning from a subroutine, though it seldom replaces
it in practice. Used in a disciplined way, continuations make a language surpris-
ingly extensible. At the same time, they allow the undisciplined programmer to
construct completely inscrutable programs.
