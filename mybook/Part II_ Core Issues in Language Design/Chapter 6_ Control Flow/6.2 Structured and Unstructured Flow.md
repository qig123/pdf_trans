# 6.2 Structured and Unstructured Flow

**246**
Chapter 6* Control Flow*

## 6.2

**Structured and Unstructured Flow**
Control ﬂow in assembly languages is achieved by means of conditional and un-
conditional jumps (branches). Early versions of Fortran mimicked the low-level
**EXAMPLE** 6.39

```
Control ﬂow with gotos in
Fortran
approach by relying heavily on goto statements for most nonprocedural control
ﬂow:
```

```
if (A .lt. B) goto 10
! ".lt." means "<"
...
10
```

```
The 10 on the bottom line is a statement label. Goto statements also featured
prominently in other early imperative languages.
■
Beginning in the late 1960s, largely in response to an article by Edsger Dijk-
stra [Dij68b],6 language designers hotly debated the merits and evils of gotos.
It seems fair to say the detractors won. Ada and C# allow gotos only in limited
contexts. Modula (1, 2, and 3), Clu, Eiffel, Java, and most of the scripting lan-
guages do not allow them at all. Fortran 90 and C++ allow them primarily for
compatibility with their predecessor languages. (Java reserves the token goto as
a keyword, to make it easier for a Java compiler to produce good error messages
when a programmer uses a C++ goto by mistake.)
The abandonment of gotos was part of a larger “revolution” in software en-
gineering known as structured programming. Structured programming was the
“hot trend” of the 1970s, in much the same way that object-oriented program-
ming was the trend of the 1990s. Structured programming emphasizes top-down
design (i.e., progressive reﬁnement), modularization of code, structured types
(records, sets, pointers, multidimensional arrays), descriptive variable and con-
stant names, and extensive commenting conventions. The developers of struc-
tured programming were able to demonstrate that within a subroutine, almost
any well-designed imperative algorithm can be elegantly expressed with only se-
quencing, selection, and iteration. Instead of labels, structured languages rely on
the boundaries of lexically nested constructs as the targets of branching control.
Many of the structured control-ﬂow constructs familiar to modern program-
mers were pioneered by Algol 60. These include the if... then ... else con-
struct and both enumeration (for) and logically (while) controlled loops. The
modern case (switch) statement was introduced by Wirth and Hoare in Al-
gol W [WH66] as an alternative to the more unstructured computed goto and
switch constructs of Fortran and Algol 60, respectively. (The switch statement
of C bears a closer resemblance to the Algol W case statement than to the Algol
60 switch.)
```

**6**
Edsger W. Dijkstra (1930–2002) developed much of the logical foundation of our modern un-
derstanding of concurrency. He was also responsible, among many other contributions, for the
semaphores of Section 13.3.5 and for much of the practical development of structured program-
ming. He received the ACM Turing Award in 1972.

6.4 Cleaning up continuations
The implementation of continuations in Scheme and Ruby is surprisingly
straightforward. Because local variables have unlimited extent in both lan-
guages, activation records must in general be allocated on the heap. As a re-
sult, explicit deallocation of frames in the current context is neither required
nor appropriate when jumping through a continuation: if those frames are
no longer accessible, they will eventually be reclaimed by the standard garbage
collector (more on this in Section 8.5.3).

```
Call/cc sufﬁces to build a wide variety of control abstractions, including
gotos, midloop exits, multilevel returns, exceptions, iterators (Section 6.5.3),
call-by-name parameters (Section 9.3.1), and coroutines (Section 9.5). It even
subsumes the notion of returning from a subroutine, though it seldom replaces
it in practice. Used in a disciplined way, continuations make a language surpris-
ingly extensible. At the same time, they allow the undisciplined programmer to
construct completely inscrutable programs.
```

