294
Chapter 6 Control Flow
6.45 In Examples 6.43 and 6.72 we suggested that a Ruby proc (a block, passed
to a function as an implicit extra argument) was “roughly” equivalent to
a lambda expression. As it turns out, Ruby has both procs and lambda
expressions, and they’re almost—but not quite—the same. Learn about the
details, and the history of their development. In what situations will a proc
and a lambda behave differently, and why?
6.46 One of the most popular idioms for large-scale systems is the so-called vis-
itor pattern. It has several uses, one of which resembles the “iterating with
ﬁrst-class functions” idiom of Examples 6.70 and 6.71. Brieﬂy, elements
of a container class provide an accept method that expects as argument
an object that implements the visitor interface. This interface in turn has
a method named visit that expects an argument of element type. To iter-
ate over a collection, we implement the “loop body” in the visit method of
a visitor object. This object constitutes a closure of the sort described in
Section 3.6.3. Any information that visit needs (beyond the identify of the
“loop index” element) can be encapsulated in the object’s ﬁelds. An itera-
tor method for the collection passes the visitor object to the accept method
of each element. Each element in turn calls the visit method of the visitor
object, passing itself as argument.
Learn more about the visitor pattern. Use it to implement iterators for a
collection—preorder, inorder, and postorder traversals of a binary tree, for
example. How do visitors compare with equivalent iterator-based code? Do
they add new functionality? What else are visitors good for, in addition to
iteration?
6.47–6.50 In More Depth.
6.11
Bibliographic Notes
Many of the issues discussed in this chapter feature prominently in papers on
the history of programming languages. Pointers to several such papers can be
found in the Bibliographic Notes for Chapter 1. Fifteen papers comparing Ada,
C, and Pascal can be found in the collection edited by Feuer and Gehani [FG84].
References for individual languages can be found in Appendix A.
Niklaus Wirth has been responsible for a series of inﬂuential languages over a
30-year period, including Pascal [Wir71], its predecessor Algol W [WH66], and
the successors Modula [Wir77b], Modula-2 [Wir85b], and Oberon [Wir88b].
The case statement of Algol W is due to Hoare [Hoa81]. Bernstein [Ber85]
considers a variety of alternative implementations for case, including multi-
level versions appropriate for label sets consisting of several dense “clusters” of
values. Guarded commands (Section C 6.7) are due to Dijkstra [Dij75]. Duff’s
device (Exploration 6.41) was originally posted to netnews, an early on-line dis-
cussion group system, in May of 1984. The original posting appears to have been
6.11 Bibliographic Notes
295
lost, but Duff’s commentary on it can be found at many Internet sites, including
www.lysator.liu.se/c/duffs-device.html.
Debate over the supposed merits or evils of the goto statement dates from at
least the early 1960s, but became a good bit more heated in the wake of a 1968
article by Dijkstra (“Go To Statement Considered Harmful” [Dij68b]). The struc-
tured programming movement of the 1970s took its name from the text of Dahl,
Dijkstra, and Hoare [DDH72]. A dissenting letter by Rubin in 1987 (“ ‘GOTO
Considered Harmful’ Considered Harmful” [Rub87]; Exercise 6.26) elicited a
ﬂurry of responses.
What has been called the “reference model of variables” in this chapter is called
the “object model” in Clu; Liskov and Guttag describe it in Sections 2.3 and 2.4.2
of their text on abstraction and speciﬁcation [LG86]. Clu iterators are described
in an article by Liskov et al. [LSAS77], and in Chapter 6 of the Liskov and Guttag
text. Icon generators are discussed in Chapters 11 and 14 of the text by Gris-
wold and Griswold [GG96]. Ruby blocks, procs, and iterators are discussed in
Chapter 4 of the text by Thomas et al. [TFH13]. The tree-enumeration algo-
rithm of Exercise 6.22 was originally presented (without iterators) by Solomon
and Finkel [SF80].
Several texts discuss the use of invariants (Exercise 6.28) as a tool for writing
correct programs. Particularly noteworthy are the works of Dijkstra [Dij76] and
Gries [Gri81]. Kernighan and Plauger provide a more informal discussion of the
art of writing good programs [KP78].
The Blizzard [SFL+94] and Shasta [SG96] systems for software distributed
shared memory (S-DSM) make use of sentinels (Exercise 6.10). We will discuss
S-DSM in Section 13.2.1.
Michaelson [Mic89, Chap. 8] provides an accessible formal treatment of
applicative-order, normal-order, and lazy evaluation. The concept of memoiza-
tion is originally due to Michie [Mic68]. Friedman, Wand, and Haynes provide
an excellent discussion of continuation-passing style [FWH01, Chaps. 7–8].
This page intentionally left blank
