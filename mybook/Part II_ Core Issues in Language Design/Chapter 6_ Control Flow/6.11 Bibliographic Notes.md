# 6.11 Bibliographic Notes

**294**
Chapter 6* Control Flow*

6.45 In Examples 6.43 and 6.72 we suggested that a Ruby* proc* (a block, passed
to a function as an implicit extra argument) was “roughly” equivalent to
a lambda expression. As it turns out, Ruby has both procs* and* lambda
expressions, and they’re almost—but not quite—the same. Learn about the
details, and the history of their development. In what situations will a proc
and a lambda behave differently, and why?
6.46 One of the most popular idioms for large-scale systems is the so-called* vis-*
*itor pattern*. It has several uses, one of which resembles the “iterating with
ﬁrst-class functions” idiom of Examples 6.70 and 6.71. Brieﬂy, elements
of a container class provide an accept method that expects as argument
an object that implements the visitor interface. This interface in turn has
a method named visit that expects an argument of element type. To iter-
ate over a collection, we implement the “loop body” in the visit method of
a visitor object. This object constitutes a closure of the sort described in
Section 3.6.3. Any information that visit needs (beyond the identify of the
“loop index” element) can be encapsulated in the object’s ﬁelds. An itera-
tor method for the collection passes the visitor object to the accept method
of each element. Each element in turn calls the visit method of the visitor
object, passing itself as argument.
Learn more about the visitor pattern. Use it to implement iterators for a
collection—preorder, inorder, and postorder traversals of a binary tree, for
example. How do visitors compare with equivalent iterator-based code? Do
they add new functionality? What else are visitors good for, in addition to
iteration?
6.47–6.50 In More Depth.
## 6.11

**Bibliographic Notes**
```
Many of the issues discussed in this chapter feature prominently in papers on
the history of programming languages. Pointers to several such papers can be
found in the Bibliographic Notes for Chapter 1. Fifteen papers comparing Ada,
C, and Pascal can be found in the collection edited by Feuer and Gehani [FG84].
References for individual languages can be found in Appendix A.
Niklaus Wirth has been responsible for a series of inﬂuential languages over a
30-year period, including Pascal [Wir71], its predecessor Algol W [WH66], and
the successors Modula [Wir77b], Modula-2 [Wir85b], and Oberon [Wir88b].
The case statement of Algol W is due to Hoare [Hoa81]. Bernstein [Ber85]
considers a variety of alternative implementations for case, including multi-
level versions appropriate for label sets consisting of several dense “clusters” of
values. Guarded commands (Section C 6.7) are due to Dijkstra [Dij75]. Duff’s
device (Exploration 6.41) was originally posted to netnews, an early on-line dis-
cussion group system, in May of 1984. The original posting appears to have been
```

