# 6.8 Summary and Concluding Remarks

**284**
Chapter 6* Control Flow*

is deliberately unspeciﬁed. We have already seen examples of nondeterminacy
in the evaluation of expressions (Section 6.1.4): in most languages, operator or
subroutine arguments may be evaluated in any order. Some languages, notably
Algol 68 and various concurrent languages, provide more extensive nondetermin-
istic mechanisms, which cover statements as well.

**IN MORE DEPTH**

Further discussion of nondeterminism can be found on the companion site. Ab-
sent a nondeterministic construct, the author of a code fragment in which order
does not matter must choose some arbitrary (artiﬁcial) order. Such a choice can
make it more difﬁcult to construct a formal correctness proof. Some language
designers have also argued that it is inelegant. The most compelling uses for non-
determinacy arise in concurrent programs, where imposing an arbitrary choice
on the order in which a thread interacts with its peers may cause the system as a
whole to deadlock. For such programs one may need to ensure that the choice
among nondeterministic alternatives is* fair* in some formal sense.

```
3CHECK YOUR UNDERSTANDING
39. What is a tail-recursive function? Why is tail recursion important?
40. Explain the difference between applicative- and normal-order evaluation of
expressions. Under what circumstances is each desirable?
41. What is lazy evaluation? What are promises? What is memoization?
```

42. Give two reasons why lazy evaluation may be desirable.
43. Name a language in which parameters are always evaluated lazily.

44. Give two reasons why a programmer might sometimes want control ﬂow to
be* nondeterministic*.

## 6.8

**Summary and Concluding Remarks**
In this chapter we introduced the principal forms of control ﬂow found in pro-
gramming languages: sequencing, selection, iteration, procedural abstraction,
recursion, concurrency, exception handling and speculation, and nondetermi-
nacy. Sequencing speciﬁes that certain operations are to occur in order, one after
the other. Selection expresses a choice among two or more control-ﬂow alter-
natives. Iteration and recursion are the two ways to execute operations repeat-
edly. Recursion deﬁnes an operation in terms of simpler instances of itself; it
depends on procedural abstraction. Iteration repeats an operation for its side

