284
Chapter 6 Control Flow
is deliberately unspeciﬁed. We have already seen examples of nondeterminacy
in the evaluation of expressions (Section 6.1.4): in most languages, operator or
subroutine arguments may be evaluated in any order. Some languages, notably
Algol 68 and various concurrent languages, provide more extensive nondetermin-
istic mechanisms, which cover statements as well.
IN MORE DEPTH
Further discussion of nondeterminism can be found on the companion site. Ab-
sent a nondeterministic construct, the author of a code fragment in which order
does not matter must choose some arbitrary (artiﬁcial) order. Such a choice can
make it more difﬁcult to construct a formal correctness proof. Some language
designers have also argued that it is inelegant. The most compelling uses for non-
determinacy arise in concurrent programs, where imposing an arbitrary choice
on the order in which a thread interacts with its peers may cause the system as a
whole to deadlock. For such programs one may need to ensure that the choice
among nondeterministic alternatives is fair in some formal sense.
3CHECK YOUR UNDERSTANDING
39. What is a tail-recursive function? Why is tail recursion important?
40. Explain the difference between applicative- and normal-order evaluation of
expressions. Under what circumstances is each desirable?
41. What is lazy evaluation? What are promises? What is memoization?
42. Give two reasons why lazy evaluation may be desirable.
43. Name a language in which parameters are always evaluated lazily.
44. Give two reasons why a programmer might sometimes want control ﬂow to
be nondeterministic.
6.8
Summary and Concluding Remarks
In this chapter we introduced the principal forms of control ﬂow found in pro-
gramming languages: sequencing, selection, iteration, procedural abstraction,
recursion, concurrency, exception handling and speculation, and nondetermi-
nacy. Sequencing speciﬁes that certain operations are to occur in order, one after
the other. Selection expresses a choice among two or more control-ﬂow alter-
natives. Iteration and recursion are the two ways to execute operations repeat-
edly. Recursion deﬁnes an operation in terms of simpler instances of itself; it
depends on procedural abstraction. Iteration repeats an operation for its side
6.8 Summary and Concluding Remarks
285
effect(s). Sequencing and iteration are fundamental to imperative programming.
Recursion is fundamental to functional programming. Nondeterminacy allows
the programmer to leave certain aspects of control ﬂow deliberately unspeciﬁed.
We touched on concurrency only brieﬂy; it will be the subject of Chapter 13.
Procedural abstractions (subroutines) are the subject of Chapter 9. Exception
handling and speculation will be covered in Sections 9.4 and 13.4.4.
Our survey of control-ﬂow mechanisms was preceded by a discussion of ex-
pression evaluation. We considered the distinction between l-values and r-values,
and between the value model of variables, in which a variable is a named con-
tainer for data, and the reference model of variables, in which a variable is a ref-
erence to a data object. We considered issues of precedence, associativity, and
ordering within expressions. We examined short-circuit Boolean evaluation and
its implementation via jump code, both as a semantic issue that affects the cor-
rectness of expressions whose subparts are not always well deﬁned, and as an
implementation issue that affects the time required to evaluate complex Boolean
expressions.
In our survey we encountered many examples of control-ﬂow constructs
whose syntax and semantics have evolved considerably over time. An important
early example was the phasing out of goto-based control ﬂow and the emergence
of a consensus on structured alternatives. While convenience and readability are
difﬁcult to quantify, most programmers would agree that the control-ﬂow con-
structs of a language like Ada are a dramatic improvement over those of, say,
Fortran IV. Examples of features in Ada that are speciﬁcally designed to rectify
control-ﬂow problems in earlier languages include explicit terminators (end if,
end loop, etc.) for structured constructs; elsif clauses; label ranges and default
(others) clauses in case statements; implicit declaration of for loop indices as
read-only local variables; explicit return statements; multilevel loop exit state-
ments; and exceptions.
The evolution of constructs has been driven by many goals, including ease
of programming, semantic elegance, ease of implementation, and run-time ef-
ﬁciency. In some cases these goals have proved complementary. We have seen
for example that short-circuit evaluation leads both to faster code and (in many
cases) to cleaner semantics. In a similar vein, the introduction of a new local
scope for the index variable of an enumeration-controlled loop avoids both the
semantic problem of the value of the index after the loop and (to some extent)
the implementation problem of potential overﬂow.
In other cases improvements in language semantics have been considered
worth a small cost in run-time efﬁciency. We saw this in the development of
iterators: like many forms of abstraction, they add a modest amount of run-time
cost in many cases (e.g., in comparison to explicitly embedding the implementa-
tion of the enumerated collection in the control ﬂow of the loop), but with a large
pay-back in modularity, clarity, and opportunities for code reuse. In a similar
vein, the developers of Java would argue that for many applications the portabil-
ity and safety provided by extensive semantic checking, standard-format numeric
types, and so on are far more important than speed.
