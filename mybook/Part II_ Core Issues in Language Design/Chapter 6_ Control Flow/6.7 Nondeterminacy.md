# 6.7 Nondeterminacy

6.7 Nondeterminacy 283

evaluation in the form of built-in functions called delay and force.10 These functions provide an implementation of lazy evaluation. In the absence of side effects, lazy evaluation has the same semantics as normal-order evaluation, but the implementation keeps track of which expressions have already been evaluated, so it can reuse their values if they are needed more than once in a given referencing environment. A delayed expression is sometimes called a promise. The mechanism used to keep track of which promises have already been evaluated is sometimes called memoization.11 Because applicative-order evaluation is the default in Scheme, the programmer must use special syntax not only to pass an unevaluated argument, but also to use it. In Algol 60, subroutine headers indicate which arguments are to be passed which way; the point of call and the uses of parameters within sub- routines look the same in either case. One important use of lazy evaluation is to create so-called inﬁnite or lazy data structures, which are “ﬂeshed out” on demand. The following example, adapted EXAMPLE 6.88

Lazy evaluation of an inﬁnite data structure from version 5 of the Scheme manual [KCR+98, p. 28], creates a “list” of all the natural numbers:

(define naturals (letrec ((next (lambda (n) (cons n (delay (next (+ n 1))))))) (next 1))) (define head car) (define tail (lambda (stream) (force (cdr stream))))

Here cons can be thought of, roughly, as a concatenation operator. Car returns the head of a list; cdr returns everything but the head. Given these deﬁnitions, we can access as many natural numbers as we want:

(head naturals) =⇒1 (head (tail naturals)) =⇒2 (head (tail (tail naturals))) =⇒3

The list will occupy only as much space as we have actually explored. More elab- orate lazy data structures (e.g., trees) can be valuable in combinatorial search problems, in which a clever algorithm may explore only the “interesting” parts of a potentially enormous search space. ■ 6.7 Nondeterminacy

Our ﬁnal category of control ﬂow is nondeterminacy. A nondeterministic con- struct is one in which the choice between alternatives (i.e., between control paths)

10 More precisely, delay is a special form, rather than a function. Its argument is passed to it un- evaluated.

11 Within the functional programming community, the term “lazy evaluation” is often used for any implementation that declines to evaluate unneeded function parameters; this includes both naive implementations of normal-order evaluation and the memoizing mechanism described here.

