6.6 Recursion
277
30. Why do many languages require the step size of an enumeration-controlled
loop to be a compile-time constant?
31. Describe the “iteration count” loop implementation. What problem(s) does
it solve?
32. What are the advantages of making an index variable local to the loop it con-
trols?
33. Does C have enumeration-controlled loops? Explain.
34. What is a collection (a container instance)?
35. Explain the difference between true iterators and iterator objects.
36. Cite two advantages of iterator objects over the use of programming conven-
tions in a language like C.
37. Describe the approach to iteration typically employed in languages with ﬁrst-
class functions.
38. Give an example in which a mid-test loop results in more elegant code than
does a pretest or post-test loop.
6.6
Recursion
Unlike the control-ﬂow mechanisms discussed so far, recursion requires no spe-
cial syntax. In any language that provides subroutines (particularly functions), all
that is required is to permit functions to call themselves, or to call other functions
that then call them back in turn. Most programmers learn in a data structures
class that recursion and (logically controlled) iteration provide equally powerful
means of computing functions: any iterative algorithm can be rewritten, auto-
matically, as a recursive algorithm, and vice versa. We will compare iteration and
recursion in more detail in the ﬁrst subsection below. In the following subsection
we will consider the possibility of passing unevaluated expressions into a func-
tion. While usually inadvisable, due to implementation cost, this technique will
sometimes allow us to write elegant code for functions that are only deﬁned on a
subset of the possible inputs, or that explore logically inﬁnite data structures.
6.6.1 Iteration and Recursion
As we noted in Section 3.2, Fortran 77 and certain other languages do not permit
recursion. A few functional languages do not permit iteration. Most modern
languages, however, provide both mechanisms. Iteration is in some sense the
more “natural” of the two in imperative languages, because it is based on the
repeated modiﬁcation of variables. Recursion is the more natural of the two in
278
Chapter 6 Control Flow
functional languages, because it does not change variables. In the ﬁnal analysis,
which to use in which circumstance is mainly a matter of taste. To compute a
EXAMPLE 6.80
A “naturally iterative”
problem
sum,

1≤i≤10
f (i)
it seems natural to use iteration. In C one would say
typedef int (*int_func) (int);
int summation(int_func f, int low, int high) {
/* assume low <= high */
int total = 0;
int i;
for (i = low; i <= high; i++) {
total += f(i);
// (C will automatically dereference
// a function pointer when we attempt to call it.)
}
return total;
}
■
To compute a value deﬁned by a recurrence,
EXAMPLE 6.81
A “naturally recursive”
problem
gcd(a, b)
(positive integers, a, b)
≡
⎧
⎨
a
if a = b
gcd(a−b, b)
if a > b
gcd(a, b−a)
if b > a
⎩
recursion may seem more natural:
int gcd(int a, int b) {
/* assume a, b > 0 */
if (a == b) return a;
else if (a > b) return gcd(a-b, b);
else return gcd(a, b-a);
}
■
In both these cases, the choice could go the other way:
EXAMPLE 6.82
Implementing problems
“the other way”
typedef int (*int_func) (int);
int summation(int_func f, int low, int high) {
/* assume low <= high */
if (low == high) return f(low);
else return f(low) + summation(f, low+1, high);
}
6.6 Recursion
279
int gcd(int a, int b) {
/* assume a, b > 0 */
while (a != b) {
if (a > b) a = a-b;
else b = b-a;
}
return a;
}
■
Tail Recursion
It is sometimes argued that iteration is more efﬁcient than recursion. It is more
accurate to say that naive implementation of iteration is usually more efﬁcient
than naive implementation of recursion. In the examples above, the iterative im-
plementations of summation and greatest divisors will be more efﬁcient than the
recursive implementations if the latter make real subroutine calls that allocate
space on a run-time stack for local variables and bookkeeping information. An
“optimizing” compiler, however, particularly one designed for a functional lan-
guage, will often be able to generate excellent code for recursive functions. It
is particularly likely to do so for tail-recursive functions such as gcd above. A
tail-recursive function is one in which additional computation never follows a re-
cursive call: the return value is simply whatever the recursive call returns. For
such functions, dynamically allocated stack space is unnecessary: the compiler
can reuse the space belonging to the current iteration when it makes the recursive
call. In effect, a good compiler will recast the recursive gcd function above as
EXAMPLE 6.83
Iterative implementation of
tail recursion
follows:
int gcd(int a, int b) {
/* assume a, b > 0 */
start:
if (a == b) return a;
else if (a > b) {
a = a-b; goto start;
} else {
b = b-a; goto start;
}
}
■
Even for functions that are not tail-recursive, automatic, often simple trans-
formations can produce tail-recursive code. The general case of the transforma-
tion employs conversion to what is known as continuation-passing style [FWH01,
Chaps. 7–8]. In effect, a recursive function can always avoid doing any work after
returning from a recursive call by passing that work into the recursive call, in the
form of a continuation.
Some speciﬁc transformations (not based on continuation passing) are often
employed by skilled users of functional languages. Consider, for example, the
EXAMPLE 6.84
By-hand creation of
tail-recursive code
recursive summation function above, written here in Scheme:
280
Chapter 6 Control Flow
(define summation
(lambda (f low high)
(if (= low high)
(f low)
; then part
(+ (f low) (summation f (+ low 1) high)))))
; else part
Recall that Scheme, like all Lisp dialects, uses Cambridge Polish notation for ex-
pressions. The lambda keyword is used to introduce a function. As recursive calls
return, our code calculates the sum from “right to left”: from high down to low.
If the programmer (or compiler) recognizes that addition is associative, we can
rewrite the code in a tail-recursive form:
(define summation
(lambda (f low high subtotal)
(if (= low high)
(+ subtotal (f low))
(summation f (+ low 1) high (+ subtotal (f low))))))
Here the subtotal parameter accumulates the sum from left to right, passing it
into the recursive calls. Because it is tail recursive, this function can be translated
into machine code that does not allocate stack space for recursive calls. Of course,
the programmer won’t want to pass an explicit subtotal parameter to the initial
call, so we hide it (the parameter) in an auxiliary, “helper” function:
(define summation
(lambda (f low high)
(letrec ((sum-helper
(lambda (low subtotal)
(let ((new_subtotal (+ subtotal (f low))))
(if (= low high)
new_subtotal
(sum-helper (+ low 1) new_subtotal))))))
(sum-helper low 0))))
The let construct in Scheme serves to introduce a nested scope in which local
names (e.g., new_subtotal) can be deﬁned. The letrec construct permits the
deﬁnition of recursive functions (e.g., sum-helper).
■
Thinking Recursively
Detractors of functional programming sometimes argue, incorrectly, that recur-
sion leads to algorithmically inferior programs. Fibonacci numbers, for example,
EXAMPLE 6.85
Naive recursive Fibonacci
function
are deﬁned by the mathematical recurrence
Fn
(non-negative integer n)
≡
 1
if n = 0 or n = 1
Fn−1 + Fn−2
otherwise
The naive way to implement this recurrence in Scheme is
6.6 Recursion
281
(define fib
(lambda (n)
(cond ((= n 0) 1)
((= n 1) 1)
(#t (+ (fib (- n 1)) (fib (- n 2)))))))
; #t means 'true' in Scheme
■
Unfortunately, this algorithm takes exponential time, when linear time is possi-
ble.9 In C, one might write
EXAMPLE 6.86
Linear iterative Fibonacci
function
int fib(int n) {
int f1 = 1; int f2 = 1;
int i;
for (i = 2; i <= n; i++) {
int temp = f1 + f2;
f1 = f2; f2 = temp;
}
return f2;
}
■
One can write this iterative algorithm in Scheme: the language includes (non-
functional) iterative features. It is probably better, however, to draw inspiration
EXAMPLE 6.87
Efﬁcient tail-recursive
Fibonacci function
from the tail-recursive version of the summation example above, and write the
following O(n) recursive function:
(define fib
(lambda (n)
(letrec ((fib-helper
(lambda (f1 f2 i)
(if (= i n)
f2
(fib-helper f2 (+ f1 f2) (+ i 1))))))
(fib-helper 0 1 0))))
For a programmer accustomed to writing in a functional style, this code is per-
fectly natural. One might argue that it isn’t “really” recursive; it simply casts an
iterative algorithm in a tail-recursive form, and this argument has some merit.
Despite the algorithmic similarity, however, there is an important difference be-
tween the iterative algorithm in C and the tail-recursive algorithm in Scheme: the
latter has no side effects. Each recursive call of the fib-helper function creates
a new scope, containing new variables. The language implementation may be
able to reuse the space occupied by previous instances of the same scope, but it
guarantees that this optimization will never introduce bugs.
■
9
Actually, one can do substantially better than linear time using algorithms based on binary matrix
multiplication or closest-integer rounding of continuous functions, but these approaches suffer
from high constant-factor costs or problems with numeric precision. For most purposes the
linear-time algorithm is a reasonable choice.
282
Chapter 6 Control Flow
6.6.2 Applicative- and Normal-Order Evaluation
Throughout the discussion so far we have assumed implicitly that arguments are
evaluated before passing them to a subroutine. This need not be the case. It is
possible to pass a representation of the unevaluated arguments to the subroutine
instead, and to evaluate them only when (if) the value is actually needed. The for-
mer option (evaluating before the call) is known as applicative-order evaluation;
the latter (evaluating only when the value is actually needed) is known as normal-
order evaluation. Normal-order evaluation is what naturally occurs in macros
(Section 3.7). It also occurs in short-circuit Boolean evaluation (Section 6.1.5),
call-by-name parameters (to be discussed in Section 9.3.1), and certain functional
languages (to be discussed in Section 11.5).
Algol 60 uses normal-order evaluation by default for user-deﬁned functions
(applicative order is also available). This choice was presumably made to mimic
the behavior of macros (Section 3.7). Most programmers in 1960 wrote mainly
in assembler, and were accustomed to macro facilities. Because the parameter-
passing mechanisms of Algol 60 are part of the language, rather than textual ab-
breviations, problems like misinterpreted precedence or naming conﬂicts do not
arise. Side effects, however, are still very much an issue. We will discuss Algol 60
parameters in more detail in Section 9.3.1.
Lazy Evaluation
From the points of view of clarity and efﬁciency, applicative-order evaluation is
generally preferable to normal-order evaluation. It is therefore natural for it to
be employed in most languages. In some circumstances, however, normal-order
evaluation can actually lead to faster code, or to code that works when applicative-
order evaluation would lead to a run-time error. In both cases, what matters is
that normal-order evaluation will sometimes not evaluate an argument at all, if
its value is never actually needed. Scheme provides for optional normal-order
DESIGN & IMPLEMENTATION
6.10 Normal-order evaluation
Normal-order evaluation is one of many examples we have seen where ar-
guably desirable semantics have been dismissed by language designers because
of fear of implementation cost. Other examples in this chapter include side-
effect freedom (which allows normal order to be implemented via lazy evalu-
ation), iterators (Section 6.5.3), and nondeterminacy (Section 6.7). As noted
in Sidebar 6.2, however, there has been a tendency over time to trade a bit of
speed for cleaner semantics and increased reliability. Within the functional
programming community, Haskell and its predecessor Miranda are entirely
side-effect free, and use normal-order (lazy) evaluation for all parameters.
