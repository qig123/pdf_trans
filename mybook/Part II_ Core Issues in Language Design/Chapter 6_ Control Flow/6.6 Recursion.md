# 6.6 Recursion

6.6 Recursion
**277**

30. Why do many languages require the step size of an enumeration-controlled
loop to be a compile-time constant?
31. Describe the “iteration count” loop implementation. What problem(s) does
it solve?
32. What are the advantages of making an index variable local to the loop it con-
trols?

33. Does C have enumeration-controlled loops? Explain.
34. What is a* collection* (a* container* instance)?
35. Explain the difference between true iterators and iterator objects.

36. Cite two advantages of iterator objects over the use of programming conven-
tions in a language like C.

37. Describe the approach to iteration typically employed in languages with ﬁrst-
class functions.
38. Give an example in which a* mid-test* loop results in more elegant code than
does a pretest or post-test loop.

## 6.6

**Recursion**
Unlike the control-ﬂow mechanisms discussed so far, recursion requires no spe-
cial syntax. In any language that provides subroutines (particularly functions), all
that is required is to permit functions to call themselves, or to call other functions
that then call them back in turn. Most programmers learn in a data structures
class that recursion and (logically controlled) iteration provide equally powerful
means of computing functions: any iterative algorithm can be rewritten, auto-
matically, as a recursive algorithm, and vice versa. We will compare iteration and
recursion in more detail in the ﬁrst subsection below. In the following subsection
we will consider the possibility of passing* unevaluated* expressions into a func-
tion. While usually inadvisable, due to implementation cost, this technique will
sometimes allow us to write elegant code for functions that are only deﬁned on a
subset of the possible inputs, or that explore logically inﬁnite data structures.

6.6.1** Iteration and Recursion**

As we noted in Section 3.2, Fortran 77 and certain other languages do not permit
recursion. A few functional languages do not permit iteration. Most modern
languages, however, provide both mechanisms. Iteration is in some sense the
more “natural” of the two in imperative languages, because it is based on the
repeated modiﬁcation of variables. Recursion is the more natural of the two in

⎧
⎨

⎩

*a*
if* a* =* b*
gcd(*a**−**b**,** b*)
if* a** >** b*
gcd(*a**,** b**−**a*)
if* b** >** a*

### recursion may seem more natural:

```
int gcd(int a, int b) {
/* assume a, b > 0 */
if (a == b) return a;
else if (a > b) return gcd(a-b, b);
else return gcd(a, b-a);
}
■
```

### In both these cases, the choice could go the other way:

**EXAMPLE** 6.82
```
Implementing problems
“the other way”
typedef int (*int_func) (int);
int summation(int_func f, int low, int high) {
/* assume low <= high */
if (low == high) return f(low);
else return f(low) + summation(f, low+1, high);
}
```

