# 6.10 Explorations

**292**
Chapter 6* Control Flow*

consisting of an element and an iterator. As in that previous exercise,
your implementation should support expressions like

```
(for-iter (lambda (e) (display e) (newline)) (uptoby 10 50 3))
```

```
Where the implementation of uptoby in Exercise 6.34 required the use
of delay and force, however, you should provide an iterator macro
(a Scheme special form) and a yield function that allows uptoby to
look like an ordinary tail-recursive function with an embedded yield:
```

```
(define uptoby
(iterator (low high step)
(letrec ((helper (lambda (next)
(if (> next high) '()
(begin
; else clause
(yield next)
(helper (+ next step)))))))
(helper low))))
```

6.36–6.40 In More Depth.
## 6.10

**Explorations**
6.41* Loop unrolling* (described in Exercise C 5.21 and Section C 17.7.1) is a code
transformation that replicates the body of a loop and reduces the number
of iterations, thereby decreasing loop overhead and increasing opportuni-
ties to improve the performance of the processor pipeline by reordering in-
structions. Unrolling is traditionally implemented by the code improve-
ment phase of a compiler. It can be implemented at source level, however, if
we are faced with the prospect of “hand optimizing” time-critical code on a
system whose compiler is not up to the task. Unfortunately, if we replicate
the body of a loop* k* times, we must deal with the possibility that the original
number of loop iterations,* n*, may not be a multiple of* k*. Writing in C, and
letting* k* = 4, we might transform the main loop of Exercise C 5.21 from

```
i = 0;
do {
sum += A[i]; squares += A[i] * A[i]; i++;
} while (i < N);
```

to

