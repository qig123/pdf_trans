# 6.10 Explorations

consisting of an element and an iterator. As in that previous exercise, your implementation should support expressions like

(for-iter (lambda (e) (display e) (newline)) (uptoby 10 50 3))

Where the implementation of uptoby in Exercise 6.34 required the use of delay and force, however, you should provide an iterator macro (a Scheme special form) and a yield function that allows uptoby to look like an ordinary tail-recursive function with an embedded yield:

(define uptoby (iterator (low high step) (letrec ((helper (lambda (next) (if (> next high) '() (begin ; else clause (yield next) (helper (+ next step))))))) (helper low))))

6.36–6.40 In More Depth. 6.10 Explorations

6.41 Loop unrolling (described in Exercise C 5.21 and Section C 17.7.1) is a code transformation that replicates the body of a loop and reduces the number of iterations, thereby decreasing loop overhead and increasing opportuni- ties to improve the performance of the processor pipeline by reordering in- structions. Unrolling is traditionally implemented by the code improve- ment phase of a compiler. It can be implemented at source level, however, if we are faced with the prospect of “hand optimizing” time-critical code on a system whose compiler is not up to the task. Unfortunately, if we replicate the body of a loop k times, we must deal with the possibility that the original number of loop iterations, n, may not be a multiple of k. Writing in C, and letting k = 4, we might transform the main loop of Exercise C 5.21 from

i = 0; do { sum += A[i]; squares += A[i] * A[i]; i++; } while (i < N);

to

i = 0; j = N/4; do { sum += A[i]; squares += A[i] * A[i]; i++; sum += A[i]; squares += A[i] * A[i]; i++; sum += A[i]; squares += A[i] * A[i]; i++; sum += A[i]; squares += A[i] * A[i]; i++; } while (--j > 0); do { sum += A[i]; squares += A[i] * A[i]; i++; } while (i < N);

In 1983, Tom Duff of Lucasﬁlm realized that code of this sort can be “simpliﬁed” in C by interleaving a switch statement and a loop. The result is rather startling, but perfectly valid C. It’s known in programming folklore as “Duff’s device”:

i = 0; j = (N+3)/4; switch (N%4) { case 0: do{ sum += A[i]; squares += A[i] * A[i]; i++; case 3: sum += A[i]; squares += A[i] * A[i]; i++; case 2: sum += A[i]; squares += A[i] * A[i]; i++; case 1: sum += A[i]; squares += A[i] * A[i]; i++; } while (--j > 0); }

Duff announced his discovery with “a combination of pride and revulsion.” He noted that “Many people... have said that the worst feature of C is that switches don’t break automatically before each case label. This code forms some sort of argument in that debate, but I’m not sure whether it’s for or against.” What do you think? Is it reasonable to interleave a loop and a switch in this way? Should a programming language permit it? Is automatic fall-through ever a good idea? 6.42 Using your favorite language and compiler, investigate the order of evalu- ation of subroutine parameters. Are they usually evaluated left-to-right or right-to-left? Are they ever evaluated in the other order? (Can you be sure?) Write a program in which the order makes a difference in the results of the computation. 6.43 Consider the different approaches to arithmetic overﬂow adopted by Pascal, C, Java, C#, and Common Lisp, as described in Section 6.1.4. Speculate as to the differences in language design goals that might have caused the designers to adopt the approaches they did. 6.44 Learn more about container classes and the design patterns (structured pro- gramming idioms) they support. Explore the similarities and differences among the standard container libraries of C++, Java, and C#. Which of these libraries do you ﬁnd the most appealing? Why?

