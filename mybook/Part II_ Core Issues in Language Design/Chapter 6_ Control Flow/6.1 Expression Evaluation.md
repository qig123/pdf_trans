# 6.1 Expression Evaluation

**224**
Chapter 6* Control Flow*

dition turns out to be false, execution branches to a handler that executes in
place of the remainder of the protected fragment (in the case of exception han-
dling), or in place of the* entire* protected fragment (in the case of speculation).
For speculation, the language implementation must be able to undo, or “roll
back,” any visible effects of the protected code.
**8.*** Nondeterminacy:* The ordering or choice among statements or expressions is
deliberately left unspeciﬁed, implying that any alternative will lead to correct
results. Some languages require the choice to be random, or fair, in some for-
mal sense of the word.

```
Though the syntactic and semantic details vary from language to language, these
categories cover all of the control-ﬂow constructs and mechanisms found in most
programming languages. A programmer who thinks in terms of these categories,
rather than the syntax of some particular language, will ﬁnd it easy to learn new
languages, evaluate the tradeoffs among languages, and design and reason about
algorithms in a language-independent way.
Subroutines are the subject of Chapter 9. Concurrency is the subject of Chap-
ter 13. Exception handling and speculation are discussed in those chapters as
well, in Sections 9.4 and 13.4.4. The bulk of the current chapter (Sections 6.3
through 6.7) is devoted to the ﬁve remaining categories. We begin in Section 6.1
by considering the evaluation of expressions—the building blocks on which all
higher-level ordering is based. We consider the syntactic form of expressions, the
precedence and associativity of operators, the order of evaluation of operands,
and the semantics of the assignment statement. We focus in particular on the
distinction between variables that hold a value and variables that hold a reference
to a value; this distinction will play an important role many times in future chap-
ters. In Section 6.2 we consider the difference between structured and unstructured
(goto-based) control ﬂow.
The relative importance of different categories of control ﬂow varies signif-
icantly among the different classes of programming languages. Sequencing is
central to imperative (von Neumann and object-oriented) languages, but plays
a relatively minor role in functional languages, which emphasize the evaluation
of expressions, de-emphasizing or eliminating statements (e.g., assignments) that
affect program output in any way other than through the return of a value. Sim-
ilarly, functional languages make heavy use of recursion, while imperative lan-
guages tend to emphasize iteration. Logic languages tend to de-emphasize or hide
the issue of control ﬂow entirely: The programmer simply speciﬁes a set of infer-
ence rules; the language implementation must ﬁnd an order in which to apply
those rules that will allow it to deduce values that satisfy some desired property.
6.1
Expression Evaluation
```

An expression generally consists of either a simple object (e.g., a literal constant,
or a named variable or constant) or an* operator* or function applied to a col-

Operators are typically simpler, taking only one or two arguments, and dispensing
**EXAMPLE** 6.2

Typical operators
with the parentheses and commas:

```
a + b
- c
```

```
As we saw in Section 3.5.2, some languages deﬁne their operators as syntactic
sugar for more “normal”-looking functions. In Ada, for example, a + b is short
for "+"(a, b); in C++, a + b is short for a.operator+(b) or operator+(a,
b) (whichever is deﬁned).
■
In general, a language may specify that function calls (operator invocations)
employ preﬁx, inﬁx, or postﬁx notation.
These terms indicate, respectively,
whether the function name appears before, among, or after its several arguments:
```

preﬁx:
*op* a b
or
*op* (a, b)
or
(*op* a b)
inﬁx:
a* op* b
postﬁx:
a b* op*

Most imperative languages use inﬁx notation for binary operators and preﬁx
notation for unary operators and (with parentheses around the arguments) other
functions. Lisp uses preﬁx notation for all functions, but with the third of the
**EXAMPLE** 6.3

Cambridge Polish (preﬁx)
notation
variants above: in what is known as* Cambridge Polish*1 notation, it places the
function name* inside* the parentheses:

```
(* (+ 1 3) 2)
; that would be (1 + 3) * 2 in infix
(append a b c my_list)
■
```

ML-family languages dispense with the parentheses altogether, except when
**EXAMPLE** 6.4

Juxtaposition in ML
they are required for disambiguation:

```
max (2 + 3) 4;;
=⇒5
■
```

**1**
Preﬁx notation was popularized by Polish logicians of the early 20th century; Lisp-like parenthe-
sized syntax was ﬁrst employed (for noncomputational purposes) by philosopher W. V. Quine of
Harvard University (Cambridge, MA).

or

**2**
Most authors use the term “inﬁx” only for binary operators. Multiword operators may be called
“mixﬁx,” or left unnamed.

```
, (sequencing)
```


![Figure 6.1 Operator precedence...](images/page_261_vector_480.png)
*Figure 6.1 Operator precedence levels in Fortran, Pascal, C, and Ada. The operators at the top of the ﬁgure group most tightly.*

```
4**(3**2); the language syntax does not allow the unparenthesized form. In
languages that allow assignments inside expressions (an option we will consider
more in Section 6.1.2), assignment associates right-to-left. Thus in C, a = b =
a + c assigns a + c into b and then assigns the same value into a.
■
Haskell is unusual in allowing the programmer to specify both the associativity
EXAMPLE 6.11
```

```
User-deﬁned precedence
and associativity in Haskell
and the precedence of user-deﬁned operators. The predeﬁned ^ operator, for ex-
```

