# 6.3 Sequencing

**252**
Chapter 6* Control Flow*

## 6.3

**Sequencing**
```
Like assignment, sequencing is central to imperative programming. It is the prin-
cipal means of controlling the order in which side effects (e.g., assignments) oc-
cur: when one statement follows another in the program text, the ﬁrst statement
executes before the second. In most imperative languages, lists of statements can
be enclosed with begin... end or { ... } delimiters and then used in any context
in which a single statement is expected. Such a delimited list is usually called
a compound statement. A compound statement optionally preceded by a set of
declarations is sometimes called a block.
In languages like Algol 68, which blur or eliminate the distinction between
statements and expressions, the value of a statement (expression) list is the value
of its ﬁnal element. In Common Lisp, the programmer can choose to return
the value of the ﬁrst element, the second, or the last. Of course, sequencing is a
useless operation unless the subexpressions that do not play a part in the return
value have side effects. The various sequencing constructs in Lisp are used only
in program fragments that do not conform to a purely functional programming
model.
Even in imperative languages, there is debate as to the value of certain kinds of
side effects. In Euclid and Turing, for example, functions (i.e., subroutines that
return values, and that therefore can appear within expressions) are not permitted
to have side effects. Among other things, side-effect freedom ensures that a Euclid
or Turing function, like its counterpart in mathematics, is always idempotent: if
called repeatedly with the same set of arguments, it will always return the same
value, and the number of consecutive calls (after the ﬁrst) will not affect the results
of subsequent execution. In addition, side-effect freedom for functions means
that the value of a subexpression will never depend on whether that subexpression
is evaluated before or after calling a function in some other subexpression. These
properties make it easier for a programmer or theorem-proving system to reason
about program behavior. They also simplify code improvement, for example by
permitting the safe rearrangement of expressions.
Unfortunately, there are some situations in which side effects in functions are
EXAMPLE 6.45
```

Side effects in a random
number generator
highly desirable. We saw one example in the label name function of Figure 3.3.
Another arises in the typical interface to a pseudorandom number generator:

procedure srand(seed : integer)
–– Initialize internal tables.
–– The pseudorandom generator will return a different
–– sequence of values for each different value of seed.

function rand() : integer
–– No arguments; returns a new “random” number.

Obviously rand needs to have a side effect, so that it will return a different value
each time it is called. One could always recast it as a procedure with a reference
parameter:

