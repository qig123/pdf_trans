# 9.5 Coroutines

**450**
Chapter 9* Subroutines and Control Abstraction*

```
been written through to memory will be visible in the handler, but changes that
were cached in registers will be lost. To address this limitation, C allows the pro-
grammer to specify that certain variables are volatile. A volatile variable is one
whose value in memory can change “spontaneously,” for example as the result of
activity by an I/O device or a concurrent thread of control. C implementations
are required to store volatile variables to memory whenever they are written, and
to load them from memory whenever they are read. If a handler needs to see
changes to a variable that may be modiﬁed by the protected code, then the pro-
grammer must include the volatile keyword in the variable’s declaration.
```

```
3CHECK YOUR UNDERSTANDING
26. Describe three ways in which a language may allow programmers to declare
exceptions.
```

```
27. Explain why it is useful to deﬁne exceptions as classes in C++, Java, and C#.
28. Explain the behavior and purpose of a try... finally construct.
```

29. Describe the algorithm used to identify an appropriate handler when an ex-
ception is raised in a language like Ada or C++.

30. Explain how to implement exceptions in a way that incurs no cost in the com-
mon case (when exceptions don’t arise).

31. How do the exception handlers of a functional language like ML differ from
those of an imperative language like C++?

32. Describe the operations that must be performed by the implicit handler for a
subroutine.

```
33. Summarize the shortcomings of the setjmp and longjmp library routines
of C.
```

```
34. What is a volatile variable in C? Under what circumstances is it useful?
```

## 9.5

**Coroutines**
```
Given an understanding of the layout of the run-time stack, we can now consider
the implementation of more general control abstractions—coroutines in particu-
lar. Like a continuation, a coroutine is represented by a closure (a code address
and a referencing environment), into which we can jump by means of a nonlocal
goto, in this case a special operation known as transfer. The principal differ-
ence between the two abstractions is that a continuation is a constant—it does
not change once created—while a coroutine changes every time it runs. When we
goto a continuation, our old program counter is lost, unless we explicitly create
a new continuation to hold it. When we transfer from one coroutine to another,
```

Q

Q
M

M

A

A


![Figure 9.4 A cactus...](images/page_487_vector_268.png)
*Figure 9.4 A cactus stack. Each branch to the side represents the creation of a coroutine (A, B, C, and D). The static nesting of blocks is shown at right. Static links are shown with arrows. Dynamic links are indicated simply by vertical arrangement: each routine has called the one above it. (Coroutine B, for example, was created by the main program, M. B in turn called subroutine S and created coroutine D.)*

If coroutines can be created at arbitrary levels of lexical nesting (as they could
**EXAMPLE** 9.48

Cactus stacks
in Simula), then two or more coroutines may be declared in the same nonglobal
scope, and must thus share access to objects in that scope. To implement this
sharing, the run-time system must employ a so-called* cactus stack* (named for its
resemblance to the Saguaro cacti of the American Southwest; see Figure 9.4).
Each branch off the stack contains the frames of a separate coroutine. The dy-
namic chain of a given coroutine ends in the block in which the coroutine began
execution. The* static* chain of the coroutine, however, extends down into the re-
mainder of the cactus, through any lexically surrounding blocks. In addition to
the coroutines of Simula, cactus stacks are needed for the threads of any language
with lexically nested threads. “Returning” from the main block of a coroutine
must generally terminate the program, as there is no indication of what routine
to transfer to. Because a coroutine only runs when speciﬁed as the target of a
transfer, there is never any need to terminate it explicitly. When a given corou-
tine is no longer needed, the programmer can simply reuse its stack space or,
in a language with garbage collection, allow the collector to reclaim it automati-
cally.
■

9.5.2** Transfer**

To transfer from one coroutine to another, the run-time system must change the
program counter (PC), the stack, and the contents of the processor’s registers.
These changes are encapsulated in the transfer operation: one coroutine calls

