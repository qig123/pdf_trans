# 9.8 Exercises

**462**
Chapter 9* Subroutines and Control Abstraction*

```
that they could be used to implement iterators, but here simpler alternatives exist.
In Chapter 13, we will build on coroutines to implement threads, which run (or
appear to run) in parallel with one another.
In several cases we can discern an evolving consensus about the sorts of con-
trol abstractions that a language should provide. The limited parameter-passing
modes of languages like Fortran and Algol 60 have been replaced by more ex-
tensive or ﬂexible options. Several languages augment the standard positional
notation for arguments with default and named parameters. Less-structured
error-handling mechanisms, such as label parameters, nonlocal gotos, and dy-
namically bound handlers, have been replaced by structured exception handlers
that are lexically scoped within subroutines, and can be implemented at zero cost
in the common (no-exception) case. The spontaneous subroutine call of tradi-
tional signal-handling mechanisms have been replaced by callbacks in a dedicated
thread. In many cases, implementing these newer features has required that com-
pilers and run-time systems become more complex. Occasionally, as in the case
of call-by-name parameters, label parameters, or nonlocal gotos, features that
were semantically confusing were also difﬁcult to implement, and abandoning
them has made compilers simpler. In yet other cases language features that are
useful but difﬁcult to implement continue to appear in some languages but not
in others. Examples in this category include ﬁrst-class subroutines, coroutines,
iterators, continuations, and local objects with unlimited extent.
9.8
Exercises
```

9.1
Describe as many ways as you can in which functions in imperative pro-
gramming languages differ from functions in mathematics.
9.2
Consider the following code in C++:

```
class string_map {
string cached_key;
string cached_val;
const string complex_lookup(const string key);
// body specified elsewhere
public:
const string operator[](const string key) {
if (key == cached_key) return cached_val;
string rtn_val = complex_lookup(key);
cached_key = key;
cached_val = rtn_val;
return rtn_val;
}
};
```

```
Suppose that string_map::operator[] contains the only call to complex_
lookup anywhere in the program. Explain why it would be unwise for the
programmer to expand that call textually in-line and eliminate the separate
function.
```

```
subroutine shift(a, b, c)
integer a, b, c
a = b
b = c
end
```

```
Suppose we want to call shift(x, y, 0) but we don’t want to change the
value of y. Knowing that built-up expressions are passed as temporaries,
we decide to call shift(x, y+0, 0). Our code works ﬁne at ﬁrst, but then
(with some compilers) fails when we enable optimization. What is going
on? What might we do instead?
```

9.26–9.36 In More Depth.

