# 9.7 Summary and Concluding Remarks

9.7 Summary and Concluding Remarks 461

3CHECK YOUR UNDERSTANDING 35. What was the ﬁrst high-level programming language to provide coroutines? 36. What is the difference between a coroutine and a thread?

37. Why doesn’t the transfer library routine need to change the program counter when switching between coroutines?

38. Describe three alternative means of allocating coroutine stacks. What are their relative strengths and weaknesses?

39. What is a cactus stack? What is its purpose? 40. What is discrete event simulation? What is its connection with coroutines?

41. What is an event in the programming language sense of the word? 42. Summarize the two main implementation strategies for events. 43. Explain the appeal of anonymous delegates (C#) and anonymous inner classes (Java) for handling events.

9.7 Summary and Concluding Remarks

This chapter has focused on the subject of control abstraction, and on subroutines in particular. Subroutines allow the programmer to encapsulate code behind a narrow interface, which can then be used without regard to its implementation. We began our study of subroutines in Section 9.1 by reviewing the manage- ment of the subroutine call stack. We then considered the calling sequences used to maintain the stack, with extra sections on the companion site devoted to dis- plays; case studies of the LLVM and gcc compilers on ARM and x86, respectively; and the register windows of the SPARC. After a brief consideration of in-line ex- pansion, we turned in Section 9.3 to the subject of parameters. We ﬁrst consid- ered parameter-passing modes, all of which are implemented by passing values, references, or closures. We noted that the goals of semantic clarity and imple- mentation speed sometimes conﬂict: it is usually most efﬁcient to pass a large parameter by reference, but the aliasing that results can lead to program bugs. In Section 9.3.3 we considered special parameter-passing mechanisms, including default (optional) parameters, named parameters, and variable-length parameter lists. In the ﬁnal three major sections we considered exception-handling mecha- nisms, which allow a program to “unwind” in a well-structured way from a nested sequence of subroutine calls; coroutines, which allow a program to maintain (and switch between) two or more execution contexts; and events, which allow a pro- gram to respond to asynchronous external activity. On the companion site we explained how coroutines are used for discrete event simulation. We also noted

