# 9.3 Parameter Passing

**422**
Chapter 9* Subroutines and Control Abstraction*

## 9.3

**Parameter Passing**
```
Most subroutines are parameterized: they take arguments that control certain
aspects of their behavior, or specify the data on which they are to operate. Pa-
rameter names that appear in the declaration of a subroutine are known as for-
mal parameters. Variables and expressions that are passed to a subroutine in a
particular call are known as actual parameters. We have been referring to actual
parameters as arguments. In the following two subsections, we discuss the most
common parameter-passing modes, most of which are implemented by passing
values, references, or closures. In Section 9.3.3 we will look at additional mecha-
nisms, including default (optional) parameters, named parameters, and variable-
length argument lists. Finally, in Section 9.3.4 we will consider mechanisms for
returning values from functions.
As we noted in Section 6.1, most languages use a preﬁx notation for calls
to user-deﬁned subroutines, with the subroutine name followed by a parenthe-
sized argument list. Lisp places the function name inside the parentheses, as in
(max a b). ML dispenses with the parentheses entirely, except when needed for
EXAMPLE 9.8
```

```
Inﬁx operators
disambiguation: max a b. ML also allows the programmer to specify that certain
names represent inﬁx operators, which appear between a pair of arguments. In
Standard ML one can even specify their precedence:
```

```
infixr 8 tothe;
(* exponentiation *)
fun x tothe 0 = 1.0
| x tothe n = x * (x tothe(n-1));
(* assume n >= 0 *)
```

```
The infixr declaration indicates that tothe will be a right-associative binary
inﬁx operator, at precedence level 8 (multiplication and division are at level 7,
addition and subtraction at level 6). Fortran 90 also allows the programmer to
deﬁne new inﬁx operators, but it requires their names to be bracketed with pe-
riods (e.g., A .cross. B), and it gives them all the same precedence. Smalltalk
uses inﬁx (or “mixﬁx”) notation (without precedence) for all its operations.
■
The uniformity of Lisp and Smalltalk syntax makes control abstraction partic-
EXAMPLE 9.9
```

```
Control abstraction in Lisp
and Smalltalk
ularly effective: user-deﬁned subroutines (functions in Lisp, “messages” in Small-
talk) use the same style of syntax as built-in operations. As an example, consider
if... then ... else:
```

```
if a > b then max := a; else max := b; end if;
-- Ada
```

```
(if (> a b) (setf max a) (setf max b))
; Lisp
```

```
(a > b) ifTrue: [max <- a] ifFalse: [max <- b].
"Smalltalk"
```

```
In Ada (as in most imperative languages) it is clear that if... then ... else is a
built-in language construct: it does not look like a subroutine call. In Lisp and
```

This change would spoil the cascading syntax of the operator form:

```
*(*(cout << a) << b) << c;
```

```
Like pointers, referencesreturned from functions introduce the opportunity to
create dangling references in a language (like C++) with limited extent for local
variables. In our I/O example, the return value is the same stream that was passed
into operator<< as a parameter; since this outlives the function invocation, con-
tinued use of the reference is safe.
■
It should be noted that the ability to return references from functions is not
new in C++: Algol 68 provides the same capability. The object-oriented features
of C++, and its operator overloading, make reference returns particularly useful.
```

```
type field is integer range 0..integer'last;
type number_base is integer range 2..16;
default_width : field
:= integer'width;
default_base
: number_base := 10;
procedure put(item
: in integer;
width : in field
:= default_width;
base
: in number_base := default_base);
```

```
Here the declaration of default_width uses the built-in type attribute width
to determine the maximum number of columns required to print an integer in
decimal on the current machine (e.g., a 32-bit integer requires no more than 11
columns, including the optional minus sign).
Any formal parameter that is “assigned” a value in its subroutine heading is
optional in Ada. In our text_IO example, the programmer can call put with
one, two, or three arguments. No matter how many are provided in a particular
call, the code for put can always assume it has all three parameters. The imple-
mentation is straightforward: in any call in which actual parameters are missing,
the compiler pretends as if the defaults had been provided; it generates a calling
sequence that loads those defaults into registers or pushes them onto the stack,
```

