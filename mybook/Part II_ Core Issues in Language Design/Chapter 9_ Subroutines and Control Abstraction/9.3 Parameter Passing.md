422
Chapter 9 Subroutines and Control Abstraction
9.3
Parameter Passing
Most subroutines are parameterized: they take arguments that control certain
aspects of their behavior, or specify the data on which they are to operate. Pa-
rameter names that appear in the declaration of a subroutine are known as for-
mal parameters. Variables and expressions that are passed to a subroutine in a
particular call are known as actual parameters. We have been referring to actual
parameters as arguments. In the following two subsections, we discuss the most
common parameter-passing modes, most of which are implemented by passing
values, references, or closures. In Section 9.3.3 we will look at additional mecha-
nisms, including default (optional) parameters, named parameters, and variable-
length argument lists. Finally, in Section 9.3.4 we will consider mechanisms for
returning values from functions.
As we noted in Section 6.1, most languages use a preﬁx notation for calls
to user-deﬁned subroutines, with the subroutine name followed by a parenthe-
sized argument list. Lisp places the function name inside the parentheses, as in
(max a b). ML dispenses with the parentheses entirely, except when needed for
EXAMPLE 9.8
Inﬁx operators
disambiguation: max a b. ML also allows the programmer to specify that certain
names represent inﬁx operators, which appear between a pair of arguments. In
Standard ML one can even specify their precedence:
infixr 8 tothe;
(* exponentiation *)
fun x tothe 0 = 1.0
| x tothe n = x * (x tothe(n-1));
(* assume n >= 0 *)
The infixr declaration indicates that tothe will be a right-associative binary
inﬁx operator, at precedence level 8 (multiplication and division are at level 7,
addition and subtraction at level 6). Fortran 90 also allows the programmer to
deﬁne new inﬁx operators, but it requires their names to be bracketed with pe-
riods (e.g., A .cross. B), and it gives them all the same precedence. Smalltalk
uses inﬁx (or “mixﬁx”) notation (without precedence) for all its operations.
■
The uniformity of Lisp and Smalltalk syntax makes control abstraction partic-
EXAMPLE 9.9
Control abstraction in Lisp
and Smalltalk
ularly effective: user-deﬁned subroutines (functions in Lisp, “messages” in Small-
talk) use the same style of syntax as built-in operations. As an example, consider
if... then ... else:
if a > b then max := a; else max := b; end if;
-- Ada
(if (> a b) (setf max a) (setf max b))
; Lisp
(a > b) ifTrue: [max <- a] ifFalse: [max <- b].
"Smalltalk"
In Ada (as in most imperative languages) it is clear that if... then ... else is a
built-in language construct: it does not look like a subroutine call. In Lisp and
9.3 Parameter Passing
423
Smalltalk, on the other hand, the analogous conditional constructs are syntacti-
cally indistinguishable from user-deﬁned operations. They are in fact deﬁned in
terms of simpler concepts, rather than being built in, though they require a spe-
cial mechanism to evaluate their arguments in normal, rather than applicative,
order (Section 6.6.2).
■
9.3.1 Parameter Modes
In our discussion of subroutines so far, we have glossed over the semantic rules
that govern parameter passing, and that determine the relationship between ac-
tual and formal parameters. Some languages, including C, Fortran, ML, and Lisp,
deﬁne a single set of rules, which apply to all parameters. Other languages, in-
cluding Ada, C++, and Swift, provide two or more sets of rules, corresponding
to different parameter-passing modes. As in many aspects of language design, the
semantic details are heavily inﬂuenced by implementation issues.
Suppose for the moment that x is a global variable in a language with a value
EXAMPLE 9.10
Passing an argument to a
subroutine
model of variables, and that we wish to pass x as a parameter to subroutine p:
p(x);
From an implementation point of view, we have two principal alternatives: we
may provide p with a copy of x’s value, or we may provide it with x’s address.
The two most common parameter-passing modes, called call by value and call by
reference, are designed to reﬂect these implementations.
■
With value parameters, each actual parameter is assigned into the correspond-
ing formal parameter when a subroutine is called; from then on, the two are inde-
pendent. With reference parameters, each formal parameter introduces, within
the body of the subroutine, a new name for the corresponding actual parame-
ter. If the actual parameter is also visible within the subroutine under its original
name (as will generally be the case if it is declared in a surrounding scope), then
the two names are aliases for the same object, and changes made through one
will be visible through the other. In most languages (Fortran is an exception; see
below) an actual parameter that is to be passed by reference must be an l-value;
it cannot be the result of an arithmetic operation, or any other value without an
address.
As a simple example, consider the following pseudocode:
EXAMPLE 9.11
Value and reference
parameters
x : integer
–– global
procedure foo(y : integer)
y := 3
print x
. . .
x := 2
foo(x)
print x
424
Chapter 9 Subroutines and Control Abstraction
If y is passed to foo by value, then the assignmentinside foo has no visible effect—
y is private to the subroutine—and the program prints 2 twice. If y is passed to
foo by reference, then the assignment inside foo changes x—y is just a local name
for x—and the program prints 3 twice.
■
Variations on Value and Reference Parameters
If the purpose of call by referenceis to allow the called routine to modify the actual
parameter, we can achieve a similar effect using call by value/result, a mode ﬁrst
introduced in Algol W. Like call by value, call by value/result copies the actual
parameter into the formal parameter at the beginning of subroutine execution.
Unlike call by value, it also copies the formal parameter back into the actual pa-
rameter when the subroutine returns. In Example 9.11, value/result would copy
EXAMPLE 9.12
Call by value/result
x into y at the beginning of foo, and y into x at the end of foo. Because foo
accesses x directly in between, the program’s visible behavior would be different
than it was with call by reference: the assignment of 3 into y would not affect x
until after the inner print statement, so the program would print 2 and then 3. ■
In Pascal, parameters were passed by value by default; they were passed by
reference if preceded by the keyword var in their subroutine header’s formal pa-
rameter list. Parameters in C are always passed by value, though the effect for
arrays is unusual: because of the interoperability of arrays and pointers in C (Sec-
tion 8.5.1), what is passed by value is a pointer; changes to array elements accessed
through this pointer are visible to the caller. To allow a called routine to modify a
EXAMPLE 9.13
Emulating call-by-reference
in C
variable other than an array in the caller’s scope, the C programmer must pass a
pointer to the variable explicitly:
void swap(int *a, int *b) { int t = *a; *a = *b; *b = t; }
...
swap(&v1, &v2);
■
Fortran passes all parameters by reference, but does not require that every ac-
tual parameter be an l-value. If a built-up expression appears in an argument
list, the compiler creates a temporary variable to hold the value, and passes this
variable by reference. A Fortran subroutine that needs to modify the values of its
formal parameters without modifying its actual parameters must copy the values
into local variables, and modify those instead.
DESIGN & IMPLEMENTATION
9.3 Parameter modes
While it may seem odd to introduce parameter modes (a semantic issue) in
terms of implementation, the distinction between value and reference parame-
ters is fundamentally an implementation issue. Most languages with more than
one mode (Ada and Swift are notable exceptions) might fairly be characterized
as an attempt to paste acceptable semantics onto the desired implementation,
rather than to ﬁnd an acceptable implementation of the desired semantics.
9.3 Parameter Passing
425
Call by Sharing
Call by value and call by reference make the most sense in a
language with a value model of variables: they determine whether we copy the
variable or pass an alias for it. Neither option really makes sense in a language
like Smalltalk, Lisp, ML, or Ruby, in which a variable is already a reference. Here
it is most natural simply to pass the reference itself, and let the actual and formal
parameters refer to the same object. Clu called this mode call by sharing. It is
different from call by value because, although we do copy the actual parameter
into the formal parameter, both of them are references; if we modify the object to
which the formal parameter refers, the program will be able to see those changes
through the actual parameter after the subroutine returns. Call by sharing is also
different from call by reference, because although the called routine can change
the value of the object to which the actual parameter refers, it cannot make the
argument refer to a different object.
As we noted in Sections 6.1.2 and 8.5.1, a reference model of variables does not
necessarily require that every object be accessed indirectly by address: the imple-
mentation can create multiple copies of immutable objects (numbers, characters,
etc.) and access them directly. Call by sharing is thus commonly implemented the
same as call by value for small objects of immutable type.
In keeping with its hybrid model of variables, Java uses call by value for vari-
ables of primitive, built-in types (all of which are values), and call by sharing for
variables of user-deﬁned class types (all of which are references). An interesting
consequence is that a Java subroutine cannot change the value of an actual pa-
rameter of primitive type. A similar approach is the default in C#, but because
the language allows users to create both value (struct) and reference (class)
types, both cases are considered call by value. That is, whether a variable is a
value or a reference, we always pass it by copying. (Some authors describe Java
the same way.)
When desired, parameters in C# can be passed by reference instead, by labeling
both a formal parameter and each corresponding argument with the ref or out
keyword. Both of these modes are implemented by passing an address; they differ
in that a ref argument must be deﬁnitely assigned prior to the call, as described
in Section 6.1.3; an out argument need not. In contrast to Java, therefore, a C#
subroutine can change the value of an actual parameter of primitive type, if the
parameter is passed ref or out. Similarly, if a variable of class (reference) type
is passed as a ref or out parameter, it may end up referring to a different object
as a result of subroutine execution—something that is not possible with call by
sharing.
The Purpose of Call by Reference
Historically, there were two principal issues
that a programmer might consider when choosing between value and reference
parameters in a language (e.g., Pascal or Modula) that provided both. First, if the
called routine was supposed to change the value of an actual parameter (argu-
ment), then the programmer had to pass the parameter by reference. Conversely,
to ensure that the called routine could not modify the argument, the program-
mer could pass the parameter by value. Second, the implementation of value pa-
426
Chapter 9 Subroutines and Control Abstraction
rameters would copy actuals to formals, a potentially time-consuming operation
when arguments were large. Reference parameters can be implemented simply by
passing an address. (Of course, accessing a parameter that is passed by reference
requires an extra level of indirection. If the parameter were used often enough,
the cost of this indirection might outweigh the cost of copying the argument.)
The potential inefﬁciency of large value parameters may prompt programmers
to pass an argument by reference when passing by value would be semantically
more appropriate. Pascal programmers, for example, were commonly taught to
use var (reference) parameters both for arguments that need to be modiﬁed and
for arguments that are very large. In a similar vein, C programmers today are
commonly taught to pass pointers (created with &) for both to-be-modiﬁed and
very large arguments. Unfortunately, the latter justiﬁcation tends to lead to buggy
code, in which a subroutine modiﬁes an argument that the caller meant to leave
unchanged.
Read-Only Parameters
To combine the efﬁciency of reference parameters and
the safety of value parameters, Modula-3 provided a READONLY parameter mode.
Any formal parameter whose declaration was preceded by READONLY could not
be changed by the called routine: the compiler prevented the programmer from
using that formal parameter on the left-hand side of any assignment statement,
reading it from a ﬁle, or passing it by reference to any other subroutine. Small
READONLY parameters were generally implemented by passing a value; larger
READONLY parameters were implemented by passing an address. As in Fortran,
a Modula-3 compiler would create a temporary variable to hold the value of any
built-up expression passed as a large READONLY parameter.
The equivalent of READONLY parameters is also available in C, which allows any
EXAMPLE 9.14
const parameters in C
variable or parameter declaration to be preceded by the keyword const. Const
variables are “elaboration-time constants,” as described in Section 3.2. Const
parameters are particularly useful when passing pointers to large structures:
void append_to_log(const huge_record* r) { ...
...
append_to_log(&my_record);
Here the keyword const applies to the record to which r points;3 the callee will
be unable to change the record’s contents. Note, however, that in C the caller
must create a pointer to the record explicitly, and the compiler does not have the
option of passing by value.
■
One traditional problem with parameter modes—and with the READONLY
mode in particular—is that they tend to confuse the key pragmatic issue (does
the implementation pass a value or a reference?) with two semantic issues: is the
3
Following the usual rules for parsing C declarations (footnote in Example 8.46), r is a pointer
to a huge_record whose value is constant. If we wanted r to be a constant that points to a
huge_record, we should need to say huge_record* const r.
9.3 Parameter Passing
427
callee allowed to change the formal parameter and, if so, will the changes be re-
ﬂected in the actual parameter? C keeps the pragmatic issue separate, by forcing
the programmer to pass references explicitly with pointers. Still, its const mode
serves double duty: is the intent of const foo* p to protect the actual parameter
from change, or to document the fact that the subroutine thinks of the formal
parameter as a constant rather than a variable, or both?
Parameter Modes in Ada
Ada provides three parameter-passing modes, called in, out, and in out. In
parameters pass information from the caller to the callee; they can be read by the
callee but not written. Out parameters pass information from the callee to the
caller. In Ada 83 they can be written by the callee but not read; in Ada 95 they
can be both read and written, but they begin their life uninitialized. In out pa-
rameters pass information in both directions; they can be both read and written.
Changes to out or in out parameters always change the actual parameter.
For parameters of scalar and access (pointer) types, Ada speciﬁes that all three
modes are to be implemented by copying values. For these parameters, then, in
is call by value, in out is call by value/result, and out is simply call by result
(the value of the formal parameter is copied into the actual parameter when the
subroutine returns). For parameters of most constructed types, however, Ada
speciﬁcally permits an implementation to pass either values or references. In
most languages, these two different mechanisms would lead to different seman-
tics: changes made to an in out parameter that is passed by reference will affect
the actual parameter immediately; changes made to an in out parameter that is
passed by value will not affect the actual parameter until the subroutine returns.
As noted in Example 9.12, the difference can lead to different behavior in the
presence of aliases.
One possible way to hide the distinction between reference and value/result
would be to outlaw the creation of aliases, as Euclid does. Ada takes a simpler
tack: a program that can tell the difference between value and reference-based
implementations of (nonscalar, nonpointer) in out parameters is said to be er-
roneous—incorrect, but in a way that the language implementation is not required
to catch.
Ada’s semantics for parameter passing allow a single set of modes to be used
not only for subroutine parameters but also for communication among concur-
rently executing tasks (to be discussed in Chapter 13). When tasks are executing
on separate machines, with no memory in common, passing the address of an
actual parameter is not a practical option. Most Ada compilers pass large argu-
ments to subroutines by reference; they pass them to the entry points of tasks by
copying.
References in C++
Programmers who switch to C after some experience with other languages are of-
ten frustrated by C’s lack of reference parameters. As noted above, one can always
arrange to modify an object by passing a pointer, but then the formal parameter
428
Chapter 9 Subroutines and Control Abstraction
is declared as a pointer, and must be explicitly dereferenced whenever it is used.
C++ addresses this problem by introducing an explicit notion of a reference. Ref-
EXAMPLE 9.15
Reference parameters in
C++
erence parameters are speciﬁed by preceding their name with an ampersand in
the header of the function:
void swap(int &a, int &b) { int t = a; a = b; b = t; }
In the code of this swap routine, a and b are ints, not pointers to ints; no
dereferencing is required. Moreover, the caller passes as arguments the variables
whose values are to be swapped, rather than passing pointers to them.
■
As in C, a C++ parameter can be declared to be const to ensure that it is not
modiﬁed. For large types, const reference parameters in C++ provide the same
combination of speed and safety found in the READONLY parameters of Modula-3:
they can be passed by address, and cannot be changed by the called routine.
References in C++ see their principal use as parameters, but they can appear
in other contexts as well. Any variable can be declared to be a reference:
EXAMPLE 9.16
References as aliases in
C++
int i;
int &j = i;
...
i = 2;
j = 3;
cout << i;
// prints 3
Here j is a reference to (an alias for) i. The initializer in the declaration is re-
quired; it identiﬁes the object for which j is an alias. Moreover it is not possible
later to change the object to which j refers; it will always refer to i.
Any change to i or j can be seen by reading the other. Most C++ compilers
implement references with addresses. In this example, i will be assigned a loca-
tion that contains an integer, while j will be assigned a location that contains the
address of i. Despite their different implementation, however, there is no seman-
tic difference between i and j; the exact same operations can be applied to either,
with precisely the same results.
■
In C, programmers sometimes use a pointer to avoid repeated uses of the same
EXAMPLE 9.17
Simplifying code with an
in-line alias
complex expression:
{
element* e = &ruby.chemical_composition.elements[1];
e->name = "Al";
e->atomic_number = 13;
e->atomic_weight = 26.98154;
e->metallic = true;
}
References avoid the need for pointer syntax:
9.3 Parameter Passing
429
{
element& e = ruby.chemical_composition.elements[1];
e.name = "Al";
e.atomic_number = 13;
e.atomic_weight = 26.98154;
e.metallic = true;
}
■
Aside from function parameters, however, the most important use of refer-
ences in C++ is for function returns. Section C 8.7 explains how references are
EXAMPLE 9.18
Returning a reference from
a function
used for I/O in C++. The overloaded << and >> operators return a reference to
their ﬁrst argument, which can in turn be passed to subsequent << or >> opera-
tions. The syntax
cout << a << b << c;
is short for
((cout.operator<<(a)).operator<<(b)).operator<<(c);
Without references, << and >> would have to return a pointer to their stream:
((cout.operator<<(a))->operator<<(b))->operator<<(c);
or
*(*(cout.operator<<(a)).operator<<(b)).operator<<(c);
This change would spoil the cascading syntax of the operator form:
*(*(cout << a) << b) << c;
Like pointers, referencesreturned from functions introduce the opportunity to
create dangling references in a language (like C++) with limited extent for local
variables. In our I/O example, the return value is the same stream that was passed
into operator<< as a parameter; since this outlives the function invocation, con-
tinued use of the reference is safe.
■
It should be noted that the ability to return references from functions is not
new in C++: Algol 68 provides the same capability. The object-oriented features
of C++, and its operator overloading, make reference returns particularly useful.
430
Chapter 9 Subroutines and Control Abstraction
R-value References
One feature that is distinctive in C++ is the notion of an r-value reference, intro-
duced in C++11. R-value references allow an argument that would normally be
considered an r-value—typically, a built-up expression—to be passed to a func-
tion by reference. To see why this might be useful, consider the following decla-
EXAMPLE 9.19
R-value references in
C++11
ration:
obj o2 = o1;
Assuming that o1 is also of class obj, the compiler will initialize o2 by calling
obj’s copy constructor method, passing o1 as argument. As we shall see in Sec-
tion 10.3, a constructor can be declared to take parameters like those of any other
function. Historically, the parameter of obj’s copy constructor would have been
a constant reference (const obj&), and the body of the constructor would have
inspected this parameter to decide how to initialize o2. So far so good. Now
consider the case in which objects of class obj contain pointers to dynamically
allocated state. (The strings, vectors, lists, trees, and hash tables of the standard
library all have such dynamic state.) If that state is mutable, the constructor will
generally need to allocate and initialize a copy, so that neither object will be dam-
aged by subsequent changes to the other. But now consider the declaration
obj o3 = foo("hi mom");
Assuming that foo has return type obj, the compiler will again create a call to
the copy constructor, but this time it may pass a temporary object (call it t) used
to hold the value returned from foo. As before, the constructor will allocate and
initialize a copy of the state contained in t, but upon its return the copy in t will be
destroyed (by calling its destructor method, which will presumably free the space
it consumes in the heap). Wouldn’t it be handy if we could transfer t’s state into
o3, rather than creating a copy and then immediately destroying the original?
This is precisely what r-value references allow.
In addition to the conventional copy constructor, with its const obj& pa-
rameter, C++11 allows the programmer to declare a move constructor, with an
obj&& parameter (double ampersand, no const). The compiler will use the
move constructor when—and only when—the parameter in a declaration is a
“temporary”—a value that will no longer be accessible after evaluation of the ex-
pression in which it appears. In the declaration of o3, the return value of foo is
such a temporary. If the dynamically allocated state of an obj object is accessed
through a ﬁeld named payload, the move constructor might be as simple as
obj::obj(obj&& other) {
payload = other.payload;
other.payload = nullptr;
}
9.3 Parameter Passing
431
The explicit null-ing of other.payload prevents other’s destructor from free-
ing the transferred state.
■
In some cases, the programmer may know that a value will never be used after
passing it as a parameter, but the compiler may be unable to deduce this fact. To
force the use of a move constructor, the programmer can wrap the value in a call
to the standard library move routine:
obj o4 = std::move(o3);
The move routine generates no code: it is, in effect, a cast. Behavior is undeﬁned
if the program actually does contain a subsequent use of o3.
Like regular references, r-value references can be used in the declaration of ar-
bitrary variables in C++. In practice, they seldom appear outside the parameters
of move constructors and the analogous move assignment methods, which over-
load the = operator.
Closures as Parameters
A closure (a reference to a subroutine, together with its referencing environment)
may be passed as a parameter for any of several reasons. The most obvious of
these arises when the parameter is declared to be a subroutine (sometimes called
a formal subroutine). In Ada one might write
EXAMPLE 9.20
Subroutines as parameters
in Ada
1.
type int_func is access function (n : integer) return integer;
2.
type int_array is array (positive range <>) of integer;
3.
procedure apply_to_A (f : int_func; A : in out int_array) is
4.
begin
5.
for i in A'range loop
6.
A(i) := f(A(i));
6.
end loop;
8.
end apply_to_A;
...
9.
k : integer := 3;
-- in nested scope
...
10.
function add_k (m : integer) return integer is
11.
begin
12.
return m + k;
13.
end add_k;
...
14.
apply_to_A (add_k'access, B);
As discussed in Section 3.6.1, a closure needs to include both a code address and a
referencing environment because, in a language with nested subroutines, we need
to make sure that the environment available to f at line 6 is the same that would
have been available to add_k if it had been called directly at line 14—in particular,
that it includes the binding for k.
■
Subroutines are routinely passed as parameters (and returned as results) in
functional languages. A list-based version of apply_to_A would look something
EXAMPLE 9.21
First-class subroutines in
Scheme
like this in Scheme (for the meanings of car, cdr, and cons, see Section 8.6):
432
Chapter 9 Subroutines and Control Abstraction
(define apply-to-L
(lambda (f l)
(if (null? l) '()
(cons (f (car l)) (apply-to-L f (cdr l))))))
Since Scheme is dynamically typed, there is no need to specify the type of f. At
run time, a Scheme implementation will announce a dynamic semantic error in
(f (car l)) if f is not a function, and in (null? l), (car l), or (cdr l) if l
is not a list.
■
The code in OCaml and other ML dialects is similar, but the implementation
EXAMPLE 9.22
First-class subroutines in
OCaml
uses inference (Section 7.2.4) to determine the types of f and l at compile time:
let rec apply_to_L f l =
match l with
| []
-> []
| h :: t -> f h :: apply_to_L f t;;
■
As noted in Section 3.6, C and C++ have no need of subroutine closures, be-
EXAMPLE 9.23
Subroutine pointers in C
and C++
cause their subroutines do not nest. Simple pointers to subroutines sufﬁce. These
are permitted both as parameters and as variables.
void apply_to_A(int (*f)(int), int A[], int A_size) {
int i;
for (i = 0; i < A_size; i++) A[i] = f(A[i]);
}
The syntax f(n) is used not only when f is the name of a function but also when
f is a pointer to a subroutine; the pointer need not be dereferenced explicitly. ■
In object-oriented languages, one can approximate the behavior of a subrou-
tine closure, even without nested subroutines, by packaging a method and its
“environment” within an explicit object. We described these object closures in
Section 3.6.3, noting in particular their integration with lambda expressions and
the standard function class in C++11. Because they are ordinary objects, object
closures require no special mechanisms to pass them as parameters or to store
them in variables.
The delegates of C# extend the notion of object closures to provide type safety
without the restrictions of inheritance. A delegate can be instantiated not only
with a speciﬁed object method (subsuming the object closures of C++ and Java)
but also with a static function (subsuming the subroutine pointers of C and C++)
or with an anonymous nested delegate or lambda expression (subsuming true
subroutine closures). If an anonymous delegate or lambda expression refers to
objects declared in the surrounding method, then those objects have unlimited
extent. Finally, as we shall see in Section 9.6.2, a C# delegate can actually contain
a list of closures, in which case calling the delegate has the effect of calling all the
entries on the list, in turn. (This behavior generally makes sense only when each
entry has a void return type. It is used primarily when processing events.)
9.3 Parameter Passing
433
9.3.2 Call by Name
Explicit subroutine parameters are not the only language feature that requires a
closure to be passed as a parameter. In general, a language implementation must
pass a closure whenever the eventual use of the parameter requires the restoration
of a previous referencing environment. Interesting examples occur in the call-by-
name parameters of Algol 60 and Simula, the label parameters of Algol 60 and
Algol 68, and the call-by-need parameters of Miranda, Haskell, and R.
IN MORE DEPTH
We consider call by name in more detail on the companion site. When Algol 60
was deﬁned, most programmers programmed in assembly language (Fortran was
only a few years old, and Lisp was even newer). The assembly languages of the
day made heavy use of macros, and it was natural for the Algol designers to
propose a parameter-passing mechanism that mimicked the behavior of macros,
namely normal-order argument evaluation (Section 6.6.2). It was also natural,
given common practice in assembly language, to allow a goto to jump to a label
that was passed as a parameter.
Call-by-name parameters have some interesting and powerful applications,
but they are more difﬁcult to implement (and more expensive to use) than one
might at ﬁrst expect: they require the passing of closures, sometimes referred to
as thunks. Label parameters are typically implemented by closures as well. Both
call-by-name and label parameters tend to lead to inscrutable code; modern lan-
guages typically encourage programmers to use explicit formal subroutines and
structured exceptions instead. Signiﬁcantly, most of the arguments against call
by name disappear in purely functional code, where side-effect freedom ensures
that the value of a parameter will always be the same regardless of when it is evalu-
ated. Leveraging this observation, Haskell (and its predecessor Miranda) employs
normal-order evaluation for all parameters.
9.3.3 Special-Purpose Parameters


![Figure 9.3 contains a...](images/page_466_caption_Figure%209.3%20contains%20a%20summary%20of%20the%20common%20parameter-passing%20modes.%20In%20this%20subsection%20we%20examine%20o.png)
*Figure 9.3 contains a summary of the common parameter-passing modes. In this subsection we examine other aspects of parameter passing.*

Default (Optional) Parameters
In Section 3.3.6, we noted that default parameters provide an attractive alternative
to dynamic scope for changing the behavior of a subroutine. A default parameter
is one that need not necessarily be provided by the caller; if it is missing, then a
preestablished default value will be used instead.
One common use of default parameters is in I/O library routines (described
in Section C 8.7.3). In Ada, for example, the put routine for integers has the
EXAMPLE 9.24
Default parameters in Ada
following declaration in the text_IO library package:
434
Chapter 9 Subroutines and Control Abstraction
Parameter
Representative
Implementation
Permissible
Change to
mode
languages
mechanism
operations
actual?
Alias?
value
C/C++, Pascal,
Java/C# (value types)
value
read, write
no
no
in, const
Ada, C/C++, Modula-3
value or reference
read only
no
maybe
out
Ada
value or reference
write only
yes
maybe
value/result
Algol W
value
read, write
yes
no
var, ref
Fortran, Pascal, C++
reference
read, write
yes
yes
sharing
Lisp/Scheme, ML,
Java/C# (reference types)
value or reference
read, write
yes
yes
r-value ref
C++11
reference
read, write
yes∗
no∗
in out
Ada, Swift
value or reference
read, write
yes
maybe
name
Algol 60, Simula
closure (thunk)
read, write
yes
yes
need
Haskell, R
closure (thunk) with
read, write†
yes†
yes†
memoization


![Figure 9.3 Parameter-passing modes....](images/page_467_caption_Figure%209.3%20Parameter-passing%20modes.%20Column%201%20indicates%20common%20names%20for%20modes.%20Column%202%20indicates%20pr.png)
*Figure 9.3 Parameter-passing modes. Column 1 indicates common names for modes. Column 2 indicates prominent languages that use the modes, or that introduced them. Column 3 indicates implementation via passing of values, references, or closures. Column 4 indicates whether the callee can read or write the formal parameter. Column 5 indicates whether changes to the formal parameter affect the actual parameter. Column 6 indicates whether changes to the formal or actual parameter, during the execution of the subroutine, may be visible through the other. ∗Behavior is undeﬁned if the program attempts to use an r-value argument after the call. †Changes to arguments passed by need in R will happen only on the ﬁrst use; changes in Haskell are not permitted.*

type field is integer range 0..integer'last;
type number_base is integer range 2..16;
default_width : field
:= integer'width;
default_base
: number_base := 10;
procedure put(item
: in integer;
width : in field
:= default_width;
base
: in number_base := default_base);
Here the declaration of default_width uses the built-in type attribute width
to determine the maximum number of columns required to print an integer in
decimal on the current machine (e.g., a 32-bit integer requires no more than 11
columns, including the optional minus sign).
Any formal parameter that is “assigned” a value in its subroutine heading is
optional in Ada. In our text_IO example, the programmer can call put with
one, two, or three arguments. No matter how many are provided in a particular
call, the code for put can always assume it has all three parameters. The imple-
mentation is straightforward: in any call in which actual parameters are missing,
the compiler pretends as if the defaults had been provided; it generates a calling
sequence that loads those defaults into registers or pushes them onto the stack,
9.3 Parameter Passing
435
as appropriate. On a 32-bit machine, put(37) will print the string “37” in an
11-column ﬁeld (with nine leading blanks) in base-10 notation. Put(37, 4) will
print “37” in a four-column ﬁeld (two leading blanks), and put(37, 4, 8) will
print “45” (37 = 458) in a four-column ﬁeld.
Because the default_width and default_base variables are part of the
text_IO interface, the programmer can change them if desired. When using
default values in calls with missing actuals, the compiler loads the defaults from
the variables of the package. As noted in Section C 8.7.3, there are overloaded in-
stances of put for all the built-in types. In fact, there are two overloaded instances
of put for every type, one of which has an additional ﬁrst parameter that speci-
ﬁes the output ﬁle to which to write a value.4 It should be emphasized that there
is nothing special about I/O as far as default parameters are concerned: defaults
can be used in any subroutine declaration. In addition to Ada, default parameters
appear in C++, C#, Common Lisp, Fortran 90, and Python.
■
Named Parameters
In all of our discussions so far we have been assuming that parameters are posi-
tional: the ﬁrst actual parameter corresponds to the ﬁrst formal parameter, the
second actual to the second formal, and so on. In some languages, including
Ada, C#, Common Lisp, Fortran 90, Python, and Swift, this need not be the case.
These languages allow parameters to be named. Named parameters (also called
keyword parameters) are particularly useful in conjunction with default parame-
ters. Positional notation allows us to write put(37, 4) to print “37” in a four-
column ﬁeld, but it does not allow us to print in octal in a ﬁeld of default width:
any call (with positional notation) that speciﬁes a base must also specify a width,
explicitly, because the width parameter precedes the base in put’s parameter list.
Named parameters provide the Ada programmer with a way around this problem:
EXAMPLE 9.25
Named parameters in Ada
put(item => 37, base => 8);
Because the parameters are named, their order does not matter; we can also write
put(base => 8, item => 37);
We can even mix the two approaches, using positional notation for the ﬁrst few
parameters, and names for all the rest:
put(37, base => 8);
■
In addition to allowing parameters to be speciﬁed in arbitrary order, omitting
any intermediate default parameters for which special values are not required,
4
The real situation is actually a bit more complicated: The put routine for integers is nested
inside integer_IO, a generic package that is in turn inside of text_IO. The programmer must
instantiate a separate version of the integer_IO package for each variety (size) of integer type.
436
Chapter 9 Subroutines and Control Abstraction
named parameter notation has the advantage of documenting the purpose of each
parameter. For a subroutine with a very large number of parameters, it can be
difﬁcult to remember which is which. Named notation makes the meaning of
EXAMPLE 9.26
Self-documentation with
named parameters
arguments explicit in the call, as in the following hypothetical example:
format_page(columns => 2,
window_height => 400, window_width => 200,
header_font => Helvetica, body_font => Times,
title_font => Times_Bold, header_point_size => 10,
body_point_size => 11, title_point_size => 13,
justification => true, hyphenation => false,
page_num => 3, paragraph_indent => 18,
background_color => white);
■
Variable Numbers of Arguments
Several languages, including Lisp, C and its descendants, and most of the script-
ing languages, allow the user to deﬁne subroutines that take a variable number
of arguments. Examples of such subroutines can be found in Section C 8.7.3:
the printf and scanf functions of C’s stdio I/O library. In C, printf can be
declared as follows:
int printf(char *format, ...) {
...
The ellipsis (...) in the function header is a part of the language syntax. It in-
dicates that there are additional parameters following the format, but that their
types and numbers are unspeciﬁed. Since C and C++ are statically typed, addi-
tional parameters are not type safe. They are type safe in Common Lisp and the
scripting languages, however, thanks to dynamic typing.
Within the body of a function with a variable-length argument list, the C or
C++ programmer must use a collection of standard routines to access the extra
arguments. Originally deﬁned as macros, these routines have implementations
that vary from machine to machine, depending on how arguments are passed
to functions; today the necessary support is usually built into the compiler. For
EXAMPLE 9.27
Variable number of
arguments in C
printf, variable arguments would be used as follows in C:
#include <stdarg.h>
/* macros and type definitions */
int printf(char *format, ...) {
va_list args;
va_start(args, format);
...
char cp = va_arg(args, char);
...
double dp = va_arg(args, double);
...
va_end(args);
}
9.3 Parameter Passing
437
Here args is deﬁned as an object of type va_list, a special (implementation-
dependent) type used to enumerate the elided parameters. The va_start routine
takes the last declared parameter (in this case, format) as its second argument. It
initializes its ﬁrst argument (in this case args) so that it can be used to enumerate
the rest of the caller’s actual parameters. At least one formal parameter must be
declared; they can’t all be elided.
Each call to va_arg returns the value of the next elided parameter. Two ex-
amples appear above. Each speciﬁes the expected type of the parameter, and
assigns the result into a variable of the appropriate type. If the expected type
is different from the type of the actual parameter, chaos can result. In printf,
the %X placeholders in the format string are used to determine the type: printf
contains a large switch statement, with one arm for each possible X. The arm
for %c contains a call to va_arg(args, char); the arm for %f contains a call
to va_arg(args, double). All C ﬂoating-point types are extended to double-
precision before being passed to a subroutine, so there is no need inside printf
to worry about the distinction between floats and doubles. Scanf, on the other
hand, must distinguish between pointers to floats and pointers to doubles. The
call to va_end allows the implementation to perform any necessary cleanup op-
erations (e.g., deallocation of any heap space used for the va_list, or repair of
any changes to the stack frame that might confuse the epilogue code).
■
Like C and C++, C# and recent versions of Java support variable numbers of
parameters, but unlike their parent languages they do so in a type-safe manner,
by requiring all trailing parameters to share a common type. In Java, for example,
EXAMPLE 9.28
Variable number of
arguments in Java
one can write
static void print_lines(String foo, String... lines) {
System.out.println("First argument is \"" + foo + "\".");
System.out.println("There are " +
lines.length + " additional arguments:");
for (String str: lines) {
System.out.println(str);
}
}
...
print_lines("Hello, world", "This is a message", "from your sponsor.");
Here again the ellipsis in the method header is part of the language syntax.
Method print_lines has two arguments. The ﬁrst, foo, is of type String; the
second, lines, is of type String.... Within print_lines, lines functions as
if it had type String[] (array of String). The caller, however, need not package
the second and subsequent parameters into an explicit array; the compiler does
this automatically, and the program prints
First argument is "Hello, world".
There are 2 additional arguments:
This is a message
from your sponsor.
■
438
Chapter 9 Subroutines and Control Abstraction
The parameter declaration syntax is slightly different in C#:
EXAMPLE 9.29
Variable number of
arguments in C#
static void print_lines(String foo, params String[] lines) {
Console.WriteLine("First argument is \"" + foo + "\".");
Console.WriteLine("There are " +
lines.Length + " additional arguments:");
foreach (String line in lines) {
Console.WriteLine(line);
}
}
The calling syntax is the same.
■
9.3.4 Function Returns
The syntax by which a function indicates the value to be returned varies greatly.
In languages like Lisp, ML, and Algol 68, which do not distinguish between ex-
pressions and statements, the value of a function is simply the value of its body,
which is itself an expression.
In several early imperative languages, including Algol 60, Fortran, and Pas-
cal, a function speciﬁed its return value by executing an assignment statement
whose left-hand side was the name of the function. This approach has an unfor-
tunate interaction with the usual static scope rules (Section 3.3.1): the compiler
must forbid any immediately nested declaration that would hide the name of the
function, since the function would then be unable to return. This special case is
EXAMPLE 9.30
return statement
avoided in more recent imperative languages by introducing an explicit return
statement:
return expression
In addition to specifying a value, return causes the immediate termination of
the subroutine. A function that has ﬁgured out what to return but doesn’t want
to return yet can always assign the return value into a temporary variable, and
then return it later:
rtn := expression
...
return rtn
■
Fortran separates termination of a subroutine from the speciﬁcation of return
values: it speciﬁes the return value by assigning to the function name, and has a
return statement that takes no arguments.
Argument-bearing return statements and assignment to the function name
EXAMPLE 9.31
Incremental computation
of a return value
both force the programmer to employ a temporary variable in incremental com-
putations. Here is an example in Ada:
9.3 Parameter Passing
439
type int_array is array (integer range <>) of integer;
-- array of integers with unspecified integer bounds
function A_max(A : int_array) return integer is
rtn : integer;
begin
rtn := integer'first;
for i in A'first .. A'last loop
if A(i) > rtn then rtn := A(i); end if;
end loop;
return rtn;
end A_max;
Here rtn must be declared as a variable so that the function can read it as well as
write it. Because rtn is a local variable, most compilers will allocate it within the
stack frame of A_max. The return statement must then copy that variable’s value
into the return location allocated by the caller.
■
Some languages eliminate the need for a local variable by allowing the result of
a function to have a name in its own right. In Go one can write
EXAMPLE 9.32
Explicitly named return
values in Go
func A_max(A []int) (rtn int) {
rtn = A[0]
for i := 1; i < len(A); i++ {
if A[i] > rtn { rtn = A[i] }
}
return
}
Here rtn can reside throughout its lifetime in the return location allocated by the
caller. A similar facility can be found in Eiffel, in which every function contains
an implicitly declared object named Result. This object can be both read and
written, and is returned to the caller when the function returns.
■
Many early languages placed restrictions on the types of objects that could be
returned from a function. In Algol 60 and Fortran 77, a function had to return
a scalar value. In Pascal and early versions of Modula-2, it could return a scalar
or a pointer. Most imperative languages are more ﬂexible: Algol 68, Ada, C, For-
tran 90, and many (nonstandard) implementations of Pascal allow functions to
return values of composite type. ML, its descendants, and several scripting lan-
EXAMPLE 9.33
Multivalue returns
guages allow a function to return a tuple of values. In Python, for example, we
might write
def foo():
return 2, 3
...
i, j = foo()
■
In functional languages, it is commonplace to return a subroutine as a closure.
Many imperative languages permit this as well. C has no closures, but allows a
function to return a pointer to a subroutine.
