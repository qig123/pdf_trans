468
Chapter 9 Subroutines and Control Abstraction
itives of C# 5 and the similar async and let! of F#. Read up on the asyn-
chronous programming model supported by these promitives. Explain their
(implementation-level) connection to iterators (Section C 9.5.3). Write a
GUI-based program or a network server that makes good use of them.
9.46 Compare and contrast the event-handling mechanisms of several GUI sys-
tems. How are handlers bound to events? Can you control the order in
which they are invoked? How many event-handling threads does each sys-
tem support? How and when are handler threads created? How do they
synchronize with the rest of the program?
9.47–9.52 In More Depth.
9.10
Bibliographic Notes
Recursive subroutines became known primarily through McCarthy’s work on
Lisp [McC60].7 Stack-based space management for recursive subroutines devel-
oped with compilers for Algol 60 (see, e.g., Randell and Russell [RR64]). (Because
of issues of extent, subroutine space in Lisp requires more general, heap-based al-
location.) Dijkstra [Dij60] presents an early discussion of the use of displays to
access nonlocal data. Hanson [Han81] argues that nested subroutines are unnec-
essary.
Calling sequences and stack conventions for gcc are partially documented in
the texinfo ﬁles distributed with the compiler (see www.gnu.org/software/gcc).
Documentation for LLVM can be found at llvm.org. Several of the details de-
scribed on the companion site were “reverse engineered” by examining the output
of the two compilers.
The Ada language rationale [IBFW91, Chap. 8] contains an excellent discus-
sion of parameter-passing modes.
Harbison [Har92, Secs. 6.2–6.3] describes
the Modula-3 modes and compares them to those of other languages. Liskov
and Guttag [LG86, p. 25] liken call-by-sharing in Clu to parameter passing in
Lisp. Call-by-name parameters have their roots in the lambda calculus of Alonzo
Church [Chu41], which we consider in more detail in Section C 11.7.1. Thunks
were ﬁrst described by Ingerman [Ing61]. Fleck [Fle76] discusses the problems
involved in trying to write a swap routine with call-by-name parameters (Exer-
cise 9.10).
MacLaren [Mac77] describes exception handling in PL/I. The lexically scoped
alternative of Ada, and of most more recent languages, draws heavily on the work
of Goodenough [Goo75]. Ada’s semantics are described formally by Luckam and
7
John McCarthy (1927–2011), long-time Professor at MIT and then Stanford Universities, was
one of the founders of the ﬁeld of Artiﬁcial Intelligence. He introduced Lisp in 1958, and also
made key contributions to the early development of time-sharing and the use of mathematical
logic to reason about computer programs. He received the ACM Turing Award in 1971.
9.10 Bibliographic Notes
469
Polak [LP80]. Clu’s exceptions are an interesting historical precursor; details can
be found in the work of Liskov and Snyder [LS79]. Meyer [Mey92a] discusses De-
sign by Contract and exception handling in Eiffel. Friedman, Wand, and Haynes
[FWH01, Chaps. 8–9] provide an excellent explanation of continuation-passing
style in Scheme.
An early description of coroutines appears in the work of Conway [Con63],
who used them to represent the phases of compilation. Birtwistle et al.[BDMN73]
provide a tutorial introduction to the use of coroutines for simulation in Sim-
ula 67. Cactus stacks date from at least the mid-1960s; they were supported di-
rectly in hardware by the Burroughs B6500 and B7500 computers [HD68]. Murer
et al. [MOSS96] discuss the implementation of iterators in the Sather program-
ming language (a descendant of Eiffel). Von Behren et al. [vCZ+03] describe a
system with chunk-based stack allocation.
This page intentionally left blank
