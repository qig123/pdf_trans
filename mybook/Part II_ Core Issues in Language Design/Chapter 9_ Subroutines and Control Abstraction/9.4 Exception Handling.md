# 9.4 Exception Handling

440 Chapter 9 Subroutines and Control Abstraction

3CHECK YOUR UNDERSTANDING 13. What is the difference between formal and actual parameters? 14. Describe four common parameter-passing modes. How does a programmer choose which one to use when? 15. Explain the rationale for READONLY parameters in Modula-3.

16. What parameter mode is typically used in languages with a reference model of variables?

17. Describe the parameter modes of Ada. How do they differ from the modes of other modern languages?

18. Give an example in which it is useful to return a reference from a function in C++.

19. What is an r-value reference? Why might it be useful? 20. List three reasons why a language implementation might implement a param- eter as a closure. 21. What is a conformant (open) array?

22. What are default parameters? How are they implemented? 23. What are named (keyword) parameters? Why are they useful?

24. Explain the value of variable-length argument lists. What distinguishes such lists in Java and C# from their counterparts in C and C++?

25. Describe three common mechanisms for specifying the return value of a func- tion. What are their relative strengths and drawbacks?

9.4 Exception Handling

Several times in the preceding chapters and sections we have referred to exception- handling mechanisms. We have delayed detailed discussion of these mechanisms until now because exception handling generally requires the language implemen- tation to “unwind” the subroutine call stack. An exception can be deﬁned as an unexpected—or at least unusual—condition that arises during program execution, and that cannot easily be handled in the local context. It may be detected automatically by the language implementation, or the program may raise or throw it explicitly (the two terms are synonymous). The most common exceptions are various sorts of run-time errors. In an I/O library, for example, an input routine may encounter the end of its ﬁle before it can read a requested value, or it may ﬁnd punctuation marks or letters on the

9.4 Exception Handling 441

input when it is expecting digits. To cope with such errors without an exception- handling mechanism, the programmer has basically three options, none of which is entirely satisfactory:

1. “Invent” a value that can be used by the caller when a real value could not be returned. 2. Return an explicit “status” value to the caller, who must inspect it after every call. Most often, the status is passed through an extra, explicit parameter. In some languages, the regular return value and the status may be returned to- gether as a tuple. 3. Rely on the caller to pass a closure (in languages that support them) for an error-handling routine that the normal routine can call when it runs into trouble.

The ﬁrst of these options is ﬁne in certain cases, but does not work in the general case. Options 2 and 3 tend to clutter up the program, and impose overhead that we should like to avoid in the common case. The tests in option 2 are particularly offensive: they obscure the normal ﬂow of events in the common case. Because they are so tedious and repetitive, they are also a common source of errors; one can easily forget a needed test. Exception-handling mechanisms address these is- sues by moving error-checking code “out of line,” allowing the normal case to be speciﬁed simply, and arranging for control to branch to a handler when appro- priate. Exception handling was pioneered by PL/I, which includes an executable state- EXAMPLE 9.34

ON conditions in PL/I ment of the form

ON condition statement

The nested statement (often a GOTO or a BEGIN...END block) is a handler. It is not executed when the ON statement is encountered, but is “remembered” for future reference. It will be executed later if exception condition (e.g., OVERFLOW) arises. Because the ON statement is executable, the binding of handlers to exceptions depends on the ﬂow of control at run time. ■ If a PL/I exception handler is invoked and then “returns” (i.e., does not per- form a GOTO to somewhere else in the program), then one of two things will hap- pen. For exceptions that the language designers considered to be fatal, the pro- gram itself will terminate. For “recoverable” exceptions, execution will resume at the statement following the one in which the exception occurred. Unfortunately, experience with PL/I revealed that both the dynamic binding of handlers to ex- ceptions and the automatic resumption of code in which an exception occurred were confusing and error-prone. Many more recent languages, including Ada, Python, PHP, Ruby, C++, Java, C#, and ML, provide exception-handling facilities in which handlers are lexically bound to blocks of code, and in which the execution of the handler replaces the yet-to-be-completed portion of the block. In C++ we might write EXAMPLE 9.35

A simple try block in C++

442 Chapter 9 Subroutines and Control Abstraction

try { ... if (something_unexpected) throw my_error("oops!"); ... cout << "everything's ok\n"; ... } catch (my_error e) { cout << e.explanation << "\n"; }

If something_unexpected occurs, this code will throw an exception of class my_error. This exception will be caught by the catch block, whose parameter, e, has a matching type (here assumed to have a string ﬁeld named explanation). The catch block will then execute in place of the remainder of the try block. ■ Code blocks with handlers can nest: EXAMPLE 9.36

Nested try blocks try { ... try { ... if (something_unexpected) throw my_error("oops!"); ... cout << "everything's ok\n"; ... } catch (some_other_error e1) { cout << "not this one\n"; } ... } catch (my_error e) { cout << e.explanation << "\n"; }

When the exception is thrown, control transfers to the innermost matching han- dler within the current subroutine. ■ If there is no matching handler in the current subroutine, then the subroutine EXAMPLE 9.37

returns abruptly and the exception is re raised at the point of call:

Propagation of an exception out of a called routine

try { ... foo(); ... cout << "everything's ok\n"; ... } catch (my_error e) { cout << e.explanation << "\n"; }

void foo() { ... if (something_unexpected) throw my_error("oops!"); ... }

9.4 Exception Handling 443

If the exception is not handled in the calling routine, it continues to propagate back up the dynamic chain. If it is not handled in the program’s main routine, then a predeﬁned outermost handler is invoked, and usually terminates the pro- gram. ■ In a sense, the dependence of exception handling on the order of subroutine calls might be considered a form of dynamic binding, but it is a much more re- stricted form than is found in PL/I. Rather than say that a handler in a calling routine has been dynamically bound to an error in a called routine, we prefer to say that the handler is lexically bound to the expression or statement that calls the called routine. An exception that is not handled inside a called routine can then be modeled as an “exceptional return”; it causes the calling expression or statement to raise an exception, which is again handled lexically within its subroutine. In practice, exception handlers tend to perform three kinds of operations. First, ideally, a handler will compensate for the exception in a way that allows the program to recover and continue execution. For example, in response to an “out of memory” exception in a storage management routine, a handler might ask the operating system to allocate additional space to the application, after which it could complete the requested operation. Second, when an exception occurs in a given block of code but cannot be handled locally, it is often important to declare a local handler that cleans up any resources allocated in the local block, and then “reraises” the exception, so that it will continue to propagate back to a handler that can (hopefully) recover. Third, if recovery is not possible, a handler can at least print a helpful error message before the program terminates. As discussed in Section 6.2.1, exceptions are related to, but distinct from, the notion of multilevel returns. A routine that performs a multilevel return is func- tioning as expected; in Eiffel terminology, it is fulﬁlling its contract. A routine that raises an exception is not functioning as expected; it cannot fulﬁll its con- tract. Common Lisp and Ruby distinguish between these two related concepts, but most languages do not; in most, a multilevel return requires the outer caller to provide a trivial handler. Common Lisp is also unusual in providing four different versions of its exception-handling mechanism. Two of these provide the usual “exceptional re- turn” semantics; the others are designed to repair the problem and restart eval- uation of some dynamically enclosing expression. Orthogonally, two perform their work in the referencing environment where the handler is declared; the oth- ers perform their work in the environment where the exception ﬁrst arises. The latter option allows an abstraction to provide several alternative strategies for re- covery from exceptions. The user of the abstraction can then specify, dynamically, which of these strategies should be used in a given context. We will consider Com- mon Lisp further in Exercise 9.22 and Exploration 9.43. The “exceptional return” mechanism, with work performed in the environment of the handler, is known as handler-case; it provides semantics comparable to those of most other modern languages.

444 Chapter 9 Subroutines and Control Abstraction

9.4.1 Deﬁning Exceptions

In many languages, dynamic semantic errors automatically result in exceptions, which the program can then catch. The programmer can also deﬁne additional, application-speciﬁc exceptions. Examples of predeﬁned exceptions include arith- metic overﬂow, division by zero, end-of-ﬁle on input, subscript and subrange er- rors, and null pointer dereference. The rationale for deﬁning these as exceptions (rather than as fatal errors) is that they may arise in certain valid programs. Some other dynamic errors (e.g., return from a subroutine that has not yet designated a return value) are still fatal in most languages. In C++ and Common Lisp, excep- tions are all programmer deﬁned. In PHP, the set_error_handler function can be used to turn built-in semantic errors into ordinary exceptions. In Ada, some of the predeﬁned exceptions can be suppressed by means of a pragma. An Ada exception is simply an object of the built-in exception type: EXAMPLE 9.38

What is an exception? declare empty_queue : exception;

In Modula-3, exceptions are another “kind” of object, akin to constants, types, variables, or subroutines:

EXCEPTION empty_queue;

In most object-oriented languages, an exception is an instance of some predeﬁned or user-deﬁned class type:

class empty_queue { }; ■

Most languages allow an exception to be “parameterized,” so the code that raises the exception can pass information to the code that handles it. In object- EXAMPLE 9.39

Parameterized exceptions oriented languages, the “parameters” are simply the ﬁelds of the class:

class duplicate_in_set { // C++ public: item dup; // element that was inserted twice duplicate_in_set(item d) : dup(d) { } }; ... throw duplicate_in_set(d);

In Modula-3, the parameters are included in the exception declaration, much as they are in a subroutine header (the Modula-3 empty_queue in Example 9.38 has no parameters). In Ada, the standard Exceptions library can be used to pass information from a raise statement to a handler. Without the library, an exception is simply a tag, with no value other than its name. ■ If a subroutine raises an exception but does not catch it internally, it may “return” in an unexpected way. This possibility is an important part of the rou- tine’s interface to the rest of the program. Consequently, several languages, in- cluding Modula-3, C++, and Java, include in each subroutine header a list of

9.4 Exception Handling 445

the exceptions that may propagate out of the routine. This list is mandatory in Modula-3: it is a run-time error if an exception arises that does not appear in the header and is not caught internally. The list is optional in C++: if it appears, the semantics are the same as in Modula-3; if it is omitted, all exceptions are permitted to propagate. Java adopts an intermediate approach: it segregates its exceptions into “checked” and “unchecked” categories. Checked exceptions must be declared in subroutine headers; unchecked exceptions need not. Unchecked exceptions are typically run-time errors that most programs will want to be fatal (e.g., subscript out of bounds)—and that would therefore be a nuisance to de- clare in every function—but that a highly robust program may want to catch if they occur in library routines.

9.4.2 Exception Propagation

In most languages, a block of code can have a list of exception handlers. In C++: EXAMPLE 9.40

Multiple handlers in C++ try { // try to read from file ... // potentially complicated sequence of operations // involving many calls to stream I/O routines ... } catch(end_of_file e1) { ... } catch(io_error e2) { // handler for any io_error other than end_of_file ... } catch(...) { // handler for any exception not previously named // (in this case, the triple-dot ellipsis is a valid C++ token; // it does not indicate missing code) }

When an exception arises, the handlers are examined in order; control is trans- ferred to the ﬁrst one that matches the exception. In C++, a handler matches if it names a class from which the exception is derived, or if it is a catch-all (...). In the example here, let us assume that end_of_file is a subclass of io_error. Then an end_of_file exception, if it arises, will be handled by the ﬁrst of the three catch clauses. All other I/O errors will be caught by the second; all non- I/O errors will be caught by the third. If the last clause were missing, non-I/O errors would continue to propagate outward in the current subroutine, and then up the dynamic chain. ■ An exception that is declared in a recursive subroutine will be caught by the innermost handler for that exception at run time. If an exception propagates out of the scope in which it was declared, it can no longer be named by a handler, and thus can be caught only by a “catch-all” handler. In a language with concurrency,

446 Chapter 9 Subroutines and Control Abstraction

one must consider what will happen if an exception is not handled at the outer- most level of a concurrent thread of control. In Modula-3 and C++, the entire program terminates abnormally; in Ada and Java, the affected thread terminates quietly; in C#, the behavior is implementation deﬁned.

Handlers on Expressions

In an expression-oriented language such as ML or Common Lisp, an exception handler is attached to an expression, rather than to a statement. Since execu- tion of the handler replaces the unﬁnished portion of the protected code when an exception occurs, a handler attached to an expression must provide a value for the expression. (In a statement-oriented language, the handler—like most statements—is executed for its side effects.) In the OCaml dialect of ML, a han- EXAMPLE 9.41

Exception handler in OCaml dler looks like this:

let foo = try a / b with Division_by_zero -> max_int;;

Here a / b is the protected expression, try and with are keywords, Division_ by_zero is an exception (a value built from the exception constructor), and max_int is an expression (in this case a constant) whose value replaces the value of the expression in which the Division_by_zero exception arose. Both the protected expression and the handler could in general be arbitrarily complicated, with many nested function calls. Exceptions that arise within a nested call (and are not handled locally) propagate back up the dynamic chain, just as they do in most statement-oriented languages. ■

Cleanup Operations

In the process of searching for a matching handler, the exception-handling mech- anism must “unwind” the run-time stack by reclaiming the frames of any sub- routines from which the exception escapes. Reclaiming a frame requires not only that its space be popped from the stack but also that any registers that were saved as part of the calling sequence be restored. (We discuss implementation issues in more detail in Section 9.4.3.) In C++, an exception that leaves a scope, whether a subroutine or just a nested block, requires the language implementation to call destructor functions

DESIGN & IMPLEMENTATION

9.4 Structured exceptions Exception-handling mechanisms are among the most complex aspects of mod- ern language design, from both a semantic and a pragmatic point of view. Pro- grammers have used subroutines since before there were computers (they ap- pear, among other places, in the 19th-century notes of Countess Ada Augusta Byron). Structured exceptions, by contrast, were not invented until the 1970s, and did not become commonplace until the 1980s.

9.4 Exception Handling 447

for any objects declared within that scope. Destructors (to be discussed in more detail in Section 10.3) are often used to deallocate heap space and other re- sources (e.g., open ﬁles). Similar functionality is provided in Common Lisp by an unwind-protect expression, and in Modula-3, Python, Java, and C# by means of try... finally constructs. Code in Python might look like this: EXAMPLE 9.42

finally clause in Python try: # protected block my_stream = open("foo.txt", "r") # "r" means "for reading" for line in my_stream: ... finally: my_stream.close()

A finally clause will be executed whenever control escapes from the protected block, whether the escape is due to normal completion, an exit from a loop, a return from the current subroutine, or the propagation of an exception. We have assumed in our example that my_stream is not bound to anything at the begin- ning of the code, and that it is harmless to close a not-yet-opened stream. ■

9.4.3 Implementation of Exceptions

The most obvious implementation for exceptions maintains a linked-list stack of EXAMPLE 9.43

Stacked exception handlers handlers. When control enters a protected block, the handler for that block is added to the head of the list. When an exception arises, either implicitly or as a result of a raise or throw statement, the language run-time system pops the innermost handler off the list and calls it. The handler begins by checking to see if it matches the exception that occurred; if not, it simply reraises it:

if exception matches duplicate in set . . . else reraise exception

To implement propagation back down the dynamic chain, each subroutine has an implicit handler that performs the work of the subroutine epilogue code and then reraises the exception. ■ If a protected block of code has handlers for several different exceptions, they EXAMPLE 9.44

Multiple exceptions per handler are implemented as a single handler containing a multiarm if statement:

if exception matches end of ﬁle . . . elsif exception matches io error . . . else . . . –– “catch-all” handler ■

448 Chapter 9 Subroutines and Control Abstraction

The problem with this implementation is that it incurs run-time overhead in the common case. Every protected block and every subroutine begins with code to push a handler onto the handler list, and ends with code to pop it back off the list. We can usually do better. The only real purpose of the handler list is to determine which handler is active. Since blocks of source code tend to translate into contiguous blocks of machine language instructions, we can capture the correspondence between handlers and protected blocks in the form of a table generated at compile time. Each entry in the table contains two ﬁelds: the starting address of a block of code and the address of the corresponding handler. The table is sorted on the ﬁrst ﬁeld. When an exception occurs, the language run-time system performs binary search in the table, using the program counter as key, to ﬁnd the handler for the current block. If that handler reraises the exception, the process repeats: handlers themselves are blocks of code, and can be found in the table. The only subtlety arises in the case of the implicit handlers associated with propagation out of subroutines: such a handler must ensure that the reraise code uses the return address of the subroutine, rather than the current program counter, as the key for table lookup. The cost of raising an exception is higher in this second implementation, by a factor logarithmic in the total number of handlers. But this cost is paid only when an exception actually occurs. Assuming that exceptions are unusual events, the net impact on performance is clearly beneﬁcial: the cost in the common case is zero. In its pure form the table-based approach requires that the compiler have access to the entire program, or that the linker provide a mechanism to glue sub- tables together. If code fragments are compiled independently, we can employ a hybrid approach in which the compiler creates a separate table for each subrou- tine, and each stack frame contains a pointer to the appropriate table.

Exception Handling without Exceptions

It is worth noting that exceptions can sometimes be simulated in a language that does not provide them as a built-in. In Section 6.2 we noted that Pascal permitted gotos to labels outside the current subroutine, that Algol 60 allowed labels to be passed as parameters, and that PL/I allowed them to be stored in variables. These mechanisms permit the program to escape from a deeply nested context, but in a very unstructured way. A more structured alternative can be found in the call-with-current- continuation (call-cc) routine of languages like Scheme and Ruby. As de- scribed in Section 6.2.2, call-cc takes a single argument f , which is itself a func- tion. It calls f, passing as argument a continuation c (a closure) that captures the current program counter and referencing environment. At any point in the fu- ture, f can call c to reestablish the saved environment. If nested calls have been made, control abandons them, as it does with exceptions. If we represent a pro- tected block and its handlers as closures (lambda expressions), call-cc can be used to maintain a stack of continuations to which one should jump to emulate raise/throw. We explore this option further in Exercise 9.18.

9.4 Exception Handling 449

Intermediate between the anarchy of nonlocal gotos and the generality of EXAMPLE 9.45

setjmp and longjmp in C call/cc, C provides a pair of library routines entitled setjmp and longjmp. Setjmp takes as argument a buffer into which to capture a representation of the program’s current state. This buffer can later be passed as the ﬁrst argument to longjmp, to restore the captured state. Calls to setjmp return an integer: zero indicates “normal” return; nonzero values (provided as the second argument to longjmp) indicate exceptional “returns” from longjmp. Typical uses look like

if (!setjmp(buffer)) { /* protected code */ } else { /* handler */ } or

switch (setjmp(buffer)) { case 0: /* protected code */ break; case 1: /* handler 1 */ break; ... case n: /* handler n */ break: }

When initially called, setjmp returns a 0, and control enters the protected code. If longjmp(buffer, v) is called anywhere within the protected code, or in any- thing called by that code, then setjmp will appear to return again, this time with a return value of v, causing control to enter a handler. Unlike the closure created by call/cc, the information captured by setjmp has limited extent: the behav- ior of longjmp(buffer, v) is undeﬁned if the function containing the call to setjmp has returned. ■ The typical implementation of setjmp and longjmp saves the current ma- chine registers in the setjmp buffer, and restores them in longjmp. There is no list of handlers; rather than “unwinding” the stack, the implementation simply tosses all the nested frames by restoring old values of the sp and fp. The problem with this approach is that the register contents at the beginning of the handler do not reﬂect the effects of the successfully completed portion of the protected code: they were saved before that code began to run. Any changes to variables that have

DESIGN & IMPLEMENTATION

9.5 setjmp Because it saves multiple registers to memory, the usual implementation of setjmp is quite expensive—more so than entry to a protected block in the “obvious” implementation of exceptions described above. While implemen- tors are free to use a more efﬁcient, table-driven approach if desired, the usual implementation minimizes the complexity of the run-time system and elimi- nates the need for linker-supported integration of tables from separately com- piled modules and libraries.

