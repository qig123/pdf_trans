376
Chapter 8 Composite Types
one-byte elements, and never contain references to anything else makes dynamic-
size strings easier to implement than general dynamic arrays.
Some languages require that the length of a string-valued variable be bound
no later than elaboration time, allowing the variable to be implemented as a con-
tiguous array of characters in the current stack frame. Ada supports a few string
operations, including assignment and comparison for lexicographic ordering. C,
EXAMPLE 8.30
char* assignment in C
on the other hand, provides only the ability to create a pointer to a string literal.
Because of C’s uniﬁcation of arrays and pointers, even assignment is not sup-
ported. Given the declaration char *s, the statement s = "abc" makes s point
to the constant "abc" in static storage. If s is declared as an array, rather than
a pointer (char s[4]), then the statement will trigger an error message from
the compiler. To assign one array into another in C, the program must copy the
characters individually.
■
Other languages allow the length of a string-valued variable to change over its
lifetime, requiring that the variable be implemented as a block or chain of blocks
in the heap. ML and Lisp provide strings as a built-in type. C++, Java, and C#
provide them as predeﬁned classes of object, in the formal, object-oriented sense.
In all these languages a string variable is a reference to a string. Assigning a new
value to such a variable makes it refer to a different object—each such object
is immutable. Concatenation and other string operators implicitly create new
objects. The space used by objects that are no longer reachable from any variable
is reclaimed automatically.
8.4
Sets
A programming language set is an unordered collection of an arbitrary number
of distinct values of a common type. Sets were introduced by Pascal, and have
been supported by many subsequent languages. The type from which elements
of a set are drawn is known as the base or universe type. Pascal sets were restricted
EXAMPLE 8.31
Set types in Pascal
to discrete base types, and overloaded +, *, and - to provide set union, intersec-
tion, and difference operations, respectively. The intended implementation was a
characteristic array—a bit vector whose length (in bits) is the number of distinct
values of the base type. A one in the kth position in the bit vector indicates that
the kth element of the base type is a member of the set; a zero indicates that it is
not. In a language that uses ASCII, a set of characters would occupy 128 bits—16
bytes. Operations on bit-vector sets can make use of fast logical instructions on
most machines. Union is bit-wise or; intersection is bit-wise and; difference is
bit-wise not, followed by bit-wise and.
■
Unfortunately, bit vectors do not work well for large base types: a set of inte-
gers, represented as a bit vector, would consume some 500 megabytes on a 32-bit
machine. With 64-bit integers, a bit-vector set would consume more memory
than is currently contained on all the computers in the world. Because of this
problem, some languages (including early versions of Pascal, though not the ISO
standard) limited sets to base types of fewer than some ﬁxed number of values.
