# 8.6 Lists

398 Chapter 8 Composite Types

3CHECK YOUR UNDERSTANDING 25. What are dangling references? How are they created, and why are they a prob- lem?

26. What is garbage? How is it created, and why is it a problem? Discuss the comparative advantages of reference counts and tracing collection as a means of solving the problem. 27. What are smart pointers? What purpose do they serve?

28. Summarize the differences among mark-and-sweep, stop-and-copy, and gen- erational garbage collection. 29. What is pointer reversal? What problem does it address? 30. What is “conservative” garbage collection? How does it work?

31. Do dangling references and garbage ever arise in the same programming lan- guage? Why or why not?

32. Why was automatic garbage collection so slow to be adopted by imperative programming languages? 33. What are the advantages and disadvantages of allowing pointers to refer to objects that do not lie in the heap?

8.6 Lists

A list is deﬁned recursively as either the empty list or a pair consisting of an initial object (which may be either a list or an atom) and another (shorter) list. Lists are ideally suited to programming in functional and logic languages, which do most of their work via recursion and higher-order functions (to be described in Section 11.6). Lists can also be used in imperative programs. They are supported by built- in type constructors in a few traditional compiled languages (e.g., Clu) and in most modern scripting languages. They are also commonly supported by library classes in object-oriented languages, and programmers can build their own in any language with records and pointers. Since many of the standard list operations tend to generate garbage, lists tend to work best in a language with automatic garbage collection. One key aspect of lists is very different in the two main functional language families. Lists in ML are homogeneous: every element of the list must have the same type. Lisp lists, by contrast, are heterogeneous: any object may be placed in a list, so long as it is never used in an inconsistent fashion.9 These different EXAMPLE 8.54

Lists in ML and Lisp

9 Recall that objects are self-descriptive in Lisp. The only type checking occurs when a function “deliberately” inspects an argument to see whether it is a list or an atom of some particular type.

8.6 Lists 399

approaches lead to different implementations. An ML list is usually a chain of blocks, each of which contains an element and a pointer to the next block. A Lisp list is a chain of cons cells, each of which contains two pointers, one to the element and one to the next cons cell (see Figures 8.11 and 8.12). For historical reasons, the two pointers in a cons cell are known as the car and the cdr; they represent the head of the list and the remaining elements, respectively. In both semantics (homogeneity vs heterogeneity) and implementation (chained blocks vs cons cells), Clu resembles ML, while Python and Prolog (to be discussed in Section 12.2) resemble Lisp. ■ Both ML and Lisp provide convenient notation for lists. In the OCaml dialect EXAMPLE 8.55

List notation of ML, a list is enclosed in square brackets, with elements separated by semi- colons: [a; b; c; d]. A Lisp list is enclosed in parentheses, with elements sep- arated by white space: (a b c d). In both cases, the notation represents a proper list—one whose innermost pair consists of the ﬁnal element and the empty list. In Lisp, it is also possible to construct an improper list, whose ﬁnal pair contains two elements. (Strictly speaking, such a list does not conform to the standard re- cursive deﬁnition.) Lisp systems provide a more general, but cumbersome dotted list notation that captures both proper and improper lists. A dotted list is either an atom (possibly null) or a pair consisting of two dotted lists separated by a pe- riod and enclosed in parentheses. The dotted list (a . (b . (c . (d . null)))) is the same as (a b c d). The list (a . (b . (c . d))) is improper; its ﬁnal cons cell contains a pointer to d in the second position, where a pointer to a list is normally required. ■ Both ML and Lisp provide a wealth of built-in polymorphic functions to ma- nipulate arbitrary lists. Because programs are lists in Lisp, Lisp must distin- guish between lists that are to be evaluated and lists that are to be left “as is,”

DESIGN & IMPLEMENTATION

8.12 car and cdr The names of the functions car and cdr are historical accidents: they de- rive from the original (1959) implementation of Lisp on the IBM 704 at MIT. The machine architecture included 15-bit “address” and “decrement” ﬁelds in some of the (36-bit) loop-control instructions, together with additional in- structions to load an index register from, or store it to, one of these ﬁelds within a 36-bit memory word. The designers of the Lisp interpreter decided to make cons cells mimic the internal format of instructions, so they could exploit these special instructions. In now archaic usage, memory words were also known as “registers.” What might appropriately have been called “ﬁrst” and “rest” pointers thus came to be known as the CAR (contents of address ﬁeld of register) and CDR (contents of decrement ﬁeld of register). The 704, incidentally, was also the machine on which Fortran was ﬁrst developed, and the ﬁrst commercial machine to include hardware ﬂoating-point and magnetic core memory.

400 Chapter 8 Composite Types

as structures. To prevent a literal list from being evaluated, the Lisp programmer may quote it: (quote (a b c d)), abbreviated ‚(a b c d). To evaluate an in- ternal list (e.g., one returned by a function), the programmer may pass it to the built-in function eval. In ML, programs are not lists, so a literal list is always a structural aggregate. The most fundamental operations on lists are those that construct them from EXAMPLE 8.56

Basic list operations in Lisp their components or extract their components from them. In Lisp:

(cons 'a '(b)) =⇒(a b) (car '(a b)) =⇒a (car nil) =⇒?? (cdr '(a b c)) =⇒(b c) (cdr '(a)) =⇒nil (cdr nil) =⇒?? (append '(a b) '(c d)) =⇒(a b c d)

Here we have used =⇒to mean “evaluates to.” The car and cdr of the empty list (nil) are deﬁned to be nil in Common Lisp; in Scheme they result in a dynamic semantic error. ■ In OCaml the equivalent operations are written as follows: EXAMPLE 8.57

Basic list operations in OCaml a :: [b] =⇒[a; b] hd [a, b] =⇒a hd [] =⇒run-time exception tl [a, b, c] =⇒[b, c] tl [a] =⇒[] tl [] =⇒run-time exception [a, b] @ [c, d] =⇒[a; b; c; d]

Run-time exceptions may be caught by the program if desired; further details will appear in Section 9.4. ■ Both ML and Lisp provide many additional list functions, including ones that test a list to see if it is empty; return the length of a list; return the nth element of a list, or a list consisting of all but the ﬁrst n elements; reverse the order of the elements of a list; search a list for elements matching some predicate; or apply a function to every element of a list, returning the results as a list. Several languages, including Miranda, Haskell, Python, and F#, provide lists that resemble those of ML, but with an important additional mechanism, known as list comprehensions. These are adapted from traditional mathematical set nota- tion. A common form comprises an expression, an enumerator, and one or more ﬁlters. In Haskell, the following denotes a list of the squares of all odd numbers EXAMPLE 8.58

List comprehensions less than 100:

[i*i | i <- [1..100], i `mod` 2 == 1]

