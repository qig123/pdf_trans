# 8.6 Lists

**398**
Chapter 8* Composite Types*

```
3CHECK YOUR UNDERSTANDING
25. What are dangling references? How are they created, and why are they a prob-
lem?
```

26. What is* garbage*? How is it created, and why is it a problem? Discuss the
comparative advantages of* reference counts* and* tracing collection* as a means
of solving the problem.
27. What are* smart pointers*? What purpose do they serve?

28. Summarize the differences among mark-and-sweep, stop-and-copy, and gen-
erational garbage collection.
29. What is* pointer reversal*? What problem does it address?
30. What is “conservative” garbage collection? How does it work?

31. Do dangling references and garbage ever arise in the same programming lan-
guage? Why or why not?

32. Why was automatic garbage collection so slow to be adopted by imperative
programming languages?
33. What are the advantages and disadvantages of allowing pointers to refer to
objects that do not lie in the heap?

## 8.6

**Lists**
A list is deﬁned recursively as either the empty list or a pair consisting of an initial
object (which may be either a list or an atom) and another (shorter) list. Lists
are ideally suited to programming in functional and logic languages, which do
most of their work via recursion and higher-order functions (to be described in
Section 11.6).
Lists can also be used in imperative programs. They are supported by built-
in type constructors in a few traditional compiled languages (e.g., Clu) and in
most modern scripting languages. They are also commonly supported by library
classes in object-oriented languages, and programmers can build their own in any
language with records and pointers. Since many of the standard list operations
tend to generate garbage, lists tend to work best in a language with automatic
garbage collection.
One key aspect of lists is very different in the two main functional language
families. Lists in ML are* homogeneous*: every element of the list must have the
same type. Lisp lists, by contrast, are* heterogeneous*: any object may be placed
in a list, so long as it is never used in an inconsistent fashion.9 These different
**EXAMPLE** 8.54

Lists in ML and Lisp

**9**
Recall that objects are self-descriptive in Lisp. The only type checking occurs when a function
“deliberately” inspects an argument to see whether it is a list or an atom of some particular type.

