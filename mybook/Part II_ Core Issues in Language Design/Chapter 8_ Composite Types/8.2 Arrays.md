# 8.2 Arrays

8.2 Arrays
**359**

4.
Why is it easier to implement assignment than comparison for records?

5.
What is* packing*? What are its advantages and disadvantages?
6.
Why might a compiler reorder the ﬁelds of a record? What problems might
this cause?
7.
Brieﬂy describe two purposes for unions/variant records.

## 8.2

**Arrays**
```
Arrays are the most common and important composite data types. They have
been a fundamental part of almost every high-level language, beginning with For-
tran I. Unlike records, which group related ﬁelds of disparate types, arrays are
usually homogeneous. Semantically, they can be thought of as a mapping from
an index type to a component or element type. Some languages (e.g., Fortran) re-
quire that the index type be integer; many languages allow it to be any discrete
type. Some languages (e.g., Fortran 77) require that the element type of an array
be scalar. Most (including Fortran 90) allow any element type.
Some languages (notably scripting languages, but also some newer imperative
languages, including Go and Swift) allow nondiscrete index types. The resulting
associative arrays must generally be implemented with hash tables or search trees;
we consider them in Section 14.4.3. Associative arrays also resemble the dictio-
nary or map types supported by the standard libraries of many object-oriented
languages. In C++, operator overloading allows these types to use conventional
array-like syntax. For the purposes of this chapter, we will assume that array
indices are discrete. This admits a (much more efﬁcient) contiguous allocation
scheme, to be described in Section 8.2.3. We will also assume that arrays are
dense—that a large fraction of their elements are not equal to zero or some other
default value. The alternative—sparse arrays—arises in many important scien-
tiﬁc problems. For these, libraries (or, in rare cases, the language itself) may
support an alternative implementation that explicitly enumerates only the non-
default values.
```

8.2.1** Syntax and Operations**

```
Most languages refer to an element of an array by appending a subscript—usually
delimited by square brackets—to the name of the array: A[3]. A few languages—
notably Fortran and Ada—use parentheses instead: A(3).
In some languages one declares an array by appending subscript notation to
EXAMPLE 8.13
```

Array declarations
the syntax that would be used to declare a scalar. In C:

```
char upper[26];
```

```
VAR mat : ARRAY [1..10], [1..10] OF REAL;
```

is syntactic sugar for

```
VAR mat : ARRAY [1..10] OF ARRAY [1..10] OF REAL;
```

```
and mat[3, 4] is syntactic sugar for mat[3][4].
■
In Ada, by contrast,
EXAMPLE 8.15
```

```
Multidimensional vs
built-up arrays
mat1 : array (1..10, 1..10) of long_float;
```

is not the same as

```
type vector is array (integer range <>) of long_float;
type matrix is array (integer range <>) of vector (1..10);
mat2 : matrix (1..10);
```

```
Variable mat1 is a two-dimensional array; mat2 is an array of one-dimensional
arrays. With the former declaration, we can access individual real numbers as
mat1(3, 4); with the latter we must say mat2(3)(4). The two-dimensional
array is arguably more elegant, but the array of arrays supports additional op-
erations: it allows us to name the rows of mat2 individually (mat2(3) is a 10-
element, single-dimensional array), and it allows us to take slices, as discussed
```

Elaborated arrays in
Fortran 90
### after elaboration, but it does not allow those bounds to change once they have

### been deﬁned:

```
real, dimension (:,:), allocatable :: mat
! mat is two-dimensional, but with unspecified bounds
...
allocate (mat (a:b, 0:m-1))
! first dimension has bounds a..b; second has bounds 0..m-1
...
deallocate (mat)
! implementation is now free to reclaim mat's space
```

```
Execution of an allocate statement can be treated like the elaboration of a dy-
namic shape array in a nested block. Execution of a deallocate statement can
```

d
a
y

W
e
d
n
e
s

d
a
y
S
a
t
u
r

s
h

F
i
r


![Figure 8.9 Contiguous array...](images/page_404_vector_279.png)
*Figure 8.9 Contiguous array allocation vs row pointers in C. The declaration on the left is a true two-dimensional array. The slashed boxes are NUL bytes; the shaded areas are holes. The declaration on the right is a ragged array of pointers to arrays of characters. The arrays of characters may be located anywhere in memory—next to each other or separated, and in any order. In both cases, we have omitted bounds in the declaration that can be deduced from the size of the initializer (aggregate). Both data structures permit individual characters to be accessed using double subscripts, but the memory layout (and corresponding address arithmetic) is quite different.*

**Address Calculations**

### For the usual contiguous layout of arrays, calculating the address of a particular

### element is somewhat complicated, but straightforward. Suppose a compiler is

**EXAMPLE** 8.25
Indexing a contiguous array
### given the following declaration for a three-dimensional array:

A : array [*L*1 . .* U*1] of array [*L*2 . .*U*2] of array [*L*3 . .* U*3] of elem type;

### Let us deﬁne constants for the sizes of the three dimensions:

*S*3
= size of elem type

*S*2
=
(*U*3* −**L*3 + 1)* ×** S*3
*S*1
=
(*U*2* −**L*2 + 1)* ×** S*2

Here the size of a row (*S*2) is the size of an individual element (*S*3) times the
### number of elements in a row (assuming row-major layout). The size of a plane

(*S*1) is the size of a row (*S*2) times the number of rows in a plane. The address of
A[i, j, k] is then
