# 8.5 Pointers and Recursive Types

8.5 Pointers and Recursive Types
**377**

For sets of elements drawn from a large universe, most modern languages use
alternative implementations, whose size is proportional to the number of ele-
ments present, rather than to the number of values in the base type. Most lan-
guages also provide a built-in iterator (Section 6.5.3) to yield the elements of the
set. A distinction is often made between* sorted* lists, whose base type must sup-
port some notion of ordering, and whose iterators yield the elements smallest-to-
largest, and* unordered* lists, whose iterators yield the elements in arbitrary order.
Ordered sets are commonly implemented with skip lists or various sorts of trees.
Unordered sets are commonly implemented with hash tables.
Some languages (Python and Swift, for example) provide sets as a built-in type
constructor. The Python version can be seen in Example 14.67. In many object-
oriented languages, sets are supported by the standard library instead. A few lan-
**EXAMPLE** 8.32

Emulating a set with a map
in Go
guages and libraries have no built-in set constructor, but do provide associative
arrays (also known as “hashes,” “dictionaries,” or “maps”). These can be used to
emulate unordered sets, by mapping all (and only) the desired elements to some
dummy value. In Go, for example, we can write

```
my_set := make(map[int]bool)
// mapping from int to bool
my_set[3] = true
// inserts <3, true> in mapping
...
delete(my_set, i)
// removes <i, true>, if present
...
if my_set[j] { ...
// true if present
```

```
If M is a mapping from type D to type R in Go, and if k ∈D is not mapped to
anything in R, the expression M[k] will return the “zero value” of type R. For
Booleans, the zero value happens to be false, so the test in the last line of our
example will return false if j is not in my_set. Deleting a no-longer-present
element is preferable to mapping it explicitly to false, because deletion reclaims
the space in the underlying hash table; mapping to false does not.
■
8.5
Pointers and Recursive Types
```

```
A recursive type is one whose objects may contain one or more references to other
objects of the type. Most recursive types are records, since they need to contain
something in addition to the reference, implying the existence of heterogeneous
ﬁelds. Recursive types are used to build a wide variety of “linked” data structures,
including lists and trees.
In languages that use a reference model of variables, it is easy for a record of
type foo to include a reference to another record of type foo: every variable
(and hence every record ﬁeld) is a reference anyway. In languages that use a value
model of variables, recursive types require the notion of a pointer: a variable (or
ﬁeld) whose value is a reference to some object. Pointers were ﬁrst introduced in
PL/I.
```

```
Here a chr_tree is either an Empty leaf or a Node consisting of a character and
two child trees. (Further details can be found in Section 11.4.3.)
It is natural in OCaml to include a chr_tree within a chr_tree because every
variable is a reference. The tree Node (‚R‚, Node (‚X‚, Empty, Empty), Node
(‚Y‚, Node (‚Z‚, Empty, Empty), Node (‚W‚, Empty, Empty))) would
most likely be represented in memory as shown in Figure 8.11. Each individ-
ual rectangle in the right-hand portion of this ﬁgure represents a block of storage
allocated from the heap. In effect, the tree is a tuple (record) tagged to indicate
that it is a Node. This tuple in turn refers to two other tuples that are also tagged as
Nodes. At the fringe of the tree are tuples that are tagged as Empty; these contain
no further references. Because all Empty tuples are the same, the implementation
is free to use just one, and to have every reference point to it.
■
In Lisp, which uses a reference model of variables but is not statically typed,
EXAMPLE 8.34
```

```
Tree type in Lisp
our tree could be speciﬁed textually as ‚(#\R (#\X ()()) (#\Y (#\Z ()())
(#\W ()()))). Each level of parentheses brackets the elements of a list. In this
case, the outermost such list contains three elements: the character R and nested
```

X


![Figure 8.11 Implementation of...](images/page_413_vector_251.png)
*Figure 8.11 Implementation of a tree in ML. The abstract (conceptual) tree is shown at the lower left.*

```
lists to represent the left and right subtrees. (The preﬁx #\ notation serves the
same purpose as surrounding quotes in other languages.) Semantically, each list
is a pair of references: one to the head and one to the remainder of the list. As
we noted in Section 8.5.1, these semantics are almost always reﬂected in the im-
plementation by a cons cell containing two pointers. A binary tree can thus be
represented as a three-element (three cons cell) list, as shown in Figure 8.12. At
the top level of the ﬁgure, the ﬁrst cons cell points to R; the second and third
point to nested lists representing the left and right subtrees. Each block of mem-
ory is tagged to indicate whether it is a cons cell or an atom. An atom is anything
other than a cons cell; that is, an object of a built-in type (integer, real, character,
string, etc.), or a user-deﬁned structure (record) or array. The uniformity of Lisp
lists (everything is a cons cell or an atom) makes it easy to write polymorphic
functions, though without the static type checking of ML.
■
If one programs in a purely functional style in ML or in Lisp, the data struc-
tures created with recursive types turn out to be acyclic. New objects refer to old
ones, but old ones neverchange, and thus neverpoint to new ones. Circular struc-
tures are typically deﬁned by using the imperative features of the languages. (For
an exception to this rule, see Exercise 8.21.) In ML, the imperative features in-
clude an explicit notion of pointer, discussed brieﬂy under “Value Model” below.
Even when writing in a functional style, one often ﬁnds a need for types that
are mutually recursive. In a compiler, for example, it is likely that symbol table
EXAMPLE 8.35
```

Mutually recursive types
in OCaml
records and syntax tree nodes will need to refer to each other. A syntax tree node
that represents a subroutine call will need to refer to the symbol table record that
represents the subroutine. The symbol table record, for its part, will need to refer
to the syntax tree node at the root of the subtree that represents the subroutine’s
code. If types are declared one at a time, and if names must be declared before
they can be used, then whichever mutually recursive type is declared ﬁrst will be

*C*
*C*

*C*
*C*
*C*

*A*
W

*C*
*C*
*C*


![Figure 8.12 Implementation of...](images/page_414_vector_286.png)
*Figure 8.12 Implementation of a tree in Lisp. A diagonal slash through a box indicates a null pointer. The C and A tags serve to distinguish the two kinds of memory blocks: cons cells and blocks containing atoms.*

unable to refer to the other. ML family languagesaddress this problem by allowing
types to be declared together as a group. Using OCaml syntax,

```
type subroutine_info = {code: syn_tree_node; ...}
(* record *)
and subr_call_info
= {subr: sym_tab_rec; ...}
(* record *)
and sym_tab_rec =
(* variant *)
Variable of ...
| Type of ...
| ...
| Subroutine of subroutine_info
and syn_tree_node =
(* variant *)
Expression of ...
| Loop of ...
| ...
| Subr_call of subr_call_info;;
```

Mutually recursive types of this sort are trivial in Lisp, since it is dynamically
typed. (Common Lisp includes a notion of structures, but ﬁeld types are not
declared. In simpler Lisp dialects programmers use nested lists in which ﬁelds are
merely positional conventions.)
■

curr

prev

curr

prev

curr

prev

curr


![Figure 8.15 Heap exploration...](images/page_428_vector_416.png)
*Figure 8.15 Heap exploration via pointer reversal. The block currently under examination is indicated by the curr pointer. The previous block is indicated by the prev pointer. As the garbage collector moves from one block to the next, it changes the pointer it follows to refer back to the previous block. When it returns to a block it restores the pointer. Each reversed pointer must be marked (indicated with a shaded box), to distinguish it from other, forward pointers in the same block.*

Many garbage collectors employ a technique known as* stop-and-copy* that
achieves compaction while simultaneously eliminating Steps 1 and 3 in the stan-
dard mark-and-sweep algorithm. Speciﬁcally, they divide the heap into two re-
gions of equal size. All allocation happens in the ﬁrst half. When this half is
(nearly) full, the collector begins its exploration of reachable data structures.
Each reachable block is copied into contiguous locations in the second half of
the heap, with no external fragmentation. The old version of the block, in the
ﬁrst half of the heap, is overwritten with a “useful” ﬂag and a pointer to the new
location. Any other pointer that refers to the same block (and is found later in
the exploration) is set to point to the new location. When the collector ﬁnishes its
exploration, all useful objects have been moved (and compacted) into the second

