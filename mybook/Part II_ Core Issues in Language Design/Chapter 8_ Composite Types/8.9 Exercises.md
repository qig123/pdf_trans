# 8.9 Exercises

**404**
Chapter 8* Composite Types*

considered too expensive for production-quality imperative languages, garbage
collection is now standard not only in functional and scripting languages, but in
Ada, Java, C#, Scala, and Go, among others.
## 8.9

**Exercises**
8.1
Suppose we are compiling for a machine with 1-byte characters, 2-byte
shorts, 4-byte integers, and 8-byte reals, and with alignment rules that re-
quire the address of every primitive data element to be an even multiple of
the element’s size. Suppose further that the compiler is not permitted to
reorder ﬁelds. How much space will be consumed by the following array?
Explain.

A : array [0..9] of record
s : short
c : char
t : short
d : char
r : real
i : integer

8.2
In Example 8.10 we suggested the possibility of sorting record ﬁelds by
their alignment requirement, to minimize holes.
In the example, we
sorted smallest-alignment-ﬁrst. What would happen if we sorted longest-
alignment-ﬁrst? Do you see any advantages to this scheme? Any disad-
vantages? If the record as a whole must be an even multiple of the longest
alignment, do the two approaches ever differ in total space required?
8.3
Give Ada code to map from lowercase to uppercase letters, using
(a) an array
(b) a function

```
Note the similarity of syntax: in both cases upper(‚a‚) is ‚A‚.
8.4
In Section 8.2.2 we noted that in a language with dynamic arrays and a
value model of variables, records could have ﬁelds whose size is not known
at compile time. To accommodate these, we suggested using a dope vector
for the record, to track the offsets of the ﬁelds.
Suppose instead that we want to maintain a static offset for each ﬁeld.
Can we devise an alternative strategy inspired by the stack frame layout of
Figure 8.7, and divide each record into a ﬁxed-size part and a variable-size
part? What problems would we need to address? (Hint: Consider nested
records.)
8.5
Explain how to extend Figure 8.7 to accommodate subroutine arguments
that are passed by value, but whose shape is not known until the subroutine
is called at run time.
```

type A = record
x : pointer to B
y : real

```
The ++ operator denotes list concatenation (similar to @ in ML). The :
operator is equivalent to ML’s :: or Lisp’s cons. Show how to express the
two elided expressions as list comprehensions.
```

8.23–8.31 In More Depth.

