402
Chapter 8 Composite Types
form, but may be converted to and from internal types during read and write
operations. As examples, we consider the text I/O facilities of Fortran, Ada, C,
and C++.
3CHECK YOUR UNDERSTANDING
34. Why are lists so heavily used in functional programming languages?
35. What are list comprehensions? What languages support them?
36. Compare and contrast the support for lists in ML- and Lisp-family languages.
37. Explain the distinction between interactive and ﬁle-based I/O; between tem-
porary and persistent ﬁles.
38. What are some of the tradeoffs between supporting I/O in the language
proper versus supporting it in libraries?
8.8
Summary and Concluding Remarks
This section concludes the fourth of our six core chapters on language design
(names [from Part I], control ﬂow, type systems, composite types, subroutines,
and classes). In our survey of composite types, we spent the most time on records,
arrays, and recursive types. Key issues for records include the syntax and seman-
tics of variant records, whole-record operations, type safety, and the interaction
of each of these with memory layout. Memory layout is also important for arrays,
in which it interacts with binding time for shape; static, stack, and heap-based
allocation strategies; efﬁcient array traversal in numeric applications; the inter-
operability of pointers and arrays in C; and the available set of whole-array and
slice-based operations.
For recursive data types, much depends on the choice between the value and
reference models of variables/names. Recursive types are a natural fallout of the
reference model; with the value model they require the notion of a pointer: a
variable whose value is a reference. The distinction between values and refer-
ences is important from an implementation point of view: it would be wasteful
to implement built-in types as references, so languages with a reference model
generally implement built-in and user-deﬁned types differently. Java reﬂects this
distinction in the language semantics, calling for a value model of built-in types
and a reference model for objects of user-deﬁned class types.
Recursive types are generally used to create linked data structures. In most
cases these structures must be allocated from a heap. In some languages, the pro-
grammer is responsible for deallocating heap objects that are no longer needed.
In other languages, the language run-time system identiﬁes and reclaims such
garbage automatically. Explicit deallocation is a burden on the programmer, and
8.8 Summary and Concluding Remarks
403
leads to the problems of memory leaks and dangling references. While language im-
plementations almost never attempt to catch memory leaks (see Exploration 3.34
and Exercise C 8.28, however, for some ideas on this subject) tombstones or locks
and keys are sometimes used to catch dangling references. Automatic garbage
collection can be expensive, but has proved increasingly popular. Most garbage-
collection techniques rely either on reference counts or on some form of recursive
exploration (tracing) of currently accessible structures. Techniques in this latter
category include mark-and-sweep, stop-and-copy, and generational collection.
Few areas of language design display as much variation as I/O. Our discus-
sion (largely on the companion site) distinguished between interactive I/O, which
tends to be very platform speciﬁc, and ﬁle-based I/O, which subdivides into tem-
porary ﬁles, used for voluminous data within a single program run, and persistent
ﬁles, used for off-line storage. Files also subdivide into those that represent their
information in a binary form that mimics layout in memory and those that con-
vert to and from character-based text. In comparison to binary ﬁles, text ﬁles
generally incur both time and space overhead, but they have the important ad-
vantages of portability and human readability.
In our examination of types, we saw many examples of language innovations
that have served to improve the clarity and maintainability of programs, often
with little or no performance overhead. Examples include the original idea of
user-deﬁned types (Algol 68), enumeration and subrange types (Pascal), the in-
tegration of records and variants (Pascal), and the distinction between subtypes
and derived types in Ada. In Chapter 10 we will examine what many consider the
most important language innovation of the past 30 years, namely object orienta-
tion.
As in previous chapters, we saw several cases in which a language’s conve-
nience, orthogonality, or type safety appears to have been compromised in or-
der to simplify the compiler, or to make compiled programs smaller or faster.
Examples include the lack of an equality test for records in many languages, the
requirement in Pascal and Ada that the variant portion of a record lie at the end,
the limitations in many languages on the maximum size of sets, the lack of type
checking for I/O in C, and the general lack of dynamic semantic checks in many
language implementations. We also saw several examples of language features
introduced at least in part for the sake of efﬁcient implementation. These in-
clude packed types, multilength numeric types, decimal arithmetic, and C-style
pointer arithmetic.
At the same time, one can identify a growing willingness on the part of lan-
guage designers and users to tolerate complexity and cost in language implemen-
tation in order to improve semantics. Examples here include the type-safe variant
records of Ada; the standard-length numeric types of Java and C#; the variable-
length strings and string operators of modern scripting languages; the late bind-
ing of array bounds in Ada, C, and the various scripting languages; and the wealth
of whole-array and slice-based array operations in Fortran 90. One might also in-
clude the polymorphic type inference of ML and its descendants. Certainly one
should include the widespread adoption of automatic garbage collection. Once
