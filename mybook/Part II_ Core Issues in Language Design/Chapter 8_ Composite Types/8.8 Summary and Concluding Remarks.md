# 8.8 Summary and Concluding Remarks

**402**
Chapter 8* Composite Types*

```
form, but may be converted to and from internal types during read and write
operations. As examples, we consider the text I/O facilities of Fortran, Ada, C,
and C++.
```

```
3CHECK YOUR UNDERSTANDING
34. Why are lists so heavily used in functional programming languages?
35. What are list comprehensions? What languages support them?
```

36. Compare and contrast the support for lists in ML- and Lisp-family languages.
37. Explain the distinction between* interactive* and* ﬁle-based* I/O; between* tem-*
*porary* and* persistent* ﬁles.
38. What are some of the tradeoffs between supporting I/O in the language
proper versus supporting it in libraries?

## 8.8

**Summary and Concluding Remarks**
This section concludes the fourth of our six core chapters on language design
(names [from Part I], control ﬂow, type systems, composite types, subroutines,
and classes). In our survey of composite types, we spent the most time on records,
arrays, and recursive types. Key issues for records include the syntax and seman-
tics of variant records, whole-record operations, type safety, and the interaction
of each of these with memory layout. Memory layout is also important for arrays,
in which it interacts with binding time for shape; static, stack, and heap-based
allocation strategies; efﬁcient array traversal in numeric applications; the inter-
operability of pointers and arrays in C; and the available set of whole-array and
*slice*-based operations.
For recursive data types, much depends on the choice between the* value* and
*reference models* of variables/names. Recursive types are a natural fallout of the
reference model; with the value model they require the notion of a* pointer*: a
variable whose value is a reference. The distinction between values and refer-
ences is important from an implementation point of view: it would be wasteful
to implement built-in types as references, so languages with a reference model
generally implement built-in and user-deﬁned types differently. Java reﬂects this
distinction in the language semantics, calling for a value model of built-in types
and a reference model for objects of user-deﬁned class types.
Recursive types are generally used to create linked data structures. In most
cases these structures must be allocated from a heap. In some languages, the pro-
grammer is responsible for deallocating heap objects that are no longer needed.
In other languages, the language run-time system identiﬁes and reclaims such
*garbage* automatically. Explicit deallocation is a burden on the programmer, and

