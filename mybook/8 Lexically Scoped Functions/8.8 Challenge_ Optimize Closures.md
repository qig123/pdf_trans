# 8.8 Challenge: Optimize Closures

8.8 Challenge: Optimize Closures

In this chapter we compile lexically scoped functions into a relatively efficient representation: flat closures. However, even this representation comes with some overhead. For example, consider the following program with a function tail_sum that does not have any free variables and where all the uses of tail_sum are in applications in which we know that only tail_sum is being applied (and not any other functions):

```
(define (tail_sum [n : Integer] [s : Integer]) : Integer
(if (eq? n 0)
s
(tail_sum (- n 1) (+ n s))))
```

(+ (tail_sum 3 0) 36)

As described in this chapter, we uniformly apply closure conversion to all functions, obtaining the following output for this program:

```
(define (tail_sum1 [fvs5 : _] [n2 : Integer] [s3 : Integer]) : Integer
(if (eq? n2 0)
s3
(let ([clos4 (closure (list (fun-ref tail_sum1 2)))])
((vector-ref clos4 0) clos4 (+ n2 -1) (+ n2 s3)))))
```

```
(define (main) : Integer
(+ (let ([clos6 (closure (list (fun-ref tail_sum1 2)))])
((vector-ref clos6 0) clos6 3 0)) 27))
```

If this program were compiled according to the previous chapter, there would be no allocation and the calls to tail_sum would be direct calls. In contrast, the program presented here allocates memory for each closure and the calls to tail_sum are indirect. These two differences incur considerable overhead in a program such as this, in which the allocations and indirect calls occur inside a tight loop. One might think that this problem is trivial to solve: canâ€™t we just recognize calls of the form (Apply (FunRef f n) args) and compile them to direct calls instead of treating it like a call to a closure? We would also drop the new fvs parameter of tail_sum. However, this problem is not so trivial, because a global function may escape and become involved in applications that also involve closures. Consider the following example in which the application (f 41) needs to be compiled into a closure application because the lambda may flow into f, but the inc function might also flow into f:

```
(define (inc [x : Integer]) : Integer
(+ x 1))
```

```
(let ([y (read)])
(let ([f (if (eq? (read) 0)
inc
(lambda: ([x : Integer]) : Integer (- x y)))])
(f 41)))
```

If a global function name is used in any way other than as the operator in a direct call, then we say that the function escapes. If a global function does not escape, then we do not need to perform closure conversion on the function.

Exercise 8.2 Implement an auxiliary function for detecting which global functions escape. Using that function, implement an improved version of closure conversion that does not apply closure conversion to global functions that do not escape but instead compiles them as regular functions. Create several new test cases that check whether your compiler properly detects whether global functions escape or not.

So far we have reduced the overhead of calling global functions, but it would also be nice to reduce the overhead of calling a lambda when we can determine at compile time which lambda will be called. We refer to such calls as known calls. Consider the following example in which a lambda is bound to f and then applied.

```
(let ([y (read)])
(let ([f (lambda: ([x : Integer]) : Integer
(+ x y))])
(f 21)))
```

Closure conversion compiles the application (f 21) into an indirect call, as follows:

```
(define (lambda5 [fvs6 : (Vector _ Integer)] [x3 : Integer]) : Integer
(let ([y2 (vector-ref fvs6 1)])
(+ x3 y2)))
```

```
(define (main) : Integer
(let ([y2 (read)])
(let ([f4 (Closure 1 (list (fun-ref lambda5 1) y2))])
((vector-ref f4 0) f4 21))))
```

However, we can instead compile the application (f 21) into a direct call, as follows:

```
(define (main) : Integer
(let ([y2 (read)])
(let ([f4 (Closure 1 (list (fun-ref lambda5 1) y2))])
((fun-ref lambda5 1) f4 21))))
```

The problem of determining which lambda will be called from a particular appli- cation is quite challenging in general and the topic of considerable research (Shivers 1988; Gilray et al. 2016). For the following exercise we recommend that you com- pile an application to a direct call when the operator is a variable and the variable

