# 8.3 Assignment Conversion

8.2 Assignment and Lexically Scoped Functions

The combination of lexically scoped functions and assignment to variables raises a challenge with the flat-closure approach to implementing lexically scoped functions. Consider the following example in which function f has a free variable x that is changed after f is created but before the call to f.

```
(let ([x 0])
(let ([y 0])
(let ([z 20])
(let ([f (lambda: ([a : Integer]) : Integer (+ a (+ x z)))])
(begin
(set! x 10)
(set! y 12)
(f y))))))
```

The correct output for this example is 42 because the call to f is required to use the current value of x (which is 10). Unfortunately, the closure conversion pass (section 8.4) generates code for the lambda that copies the old value of x into a closure. Thus, if we naively applied closure conversion, the output of this program would be 32. A first attempt at solving this problem would be to save a pointer to x in the clo- sure and change the occurrences of x inside the lambda to dereference the pointer. Of course, this would require assigning x to the stack and not to a register. How- ever, the problem goes a bit deeper. Consider the following example that returns a function that refers to a local variable of the enclosing function:

```
(define (f) : ( -> Integer)
(let ([x 0])
(let ([g (lambda: () : Integer x)])
(begin
(set! x 42)
g))))
((f))
```

In this example, the lifetime of x extends beyond the lifetime of the call to f. Thus, if we were to store x on the stack frame for the call to f, it would be gone by the time we called g, leaving us with dangling pointers for x. This example demonstrates that when a variable occurs free inside a function, its lifetime becomes indefinite. Thus, the value of the variable needs to live on the heap. The verb box is often used for allocating a single value on the heap, producing a pointer, and unbox for dereferencing the pointer. We introduce a new pass named convert_assignments to address this challenge.

8.3 Assignment Conversion

The purpose of the convert_assignments pass is to address the challenge regard- ing the interaction between variable assignments and closure conversion. First we

identify which variables need to be boxed, and then we transform the program to box those variables. In general, boxing introduces runtime overhead that we would like to avoid, so we should box as few variables as possible. We recommend boxing the variables in the intersection of the following two sets of variables:

* The variables that are free in a lambda.
* The variables that appear on the left-hand side of an assignment.

The first condition is a must but the second condition is conservative. It is possible to develop a more liberal condition using static program analysis. Consider again the first example from section 8.2:

```
(let ([x 0])
(let ([y 0])
(let ([z 20])
(let ([f (lambda: ([a : Integer]) : Integer (+ a (+ x z)))])
(begin
(set! x 10)
(set! y 12)
(f y))))))
```

The variables x and y appear on the left-hand side of assignments. The variables x and z occur free inside the lambda. Thus, variable x needs to be boxed but not y or z. The boxing of x consists of three transformations: initialize x with a tuple whose element is uninitialized, replace reads from x with tuple reads, and replace each assignment to x with a tuple write. The output of convert_assignments for this example is as follows:

```
(define (main) : Integer
(let ([x0 (vector 0)])
(let ([y1 0])
(let ([z2 20])
(let ([f4 (lambda: ([a3 : Integer]) : Integer
(+ a3 (+ (vector-ref x0 0) z2)))])
(begin
(vector-set! x0 0 10)
(set! y1 12)
(f4 y1)))))))
```

To compute the free variables of all the lambda expressions, we recommend defining the following two auxiliary functions:

* free_variables computes the free variables of an expression, and
* free_in_lambda collects all the variables that are free in any of the lambda
  expressions, using free_variables in the case for each lambda.

To compute the variables that are assigned to, we recommend updating the collect-set! function that we introduced in section 5.4 to include the new AST forms such as Lambda. Let AF be the intersection of the set of variables that are free in a lambda and that are assigned to in the enclosing function definition.

