# 8.1 The L Language

![Figure 8.3...](images/page_161_vector_322.png)
*Figure 8.3*

dance. But doesn’t this lambda take only one argument, for parameter z? The third and final step of the dance is generating a top-level function for a lambda. We add an additional parameter for the closure and insert an initialization at the beginning of the function for each free variable, to bind those variables to the appropriate elements from the closure parameter. This three-step dance is known as closure conversion. We discuss the details of closure conversion in section 8.4 and show the code generated from the example in section 8.4.1. First, we define the syntax and semantics of Lλ in section 8.1.

8.1 The Lλ Language

The definitions of the concrete syntax and abstract syntax for Lλ, a language with anonymous functions and lexical scoping, are shown in figures 8.3 and 8.4. They add the lambda form to the grammar for LFun, which already has syntax for function application. The procedure-arity operation returns the number of parameters of a given function, an operation that we need for the translation of dynamic typing that is discussed in chapter 9. Figure 8.5 shows the definitional interpreter for Lλ. The case for Lambda saves the current environment inside the returned function value. Recall that during function application, the environment stored in the function value, extended with the mapping of parameters to argument values, is used to interpret the body of the function.

![Figure 8.4...](images/page_162_vector_344.png)
*Figure 8.4*

![Figure 8.6...](images/page_162_vector_383.png)
*Figure 8.6*

![(super-new)...](images/page_163_vector_88.png)
*(super-new)*

![Figure 8.5...](images/page_163_vector_368.png)
*Figure 8.5*

![Figure 8.6...](images/page_163_vector_597.png)
*Figure 8.6*

