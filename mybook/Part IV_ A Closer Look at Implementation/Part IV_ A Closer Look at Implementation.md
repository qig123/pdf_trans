# Part IV: A Closer Look at Implementation

IV A Closer Look at Implementation

In this, the ﬁnal and shortest of the major parts of the text, we return our focus to implemen- tation issues. Chapter 15 considers the work that must be done, in the wake of semantic analysis, to generate a runnable program. The ﬁrst half of the chapter describes, in general terms, the structure of the back end of the typical compiler, surveys intermediate program representations, and uses the attribute grammar framework of Chapter 4 to describe how a compiler produces assembly-level code. The second half of the chapter describes the structure of the typical process address space, and explains how the assembler and linker transform the output of the compiler into executable code. In any nontrivial language implementation, the compiler assumes the existence of a large body of preexisting code for storage management, exception handling, dynamic linking, and the like. A more sophisticated language may require events, threads, and messages as well. When the libraries that implement these features depend on knowledge of the compiler or of the structure of the running program, they are said to constitute a run-time system. We consider such systems in Chapter 16. We focus in particular on virtual machines; run-time manipulation of machine code; and reﬂection mechanisms, which allow a program to reason about its run- time structure and types. The back-end compiler description in Chapter 15 is by necessity simplistic. Entire books and courses are devoted to the fuller story, most of which focuses on the code improvement or optimization techniques used to produce efﬁcient code. Chapter 17 of the current text, con- tained entirely on the companion site, provides an overview of code improvement. Since most programmers will never write the back end of a compiler, the goal of Chapter 17 is more to convey a sense of what the compiler does than exactly how it does it. Programmers who un- derstand this material will be in a better position to “work with” the compiler, knowing what is possible, what to expect in common cases, and how to avoid programming idioms that are hard to optimize. Topics include local and “global” (procedure-level) redundancy elimination, data ﬂow analysis, loop optimization, and register allocation.

![Uncaptioned Image page 806 xref 2554](images/page_806_uncaptioned_img_2554.jpeg)

This page intentionally left blank

