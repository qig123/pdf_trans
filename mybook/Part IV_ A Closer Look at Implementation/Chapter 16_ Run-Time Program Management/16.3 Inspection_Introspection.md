# 16.3 Inspection/Introspection

16.3 Inspection/Introspection
**837**

## 16.3

**Inspection/Introspection**
Symbol table metadata makes it easy for utility programs—just-in-time and dy-
namic compilers, optimizers, debuggers, proﬁlers, and binary rewriters—to* in-*
*spect* a program and reason about its structure and types. We consider debuggers
and proﬁlers in particular in Sections 16.3.2 and 16.3.3. There is no reason, how-
ever, why the use of metadata should be limited to outside tools, and indeed it is
not: Lisp has long allowed a program to reason about its own internal structure
and types (this sort of reasoning is sometimes called* introspection*). Java and C#
provide similar functionality through a* reﬂection* API that allows a program to
peruse its own metadata. Reﬂection appears in several other languages as well,
including Prolog (Sidebar 12.2) and all the major scripting languages. In a dy-
namically typed language such as Lisp, reﬂection is essential: it allows a library
or application function to type check its own arguments. In a statically typed
language, reﬂection supports a variety of programming idioms that were not tra-
ditionally feasible.

16.3.1** Reﬂection**

Trivially, reﬂection can be useful when printing diagnostics. Suppose we are try-
**EXAMPLE** 16.18

```
Finding the concrete type
of a reference variable
ing to debug an old-style (nongeneric) queue in Java, and we want to trace the
objects that move through it. In the dequeue method, just before returning an
object rtn of type Object, we might write
```

```
System.out.println("Dequeued a " + rtn.getClass().getName());
```

```
If the dequeued object is a boxed int, we will see
```

```
Dequeued a java.lang.Integer
■
```

More signiﬁcantly, reﬂection is useful in programs that manipulate other pro-
grams. Most program development environments, for example, have mecha-
nisms to organize and “pretty-print” the classes, methods, and variables of a pro-
gram. In a language with reﬂection, these tools have no need to examine source
code: if they load the already-compiled program into their own address space,
they can use the reﬂection API to query the symbol table information created by
the compiler. Interpreters, debuggers, and proﬁlers can work in a similar fashion.
In a distributed system, a program can use reﬂection to create a general-purpose
*serialization* mechanism, capable of transforming an almost arbitrary structure
into a linear stream of bytes that can be sent over a network and reassembled at
the other end. (Both Java and C# include such mechanisms in their standard li-
brary, implemented on top of the basic language.) In the increasingly dynamic

```
Here Foo is assumed to be a user-deﬁned class in the default (outermost) package.
A left square bracket indicates an array type; it is followed by the array’s element
type. The built-in types (e.g., int) are represented in this context by single-letter
names (e.g., I). User-deﬁned types are indicated by an L, followed by the fully
qualiﬁed class name and terminated by a semicolon. Notice the similarity of the
second example (C) to entry #12 in the constant pool of Figure 16.1: that entry
```

```
Listing the methods of a
Java class
by) a given class. Also shown is output for AccessibleObject, the parent class
of Method, Field, and Constructor. (The primary purpose of this class is to
```

