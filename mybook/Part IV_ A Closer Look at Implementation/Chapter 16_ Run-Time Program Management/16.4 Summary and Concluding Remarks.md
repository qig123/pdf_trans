# 16.4 Summary and Concluding Remarks

32. What are javadoc, apt, JML, and LINQ, and what do they have to do with annotation? 33. Brieﬂy describe three different implementation strategies for a symbolic de- bugger.

34. Explain the difference between breakpoints and watchpoints. Why are watch- points potentially much more expensive?

35. Summarize the capabilities provided by the Unix ptrace mechanism. 36. What is the principal difference between the Unix prof and gprof tools? 37. For the purposes of performance analysis, summarize the relative strengths and limitations of statistical sampling, instrumentation, and hardware perfor- mance counters. Explain why statistical sampling and instrumentation might proﬁtably be used together.

16.4 Summary and Concluding Remarks

We began this chapter by deﬁning a run-time system as the set of libraries, es- sential to many language implementations, that depend on knowledge of the compiler or the programs it produces. We distinguished these from “ordinary” libraries, which require only the arguments they are passed. We noted that several topics covered elsewhere in the book, including garbage collection, variable-length argument lists, exception and event handling, corou- tines and threads, remote procedure calls, transactional memory, and dynamic linking are often considered the purview of the run-time system. We then turned to virtual machines, focusing in particular on the Java Virtual Machine (JVM) and the Common Language Infrastructure (CLI). Under the general heading of late binding of machine code, we considered just-in-time and dynamic compila- tion, binary translation and rewriting, and mobile code and sandboxing. Finally, under the general heading of inspection and introspection, we considered reﬂec- tion mechanisms, symbolic debugging, and performance analysis. Through all these topics we have seen a steady increase in complexity over time. Early Basic interpreters parsed and executed one source statement at a time. Modern interpreters ﬁrst translate their source into a syntax tree. Early Java im- plementations, while still interpreter-based, relied on a separate source-to-byte- code compiler. Modern Java implementations, as well as implementations of the CLI, enhance performance with a just-in-time compiler. For programs that ex- tend themselves at run time, the CLI allows the source-to-byte-code compiler to be invoked dynamically as well, as it is in Common Lisp. Recent systems may pro- ﬁle and reoptimize already-running programs. Similar technology may allow sep- arate tools to translate from one machine language to another, or to instrument code for testing, debugging, security, performance analysis, model checking, or

