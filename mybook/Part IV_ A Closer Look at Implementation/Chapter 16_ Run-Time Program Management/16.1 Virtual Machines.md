# 16.1 Virtual Machines

**810**
Chapter 16* Run-Time Program Management*

compiler-generated code (e.g., parameter-passing conventions, synchronization
mechanisms, and the layout of run-time stacks). The coupling between compiler
and runtime runs deeper than this, however: the CLI programming interface is
so complete as to fully hide the underlying hardware.1 Such a runtime is known
as a* virtual machine*. Some virtual machines—notably the Java Virtual Machine
(JVM)—are language-speciﬁc. Others, including the CLI, are explicitly intended
for use with multiple languages. In conjunction with developmentof their version
of the CLI,2 Microsoft introduced the term* managed code* to referto programs that
run on top of a virtual machine.
■
Virtual machines are part of a growing trend toward run-time management
and manipulation of programs using compiler technology. This trend is the sub-
ject of this chapter. We consider virtual machines in more detail in Section 16.1.
To avoid the overhead of emulating a non-native instruction set, many virtual ma-
chines use a* just-in-time* (JIT) compiler to translate their instruction set to that of
the underlying hardware. Some may even invoke the compiler after the program
is running, to compile newly discovered components or to optimize code based
on dynamically discovered properties of the program, its input, or the underly-
ing system. Using related technology, some language implementations perform
*binary translation* to retarget programs compiled for one machine to run on an-
other machine, or* binary rewriting* to instrument or optimize programs that have
already been compiled for the current machine. We consider these various forms
of late binding of machine code in Section 16.2. Finally, in Section 16.3, we con-
sider run-time mechanisms to inspect or modify the state of a running program.
Such mechanisms are needed by symbolic debuggers and by proﬁling and perfor-
mance analysis tools. They may also support* reﬂection*, which allows a program
to inspect and reason about its* own* state at run time.
## 16.1

**Virtual Machines**
A* virtual machine* (VM) provides a complete programming environment: its ap-
plication programming interface (API) includes everything required for correct
execution of the programs that run above it. We typically reserve use of the term
“VM” to environments whose level of abstraction is comparable to that of a com-
puter implemented in hardware. (A Smalltalk or Python interpreter, for example,
is usually not described as a virtual machine, because its level of abstraction is too
high, but this is a subjective call.)
Every virtual machine API includes an instruction set architecture (ISA) in
which to express programs. This may be the same as the instruction set of some

**1**
In particular, the CLI deﬁnes the instruction set of compiler’s target language: the Common
Intermediate Language (CIL) described in Section C 16.1.2.

**2**
CLI is an ECMA and ISO standard. CLR—the Common Language Runtime—is Microsoft’s im-
plementation of the CLI. It is part of the .NET framework.

The interface provided by the JVM was designed to be an attractive target for
a Java compiler. It provides direct support for all (and only) the built-in and

**DESIGN & IMPLEMENTATION**

16.2 Optimizing stack-based IF
As we shall see in Section C 16.1.2, code for the CLI was not intended for inter-
pretation; it is almost always JIT compiled. As a result, the extra instructions
sometimes needed to capture an expression in stack-based form are not a se-
rious problem: reasonably straightforward code improvement algorithms (to
be discussed in Chapter 17) allow the JIT compiler to transform the left side of
Figure 15.4 into good machine code at load time. In the judgment of the CLI
designers, the simplicity and compactness of the stack-based code outweigh
the cost of the code improvement. For Java, the need for compact mobile code
(e.g., browser applets) was a compelling advantage, even in early implementa-
tions that were interpreted rather than JIT compiled.
The higher level of abstraction of stack-based code also enhances portabil-
ity. Three-address instructions might be a good ﬁt for execution on SPARC
machines, but not on the x86 (a two-address machine).

```
n.next = t;
```

```
} // else v already in set
}
```

```
Code:
Stack=3, Locals=4, Args_size=2
0:
aload_0
// this
1:
getfield
#4; //Field head:LLLset$node;
4:
astore_2
5:
aload_2
// n
6:
getfield
#5; //Field LLset$node.next:LLLset$node;
9:
ifnull
31
// conditional branch
12:
aload_2
13:
getfield
#5; //Field LLset$node.next:LLLset$node;
16:
getfield
#6; //Field LLset$node.val:I
19:
iload_1
// v
20:
if_icmpge
31
23:
aload_2
24:
getfield
#5; //Field LLset$node.next:LLLset$node;
27:
astore_2
28:
goto
5
31:
aload_2
32:
getfield
#5; //Field LLset$node.next:LLLset$node;
35:
ifnull
49
38:
aload_2
39:
getfield
#5; //Field LLset$node.next:LLLset$node;
42:
getfield
#6; //Field LLset$node.val:I
45:
iload_1
46:
if_icmple
76
49:
new
#2; //class LLset$node
52:
dup
53:
aload_0
54:
invokespecial #3; //Method LLset$node."<init>":(LLLset;)V
57:
astore_3
58:
aload_3
// t
59:
iload_1
60:
putfield
#6; //Field LLset$node.val:I
63:
aload_3
64:
aload_2
65:
getfield
#5; //Field LLset$node.next:LLLset$node;
68:
putfield
#5; //Field LLset$node.next:LLLset$node;
71:
aload_2
72:
aload_3
73:
putfield
#5; //Field LLset$node.next:LLLset$node;
76:
return
```


![Figure 16.2 Java source...](images/page_852_vector_564.png)
*Figure 16.2 Java source and bytecode for a list insertion method. Output on the right was produced by Oracle’s javac (compiler) and javap (disassembler) tools, with additional comments inserted by hand.*

