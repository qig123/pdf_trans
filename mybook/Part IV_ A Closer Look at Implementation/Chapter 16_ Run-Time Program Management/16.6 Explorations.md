# 16.6 Explorations

16.6 Explorations
**853**

```
This method should call the annotated methods with the speciﬁed param-
eters, test the return values, and report any discrepancies. It should also
call the test methods of any nested classes. Be sure to include a mech-
anism to invoke the test method of every top-level class. For an extra
challenge, devise a way to specify multiple tests of a single method, and a
way to test exceptions thrown, in addition to values returned.
16.12
C++ provides a typeid operator that can be used to query the concrete
type of a pointer or reference variable:
```

```
if (typeid(*p) == typeid(my_derived_type)) ...
```

```
Values returned by typeid can be compared for equality but not assigned.
They also support a name() method that returns an (implementation-
dependent) character string name for the type. Give an example of a pro-
gram fragment in which these mechanisms might reasonably be used.
Unlike more extensive reﬂection mechanisms, typeid can be applied
only to (instances of) classes with at least one virtual method. Give a plau-
sible explanation for this restriction.
16.13
Suppose we wish, as described at the end of Example 16.36, to accurately
attribute sampled time to the various contexts in which a subroutine is
called. Perhaps the most straightforward approach would be to log not
only the current PC but also the stack backtrace—the contents of the dy-
namic chain—on every timer interrupt. Unfortunately, this can dramat-
ically increase proﬁling overhead. Suggest an equivalent but cheaper im-
plementation.
```

16.14–16.17 In More Depth.
## 16.6

**Explorations**
```
16.18
Learn about the Java security policy mechanism. What aspects of program
behavior can the programmer enable/proscribe? How are such policies
enforced? What is the relationship (if any) between security policies and
the veriﬁcation process described in Sidebar 16.3?
16.19
Learn about taint mode in Perl and Ruby. How does it compare to sand-
box creation via binary rewriting, as described in Sidebar 16.5? What sorts
of security problems does it catch? What sorts of problems does it not
catch?
16.20
Learn about proof-carrying code, a technique in which the supplier of mo-
bile code includes a proof of its safety, and the user simply veriﬁes the
proof, rather than regenerating it (start with the work of Necula [Nec97]).
How does this technique compare to other forms of sandboxing? What
properties can it guarantee?
```

