# 16.7 Bibliographic Notes

16.21 Investigate the MetaObject Protocol (MOP), which underlies the Common Lisp Object System. How does it compare to the reﬂection mechanisms of Java and C#? What does it allow you to do that these other languages do not? 16.22 When using a symbolic debugger and moving through a program with breakpoints, one often discovers that one has gone “too far,” and must start the program over from the beginning. This may mean losing all the effort that had been put into reaching a particular point. Consider what it would take to be able to run the program not only forward but backward as well. Such a reverse execution facility might allow the user to narrow in on the source of bugs much as one narrows the range in binary search. Consider both the loss of information that happens when data is overridden and the nondeterminism that arises in parallel and event-driven programs. 16.23 Download and experiment with one of the several available packages for performance counter sampling in Linux (try sourceforge.net/projects/ perfctr/, perfmon2.sourceforge.net/, or www.intel.com/software/pcm). What do these packages allow you to measure? How might you use the informa- tion? (Note: you may need to install a kernel patch to make the program counters available to user-level code.)

16.24–16.25 In More Depth. 16.7 Bibliographic Notes

Aycock [Ayc03] surveys the history of just-in-time compilation. Documentation on the HotSpot compiler and JVM can be found at Oracle’s web site: www.oracle. com/technetwork/articles/javase/index-jsp-136373.html. The JVM speciﬁcation is by Lindholm et al. [LYBB14]. Sources of information on the CLI include the ECMA standard [Int12a, MR04] and the .NET pages at msdn.microsoft.com. Arnold et al. [AFG+05] provide an extensive survey of adaptive optimization techniques for programs on virtual machines. Deutsch and Schiffman [DS84] describe the ParcPlace Smalltalk virtual machine, which pioneered such mecha- nisms as just-in-time compilation and the caching of JIT-compiled machine code. Various articles discuss the binary translation technology of Apple’s 68K emula- tor [Tho95], DEC’s FX!32 [HH97b], and its earlier VEST and mx [SCK+93]. Probably the best source of information on binary rewriting is the text by Hazelwood [Haz11]. The original papers on Dynamo, Atom, Pin, and QEMU are by Bala et al. [BDB00], Srivastava and Eustace [SE94], Luk et al. [LCM+05], and Bellard [Bel05], respectively. Duesterwald [Due05] surveys issues in the de- sign of a dynamic binary optimizer, drawing on her experience with the Dynamo project. Early work on sandboxing via binary rewriting is reported by Wahbe et al. [WLAG93].

The DWARF standard is available from dwarfstd.org [DWA10]; Eager pro- vides a gentler introduction [Eag12]. Ball and Larus [BL92] describe the min- imal instrumentation required to proﬁle the execution of basic blocks. Zhao et al. [ZRA+08] describe the use of dynamic instrumentation (based on Dy- namoRIO) to implement watchpoints efﬁciently. Martonosi et al. [MGA92] describe a performance analysis tool that builds on the idea outlined in Exam- ple 16.37.

