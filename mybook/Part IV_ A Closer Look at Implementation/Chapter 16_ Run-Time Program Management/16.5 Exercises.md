# 16.5 Exercises

16.5 Exercises
**851**

architectural simulation. The CLI provides extensive support for cross-language
interoperability.
Many of these developments have served to blur the line between the compiler
and the run-time system, and between compile-time and run-time operations. It
seems safe to predict that these trends will continue. More and more, programs
will come to be seen not as static artifacts, but as dynamic collections of mal-
leable components, with rich semantic structure amenable to formal analysis and
reconﬁguration.
## 16.5

**Exercises**
16.1
Write the formula of Example 15.4 as an expression tree (a syntax tree in
which each operator is represented by an internal node whose children
are its operands). Convert your tree to an* expression DAG* by merging
identical nodes. Comment on the redundancy in the tree and how it relates
to Figure 15.4.
16.2
We assumed in Example 15.4 and Figure 15.4 that a, b, c, and s were
all among the ﬁrst few local variables of the current method, and could
be pushed onto or popped from the operand stack with a single one-byte
instruction. Suppose that this is not the case: that is, that the push and
pop instructions require three bytes each. How many bytes will now be
required for the code on the left side of Figure 15.4?
Most stack-based languages, Java bytecode and CIL among them, pro-
vide a swap instruction that reverses the order of the top two values on the
stack, and a duplicate instruction that pushes a second copy of the value
currently at top of stack. Show how to use swap and duplicate to elimi-
nate the pop and the pushes of s in the left side of Figure 15.4. Feel free to
exploit the associativity of multiplication. How many instructions is your
new sequence? How many bytes?
16.3
The speculative optimization of Example 16.5 could in principle be stati-
cally performed. Explain why a dynamic compiler might be able to do it
more effectively.
16.4
Perhaps the most common form of run-time instrumentation counts the
the number of times that each basic block is executed. Since basic blocks
are short, adding a load-increment-store instruction sequence to each
block can have a signiﬁcant impact on run time.
We can improve performance by noting that certain blocks imply the
execution of other blocks. In an if... then ... else construct, for example,
execution of either the then part or the else part implies execution of the
conditional test. If we’re smart, we won’t actually have to instrument the
test.
Describe a general technique to minimize the number of blocks that
must be instrumented to allow a post-processor to obtain an accurate

