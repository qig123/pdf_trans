# 16.5 Exercises

16.5 Exercises 851

architectural simulation. The CLI provides extensive support for cross-language interoperability. Many of these developments have served to blur the line between the compiler and the run-time system, and between compile-time and run-time operations. It seems safe to predict that these trends will continue. More and more, programs will come to be seen not as static artifacts, but as dynamic collections of mal- leable components, with rich semantic structure amenable to formal analysis and reconﬁguration. 16.5 Exercises

16.1 Write the formula of Example 15.4 as an expression tree (a syntax tree in which each operator is represented by an internal node whose children are its operands). Convert your tree to an expression DAG by merging identical nodes. Comment on the redundancy in the tree and how it relates to Figure 15.4. 16.2 We assumed in Example 15.4 and Figure 15.4 that a, b, c, and s were all among the ﬁrst few local variables of the current method, and could be pushed onto or popped from the operand stack with a single one-byte instruction. Suppose that this is not the case: that is, that the push and pop instructions require three bytes each. How many bytes will now be required for the code on the left side of Figure 15.4? Most stack-based languages, Java bytecode and CIL among them, pro- vide a swap instruction that reverses the order of the top two values on the stack, and a duplicate instruction that pushes a second copy of the value currently at top of stack. Show how to use swap and duplicate to elimi- nate the pop and the pushes of s in the left side of Figure 15.4. Feel free to exploit the associativity of multiplication. How many instructions is your new sequence? How many bytes? 16.3 The speculative optimization of Example 16.5 could in principle be stati- cally performed. Explain why a dynamic compiler might be able to do it more effectively. 16.4 Perhaps the most common form of run-time instrumentation counts the the number of times that each basic block is executed. Since basic blocks are short, adding a load-increment-store instruction sequence to each block can have a signiﬁcant impact on run time. We can improve performance by noting that certain blocks imply the execution of other blocks. In an if... then ... else construct, for example, execution of either the then part or the else part implies execution of the conditional test. If we’re smart, we won’t actually have to instrument the test. Describe a general technique to minimize the number of blocks that must be instrumented to allow a post-processor to obtain an accurate

852 Chapter 16 Run-Time Program Management

count for each block. (This is a difﬁcult problem. For hints, see the paper by Larus and Ball [BL92].) 16.5 Visit software.intel.com/en-us/articles/pintool-downloads and download a copy of Pin. Use it to create a tool to proﬁle loops. When given a (machine code) program and its input, the output of the tool should list the number of times that each loop was encountered when running the program. It should also give a histogram, for each loop, of the number of iterations executed. 16.6 Outline mechanisms that might be used by a binary rewriter, without access to source code, to catch uses of uninitialized variables, “double deletes,” and uses of deallocated memory (e.g., dangling pointers). Under what circumstances might you be able to catch memory leaks and out-of- bounds array accesses? 16.7 Extend the code of Figure 16.4 to print information about (a) ﬁelds (b) constructors (c) nested classes (d) implemented interfaces (e) ancestor classes, and their methods, ﬁelds, and constructors (f) exceptions thrown by methods (g) generic type parameters 16.8 Repeat the previous exercise in C#. Add information about parameter names and generic instances. 16.9 Write an interactive tool that accepts keyboard commands to load speci- ﬁed class ﬁles, create instances of their classes, invoke their methods, and read and write their ﬁelds. Feel free to limit keyboard input to values of built-in types, and to work only in the global scope. Based on your expe- rience, comment on the feasibility of writing a command-line interpreter for Java, similar to those commonly used for Lisp, Prolog, or the various scripting languages. 16.10 In Java, if the concrete type of p is Foo, p.getClass() and Foo.class will return the same thing. Explain why a similar equivalence could not be guaranteed to hold in Ruby, Python, or JavaScript. For hints, see Sec- tion 14.4.4. 16.11 Design a “test harness” system based on Java annotations. The user should be able to attach to a method an annotation that speciﬁes parameters to be passed to a test run of the method, and values expected to be re- turned. For simplicity, you may assume that parameters and return val- ues will all be strings or instances of built-in types. Using the annota- tion processing facility of Java 6, you should automatically generate a new method, test() in any class that has methods with @Test annotations.

