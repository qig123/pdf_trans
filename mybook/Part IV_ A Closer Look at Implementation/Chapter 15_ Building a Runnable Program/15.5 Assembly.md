# 15.5 Assembly

**792**
Chapter 15* Building a Runnable Program*

*Stack:* May be allocated in some ﬁxed amount at load time. More commonly, is
given a small initial size, and is then extended automatically by the operating
system in response to (faulting) accesses beyond the current segment end.
*Heap:* Like stack, may be allocated in some ﬁxed amount at load time. More
commonly, is given a small initial size, and is then extended in response to
explicit requests (via system call) from heap-management library routines.
*Files:* In many systems, library routines allow a program to* map* a ﬁle into mem-
ory. The map routine interacts with the operating system to create a new seg-
ment for the ﬁle, and returns the address of the beginning of the segment. The
contents of the segment are usually fetched from disk on demand, in response
to page faults.
*Dynamic libraries:* Modern operating systems typically arrange for most pro-
grams to share a single copy of the code for popular libraries (Section C 15.7).
From the point of view of an individual process, each such library tends to oc-
cupy a pair of segments: one for the shared code, one for* linkage information*
and for a private copy of any writable data the library may need.

The layout of these segments for a contemporary 32-bit Linux system on the
**EXAMPLE** 15.9

Linux address space layout
x86 appears in Figure 15.8. Relative placements and addresses may be different
for other operating systems and machines.
■
## 15.5

**Assembly**
Some compilers translate source ﬁles directly into object ﬁles acceptable to the
linker. More commonly, they generate assembly language that must subsequently
be processed by an assembler to create an object ﬁle.
In our examples we have consistently employed a symbolic (textual) notation
for code. Within a compiler, the representation would not be textual, but it would
still be symbolic, most likely consisting of records and linked lists. To translate this
symbolic representation into executable code, we must

**1.** Replace opcodes and operands with their machine language encodings.
**2.** Replace uses of symbolic names with actual addresses.

These are the principal tasks of an assembler.
In the early days of computing, most programmers wrote in assembly lan-
guage. To simplify the more tedious and repetitive aspects of assembly program-
ming, assemblers often provided extensive macro expansion facilities. With the
ubiquity of modern high-level languages, such programmer-centric features have
largely disappeared. Almost all assembly language programs today are written by
compilers.
When passing assembly language directly from the compiler to the assembler, it
**EXAMPLE** 15.10

Assembly as a ﬁnal
compiler pass
makes sense to use some internal (records and linked lists) representation. At the

Shared libraries and
memory-mapped files

Read-only code
(“text”) and constants

Uninitialized data

Initialized data

```
In early Unix systems with very limited memory,
the stack grew downward from the bottom of the
text segment; the number 0x08048000 is a legacy
of these systems. The sections marked “Shared li-
braries and memory-mapped ﬁles” typically com-
prise multiple segments with varying permissions
and addresses. (Modern Linux systems randomize
the choice of addresses to discourage malware.) The
top quarter of the address space belongs to the ker-
nel. Just over 1 MB of space is left unmapped at the
bottom of the address space to help catch program
bugs in which small integer values are accidentally
used as pointers.
```


![Figure 15.8 Layout of...](images/page_826_vector_367.png)
*Figure 15.8 Layout of 32-bit process address space in x86 Linux (not to scale). Double lines separate regions with potentially different access permissions.*

same time, we must provide a textual front end to accommodate the occasional
need for human input:

Source program

Object code

Internal data structures

Assembler source
Assembler source
Compiler

Assembler front end

Assembler back end

