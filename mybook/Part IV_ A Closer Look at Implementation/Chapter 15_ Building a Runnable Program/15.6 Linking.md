15.6 Linking
797
To relocate such an instruction, the linker must add the address of the target code
segment and the offset within it of the target instruction, subtract the address
of the current code segment and the offset within it of the branch instruction,
perform a two-bit right arithmetic shift, and truncate the result to 24 bits. In a
similar vein, a 32-bit load on ARM requires a two-instruction sequence analogous
to that of Example 15.14; if the loaded quantity is relocatable, the linker must re-
calculate the 16-bit operands of both instructions. Modern assemblers and object
ﬁle formats reﬂect this diversity of relocation modes.
■
15.6
Linking
Most language implementations—certainly all that are intended for the construc-
tion of large programs—support separate compilation: fragments of the program
can be compiled and assembled more or less independently. After compilation,
these fragments (known as compilation units) are “glued together” by a linker.
In many languages and environments, the programmer explicitly divides the pro-
gram into modules or ﬁles, each of which is separately compiled. More integrated
environments may abandon the notion of a ﬁle in favor of a database of subrou-
tines, each of which is separately compiled.
The task of a linker is to join together compilation units. A static linker does
its work prior to program execution, producing an executable object ﬁle. A dy-
namic linker (described in Section C 15.7) does its work after the (ﬁrst part of the)
program has been brought into memory for execution.
Each to-be-linked compilation unit must be a relocatable object ﬁle. Typically,
some ﬁles will have been produced by compiling fragments of the application
being constructed, while others will be preexisting library packages needed by
the application. Since most programs make use of libraries, even a “one-ﬁle”
application typically needs to be linked.
Linking involves two subtasks: relocation and the resolution of external ref-
erences. Some authors refer to relocation as loading, and call the entire “joining
together” process “link-loading.” Other authors (including the current one) use
“loading” to refer to the process of bringing an executable object ﬁle into memory
for execution. On very simple machines, or on machines with very simple oper-
ating systems, loading entails relocation. More commonly, the operating system
uses virtual memory to give every program the impression that it starts at some
standard address. In many systems loading also entails a certain amount of link-
ing (Section C 15.7).
798
Chapter 15 Building a Runnable Program
Relocatable object files
Executable object file
Code
 
…
A
B
Imports
 
M
 
M
Imports
 
X
 
r1 := &M (2300)
1800
800
500
300
 
call M (2300)
Exports
 
M
Exports
 
X
 
…
Relocation
Relocation
 
r1 := &L (1800)
900
2300
3000
 
r2 := Y (3900)
Code
 
…
Code
 
…
 
r3 := X (3300)
800
300
500
L:
 
r1 := &L (1000)
 
r1 := &M
1000
400
1500
1600
M:
 
r2 := Y (400)
 
call M
 
r3 := X
Data
L:
X:
M:
Data
Data
X:
Y:
Y:


![Figure 15.9 Linking relocatable...](images/page_831_caption_Figure%2015.9%20Linking%20relocatable%20object%20%EF%AC%81les%20A%20and%20B%20to%20make%20an%20executable%20object%20%EF%AC%81le.%20For%20simplicity.png)
*Figure 15.9 Linking relocatable object ﬁles A and B to make an executable object ﬁle. For simplicity of presentation, A’s code section has been placed at offset 0, with B’s code section immediately after, at offset 800 (addresses increase down the page). To allow the operating system to establish different protections for the code and data segments, A’s data section has been placed at the next page boundary (offset 3000), with B’s data section immediately after (offset 3500). External references to M and X have been set to use the appropriate addresses. Internal references to L and Y have been updated by adding in the starting addresses of B’s code and data sections, respectively.*

15.6.1 Relocation and Name Resolution
Each relocatable object ﬁle contains the information required for linking: the
import, export, and relocation tables. A static linker uses this information in a
two-phase process analogous to that described for assemblers in Section 15.5. In
the ﬁrst phase, the linker gathers all of the compilation units together, chooses an
order for them in memory, and notes the address at which each will consequently
lie. In the second phase, the linker processes each unit, replacing unresolved exter-
nal references with appropriate addresses, and modifying instructions that need
to be relocated to reﬂect the addresses of their units. These phases are illustrated
EXAMPLE 15.17
Static linking
pictorially in Figure 15.9. Addresses and offsets are assumed to be written in hex-
adecimal notation, with a page size of 4K (100016) bytes.
■
Libraries present a bit of a challenge. Many consist of hundreds of separately
compiled program fragments, most of which will not be needed by any particular
15.6 Linking
799
application. Rather than link the entire library into every application, the linker
needs to search the library to identify the fragments that are referenced from the
main program. If these refer to additional fragments, then those must be included
also, recursively. Many systems support a special library format for relocatable
object ﬁles. A library in this format may contain an arbitrary number of code and
data sections, together with an index that maps symbol names to the sections in
which they appear.
15.6.2 Type Checking
Within a compilation unit, the compiler enforces static semantic rules. Across the
boundaries between units, it uses module headers to enforce the rules pertaining
to external references. In effect, the header for module M makes a set of promises
regarding M’s interface to its users. When compiling the body of M, the compiler
ensures that those promises are kept. Imagine what could happen, however, if
we compiled the body of M, and then changed the numbers and types of param-
eters for some of the subroutines in its header ﬁle before compiling some user
module U. If both compilations succeed, then M and U will have very differ-
ent notions of how to interpret the parameters passed between them; while they
may still link together, chaos is likely to ensue at run time. To prevent this sort of
problem, we must ensure whenever M and U are linked together that both were
compiled using the same version of M’s header.
In most module-based languages, the following technique sufﬁces.
When
compiling the body of module M we create a dummy symbol whose name
uniquely characterizes the contents of M’s header. When compiling the body
of U we create a reference to the dummy symbol. An attempt to link M and U
together will succeed only if they agree on the name of the symbol.
One way to create the symbol name that characterizes M is to use a textual
EXAMPLE 15.18
Checksumming headers
for consistency
representation of the time of the most recent modiﬁcation of M’s header. Because
ﬁles may be moved across machines, however (e.g., to deliver source ﬁles to geo-
graphically distributed customers), modiﬁcation times are problematic: clocks
on different machines may be poorly synchronized, and ﬁle copy operations often
DESIGN & IMPLEMENTATION
15.2 Type checking for separate compilation
The encoding of type information in symbol names works well in C++, but is
too strict for use in C: it would outlaw programming tricks that, while ques-
tionable, are permitted by the language deﬁnition. Symbol-name encoding is
facilitated in C++ by the use of structural equivalence for types. In princi-
ple, one could use it in a language with name equivalence, but given that such
languages generally have well-structured modules, it is simpler just to use a
checksum of the header.
