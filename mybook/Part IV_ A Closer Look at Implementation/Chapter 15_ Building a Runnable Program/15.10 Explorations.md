# 15.10 Explorations

15.10 Our GCD program did not employ subroutines. Extend the grammar of Figure 15.6 to handle procedures without parameters (feel free to adopt any reasonable conventions on the structure of the syntax tree). Be sure to generate appropriate prologue and epilogue code for each subroutine, and to save and restore any needed temporary registers. 15.11 The grammar of Figure 15.6 assumes that all variables are global. In the presence of subroutines, we should need to generate different code (with fp-relative displacement mode addressing) to access local variables and parameters. In a language with nested scopes we should need to derefer- ence the static chain (or index into the display) to access objects that are neither local nor global. Suppose that we are compiling a language with nested subroutines, and are using a static chain. Modify the grammar of Figure 15.6 to generate code to access objects correctly, regardless of scope. You may ﬁnd it useful to deﬁne a to register subroutine that generates the code to load a given object. Be sure to consider both l-values and r-values, and parameters passed by both value and result.

15.12–15.15 In More Depth. 15.10 Explorations

15.16 Investigate and describe the IF of the compiler you use most often. Can you instruct the compiler to dump it to a ﬁle which you can then inspect? Are there tools other than the compiler phases that operate on the IF (e.g., debuggers, code improvers, conﬁguration managers, etc.)? Is the same IF used by compilers for other languages or machines? 15.17 Implement Figure 15.6 in your favorite programming language. Deﬁne appropriate data structures to represent a syntax tree; then generate code for some sample trees via ad hoc tree traversal. 15.18 Augment your solution to the previous exercise to handle various other language features. Several interesting options have been mentioned in ear- lier exercises. Others include functions, ﬁrst-class subroutines, case state- ments, records, arrays (particularly those of dynamic size), and iterators. 15.19 Find out what tools are available on your favorite system to inspect the content of object ﬁles (on a Unix system, use nm or objdump). Consider some program consisting of a modest number (three to six, say) of com- pilation units. Using the appropriate tool, list the imported and exported symbols in each compilation unit. Then link the ﬁles together. Draw an address map showing the locations at which the various code and data segments have been placed. Which instructions within the code segments have been changed by relocation? 15.20 In your favorite C++ compiler, investigate the encoding of type informa- tion in the names of external symbols. Are there strange strings of char-

