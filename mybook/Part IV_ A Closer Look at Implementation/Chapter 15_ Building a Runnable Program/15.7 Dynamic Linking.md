# 15.7 Dynamic Linking

change the modiﬁcation time. A better candidate is a checksum of the header ﬁle: essentially the output of a hash function that uses the entire text of the ﬁle as key. It is possible in theory for two different but valid ﬁles to have the same checksum, but with a good choice of hash function the odds of this error are exceedingly small. ■ The checksum strategy does require that we know when we’re using a mod- ule header. Unfortunately, as described in Section C 3.8, we don’t know this in C and C++: headers in these languages are simply a programming convention, sup- ported by the textual inclusion mechanism of the language’s preprocessor. Most implementations of C do not enforce consistency of interfaces at link time; in- stead, programmers rely on conﬁguration management tools (e.g., Unix’s make) to recompile ﬁles when necessary. Such tools are typically driven by ﬁle modiﬁ- cation times. Most implementations of C++ adopt a different approach, sometimes called name mangling. The name of each imported or exported symbol in an object ﬁle is created by concatenating the corresponding name from the program source with a representation of its type. For an object, the type consists of the class name and a terse encoding of its structure. For a function, it consists of an encoding of the types of the arguments and the return value. For complicated objects or functions of many arguments, the resulting names can be very long. If the linker limits symbols to some too-small maximum length, the type information can be compressed by hashing, at some small loss in security [SF88]. One problem with any technique based on ﬁle modiﬁcation times or check- sums is that a trivial change to a header ﬁle (e.g., modiﬁcation of a comment, or deﬁnition of a new constant not needed by existing users of the interface) can prevent ﬁles from linking correctly. A similar problem occurs with conﬁguration management tools: a trivial change may cause the tool to recompile ﬁles unnec- essarily. A few programming environments address this issue by tracking changes at a granularity smaller than the compilation unit [Tic86]. Most just live with the need to recompile. 15.7 Dynamic Linking

On a multiuser system, it is common for several instances of a program (e.g., an editor or web browser) to be executing simultaneously. It would be highly wasteful to allocate space in memory for a separate, identical copy of the code of such a program for every running instance. Many operating systems therefore keep track of the programs that are running, and set up memory mapping tables so that all instances of the same program share the same read-only copy of the program’s code segment. Each instance receives its own writable copy of the data segment. Code segment sharing can save enormous amounts of space. It does not work, however, for instances of programs that are similar but not identical. Many sets of programs, while not identical, have large amounts of library code in common—for example to manage a graphical user interface. If every appli-

cation has its own copy of the library, then large amounts of memory may be wasted. Moreover, if programs are statically linked, then much larger amounts of disk space may be wasted on nearly identical copies of the library in separate executable object ﬁles.

IN MORE DEPTH

In the early 1990s, most operating system vendors adopted dynamic linking in or- der to save space in memory and on disk. We consider this option in more detail on the companion site. Each dynamically linked library resides in its own code and data segments. Every program instance that uses a given library has a pri- vate copy of the library’s data segment, but shares a single system-wide read-only copy of the library’s code segment. These segments may be linked to the remain- der of the code when the program is loaded into memory, or they may be linked incrementally on demand, during execution. In addition to saving space, dy- namic linking allows a programmer or system administrator to install backward- compatible updates to a library without rebuilding all existing executable object ﬁles: the next time it runs, each program will obtain the new version of the library automatically.

3CHECK YOUR UNDERSTANDING 14. What are the distinguishing characteristics of a relocatable object ﬁle? An ex- ecutable object ﬁle? 15. Why do operating systems typically zero-ﬁll pages used for uninitialized data?

16. List four tasks commonly performed by an assembler. 17. Summarize the comparative advantages of assembly language and object code as the output of a compiler. 18. Give three examples of pseudoinstructions and three examples of directives that an assembler might be likely to provide. 19. Why might an assembler perform its own ﬁnal pass of instruction scheduling?

20. Explain the distinction between absolute and relocatable words in an object ﬁle. Why is the notion of “relocatability” more complicated than it used to be? 21. What is the difference between linking and loading?

22. What are the principal tasks of a linker? 23. How can a linker enforce type checking across compilation units?

