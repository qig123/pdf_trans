# 15.4 Address Space Organization

techniques to improve it in Chapter 17. In the remaining sections of the current chapter we will consider assembly and linking. ■

3CHECK YOUR UNDERSTANDING 1. What is a code generator generator? Why might it be useful? 2. What is a basic block? A control ﬂow graph?

3. What are virtual registers? What purpose do they serve? 4. What is the difference between local and global code improvement?

5. What is register spilling? 6. Explain what is meant by the “level” of an intermediate form (IF). What are the comparative advantages and disadvantages of high-, medium-, and low- level IFs?

7. What is the IF most commonly used in Ada compilers? 8. Name two advantages of a stack-based IF. Name one disadvantage.

9. Explain the rationale for basing a family of compilers (several languages, sev- eral target machines) on a single IF.

10. Why might a compiler employ more than one IF? 11. Outline some of the major design alternatives for back-end compiler organi- zation and structure. 12. What is sometimes called the “middle end” of a compiler?

13. Why is management of a limited set of physical registers usually deferred until late in the compilation process?

15.4 Address Space Organization

Assemblers, linkers, and loaders typically operate on a pair of related ﬁle formats: relocatable object code and executable object code. Relocatable object code is ac- ceptable as input to a linker; multiple ﬁles in this format can be combined to create an executable program. Executable object code is acceptable as input to a loader: it can be brought into memory and run. A relocatable object ﬁle includes the following descriptive information:

Import table: Identiﬁes instructions that refer to named locations whose ad- dresses are unknown, but are presumed to lie in other ﬁles yet to be linked to this one.

Relocation table: Identiﬁes instructions that refer to locations within the current ﬁle, but that must be modiﬁed at link time to reﬂect the offset of the current ﬁle within the ﬁnal, executable program. Export table: Lists the names and addresses of locations in the current ﬁle that may be referred to in other ﬁles.

Imported and exported names are known as external symbols. An executable object ﬁle is distinguished by the fact that it contains no refer- ences to external symbols (at least if statically linked—more on this below). It also deﬁnes a starting address for execution. An executable ﬁle may or may not be relocatable, depending on whether it contains the tables above. Details of object ﬁle structure vary from one operating system to another. Typ- ically, however, an object ﬁle is divided into several sections, each of which is handled differently by the linker, loader, or operating system. The ﬁrst section includes the import, export, and relocation tables, together with an indication of how much space will be required by the program for noninitialized static data. Other sections commonly include code (instructions), read-only data (constants, jump tables for case statements, etc.), initialized but writable static data, and symbol table and layout information saved by the compiler. The initial descrip- tive section is used by the linker and loader. The symbol table section is used by debuggers and performance proﬁlers (Sections 16.3.2 and 16.3.3). Neither of these tables is usually brought into memory at run time; neither is needed by most running programs (an exception occurs in the case of programs that employ reﬂection mechanisms [Section 16.3.1] to examine their own type structure). In its runnable (loaded) form, a program is typically organized into several segments. On some machines (e.g., the 80286 or PA-RISC), segments were visible to the assembly language programmer, and could be named explicitly in instruc- tions. More commonly on modern machines, segments are simply subsets of the address space that the operating system manages in different ways. Some of them—code, constants, and initialized data in particular—correspond to sections of the object ﬁle. Code and constants are usually read-only, and are often com- bined in a single segment; the operating system arranges to receive an interrupt if the program attempts to modify them. (In response to such an interrupt it will most likely print an error message and terminate the program.) Initialized data are writable. At load time, the operating system either reads code, constants, and initialized data from disk, or arranges to read them in at run time, in response to “invalid access” (page fault) interrupts or dynamic linking requests. In addition to code, constants, and initialized data, the typical running pro- gram has several additional segments:

Uninitialized data: May be allocated at load time or on demand in response to page faults. Usually zero-ﬁlled, both to provide repeatable symptoms for pro- grams that erroneously read data they have not yet written, and to enhance security on multiuser systems, by preventing a program from reading the con- tents of pages written by previous users.

