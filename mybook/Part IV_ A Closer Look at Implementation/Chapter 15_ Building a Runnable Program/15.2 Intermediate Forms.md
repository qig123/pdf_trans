# 15.2 Intermediate Forms

**780**
Chapter 15* Building a Runnable Program*

The ﬁnal phase of our example compiler structure consists of register alloca-
tion and instruction scheduling, both of which can be thought of as machine-
speciﬁc code improvement. Register allocation requires that we map the unlim-
ited virtual registers employed in earlier phases onto the bounded set of architec-
tural registers available in the target machine. If there aren’t enough architectural
registers to go around, we may need to generate additional loads and stores to
multiplex a given architectural register among two or more virtual registers. In-
struction scheduling (described in Sections C 5.5 and C 17.6) consists of reorder-
ing the instructions of each basic block in an attempt to ﬁll the pipeline(s) of the
target machine.

15.1.2** Phases and Passes**

In Section 1.6 we deﬁned a* pass* of compilation as a phase or sequence of phases
that is serialized with respect to the rest of compilation: it does not start until
previous phases have completed, and it ﬁnishes before any subsequent phases
start. If desired, a pass may be written as a separate program, reading its input
from a ﬁle and writing its output to a ﬁle. Two-pass compilers are particularly
common. They may be divided between semantic analysis and intermediate code
generation or between intermediate code generation and machine-independent
code improvement. In either case, the ﬁrst pass is commonly referred to as the
“front end” and the second pass as the “back end.”
Like most compilers, our example generates symbolic assembly language as
its output (a few compilers, including those written by IBM for the Power family,
generate binary machine code directly). The assembler (not shown in Figure 15.1)
behaves as an extra pass, assigning addresses to fragments of data and code, and
translating symbolic operations into their binary encodings. In most cases, the
input to the compiler will have consisted of source code for a single compilation
unit. After assembly, the output will need to be* linked* to other fragments of the
application, and to various preexisting subroutine libraries. Some of the work of
linking may be delayed until load time (immediately prior to program execution)
or even until run time (during program execution). We will discuss assembly and
linking in Sections 15.5 through 15.7.
## 15.2

**Intermediate Forms**
An* intermediate form* (IF) provides the connection between phases of machine-
independent code improvement, and continues to represent the program during
the various back-end phases.
IFs can be classiﬁed in terms of their* level*, or degree of machine dependence.
High-level IFs are often based on trees or directed acyclic graphs (DAGs) that
directly capture the hierarchical structure of modern programming languages.

```
Gcc has three main IFs. Most of the (language-speciﬁc) front ends employ, in-
ternally, some variant of a high-level syntax tree form known as GENERIC. Early
phases of machine-independent code improvement use a somewhat lower-level
tree form known as GIMPLE (still a high-level IF). Later phases use a linear form
known as RTL (register transfer language). RTL is a medium-level IF, but a bit
higher level than most: it overlays a control ﬂow graph on of a sequence of pseu-
doinstructions. RTL was, for many years, the principal IF for gcc. GIMPLE was
introduced in 2005 as a more suitable form for machine-independent code im-
provement. We consider GIMPLE and RTL in more detail on the companion
site.
```

15.2.2** Stack-Based Intermediate Forms**

In situations where simplicity and brevity are paramount, designers often turn to
stack-based languages. Operations in a such a language pop arguments from—
and push results to—a common implicit stack. The lack of named operands
means that a stack-based language can be very compact. In certain HP calcu-
lators (Exercise 4.7), stack-based expression evaluation serves to minimize the
number of keystrokes required to enter equations. For embedded devices and
printers, stack-based evaluation in Forth and Postscript serves to reduce memory
and bandwidth requirements, respectively (see Sidebar 15.1).
Medium-levelstack-based intermediate languages are similarly attractive when
passing code from a compiler to an interpreter or virtual machine. Forty years

15.1 Postscript
One of the most pervasive uses of stack-based languages today occurs in doc-
ument preparation. Many document compilers (TEX, Microsoft Word, etc.)
generate Postscript or the related Portable Document Format (PDF) as their
target language. (Most document compilers employ some special-purpose in-
termediate language as well, and have multiple back ends, so they can generate
multiple target languages.)
Postscript is stack-based. It is portable, compact, and easy to generate. It
is also written in ASCII, so it can be read (albeit with some difﬁculty) by hu-
man beings. Postscript interpreters are embedded in most professional-quality
printers. Issues of code improvement are relatively unimportant: most of the
time required for printing is consumed by network delays, mechanical paper
transport, and data manipulations embedded in (optimized) library routines;
interpretation time is seldom a bottleneck. Compactness on the other hand is
crucial, because it contributes to network delays.

