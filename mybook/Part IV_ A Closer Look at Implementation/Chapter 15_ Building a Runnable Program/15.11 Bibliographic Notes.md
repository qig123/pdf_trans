# 15.11 Bibliographic Notes

**806**
Chapter 15* Building a Runnable Program*

acters at the end of every name? If so, can you “reverse engineer” the
algorithm used to generate them? For hints, type “C++ name mangling”
into your favorite search engine.

15.21–15.25 In More Depth.
## 15.11

**Bibliographic Notes**
```
Standard compiler textbooks (e.g., those by Aho et al. [ALSU07], Cooper and Tor-
czon [CT04], Grune et al. [GBJ+12], Appel [App97], or Fischer et al. [FCL10])
are an accessible source of information on back-end compiler technology. More
detailed information can be found in the text of Muchnick [Muc97]. Fraser and
Hanson provide a wealth of detail on code generation and (simple) code improve-
ment in their lcc compiler [FH95].
RTL and GIMPLE are documented in the gcc Internals Manual, available from
www.gnu.org/onlinedocs. Java bytecode is documented by Lindholm and Yellin
[LYBB14]. The Common Intermediate Language is described by Miller and Rags-
dale [MR04].
Ganapathi, Fischer, and Hennessy [GFH82] and Henry and Damron [HD89]
provide early surveys of automatic code generator generators. The most widely
used technique from that era was based on LR parsing, and was due to Glanville
and Graham [GG78]. Fraser et al. [FHP92] describe a simpler approach based on
dynamic programming. Documentation for the LLVM Target-Independent Code
Generator can be found at llvm.org/docs/CodeGenerator.html.
Beck [Bec97] provides a good turn-of-the-century introduction to assemblers,
linkers, and software development tools. Gingell et al. describe the implemen-
tation of shared libraries for the SPARC architecture and the SunOS variant of
Unix [GLDW87].
Ho and Olsson describe a particularly ambitious dynamic
linker for Unix [HO91]. Tichy presents a compilation system that avoids un-
necessary recompilations by tracking dependences at a granularity ﬁner than the
source ﬁle [Tic86].
```

